\documentclass[acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage[dvipsnames]{xcolor}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={let, fix, in}
}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
% \newtheorem{proof}{Proof}[section]


\title{Extrinsic Relational Subtyping}
% \author{}
% \date{}

\begin{document}

% \newcommand{\obj}[1]{\texttt{\small #1}}
\newcommand{\obj}[1]{\texttt{\color{RoyalBlue} #1}}
% \newcommand{\obj}[1]{\textbf{\texttt{#1}}}
\newcommand{\entails}{\vdash}
\newcommand{\satisfies}{\vDash}
\newcommand{\given}{\dashv}

% \newcommand{\tl}{\textasciitilde{}}

\newcommand{\multi}[1]{\widebar{\ #1\ }}
\newcommand{\hastype}{:}
\newcommand{\pattype}{\ \lozenge\ }
\newcommand{\liftfun}{\ \blacktriangle\ }
 
\newcommand{\subtypes}{<:}
\newcommand{\I}{\hspace{4mm}}
\newcommand{\Z}{.\hspace{4mm}}
\newcommand{\Alpha}{\mathrm{A}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\F}[1]{\text{#1}}
\newcommand{\bigand}{\bigwedge\nolimits}
\newcommand{\bigor}{\bigvee\nolimits}
\newcommand{\C}[1]{\color{teal} \rhd\ \emph{#1}}
\newcommand{\D}[1]{\small \textsc{#1}}
% \newcommand{\fig}[1]{Fig. {\color{red} \fig{#1}}}
\newcommand{\FIG}[1]{Fig. {\color{red} \ref{#1}}}
\newcommand{\TODO}[1]{\noindent \B{\color{red} TODO: #1}}

\newcommand{\is}{\ ::=\ }
\newcommand{\sep}{\ \ |\ \ }
\newcommand{\nonterm}[1]{#1\ }
\newcommand{\contin}{|\ \ \ \ \ \ \ }
\newcommand{\case}{\B{case }}
\newcommand{\wrt}{\B{wrt }}
% \newcommand{\let}{\B{let }}
% \newcommand{\for}{\B{for }}
     



\maketitle


\section{Introduction}

\paragraph{Context.} 

%%%%%%%%%%%%%
Automatically catching errors in programs is a hard enough problem
that many languages require users to provide simple specifications to limit that space of correctness.
Languages, such as Java and ML, are \textit{intrinsically typed}, 
requiring nearly all terms to be associated with some type specified by the user. 
The clever design of ML allows annotations to be fairly sparse by 
having types specified at constructor definitions and relying on type inference elsewhere.
However, one of the drawbacks of intrinsically typed languages is that they prevent reusing of
constructors in contexts that are less precise than their intrinsic specifications. For instance,
a \emph{cons} constructor belonging to a list datatype could not be considered amongst a \emph{leaf} constructor
defined as belong to a tree datatype. The user would have to define a new datatype that includes both isomorphs of both \emph{cons}
and \emph{leaf} and also write functions that translate between the isomorphs and the list and tree constructors. 
This not only bloats the codebase, but hurts either the runtime or compiler performance.

For various reasons that may include the reusability drawbacks, intrinsically typed languages have lost favor,
and untyped or \textit{extrinsically typed} languages, 
such as Javascript and Python, have increased in popularity. 
Untyped languages place less initial burden on the programmer to define the upper bounds
on specific combinations of constructors.
The flexibility and reusability of writing code that doesn't have to fit some predefined restriction 
may be seen as one of the benefits of these extrinsically typed languages over the well-studied intrinsically-typed languages.
Unfortunately, this freedom makes static analysis or type inference much more challenging. 

Despite the ever increasing use of untyped languages in production systems, 
the need to automatically verify precise and expressive properties of systems has never been greater.
To this end, researchers have extended the simple types (such as those found in ML) into 
\textit{refinement types}, \textit{predicate subtyping}, and \textit{dependent types}. 

Refinement types offer greater precision than simple types, but still rely on intrinsic type specifications.
Dependent types can express detailed relations, but may require users to provide proofs along with detailed annotations.
Predicate subtyping offers some of the expressivity of dependent types, but with the automatic subtyping of refinement types.
All of these techniques are based on intrinsic typing and therefore require users to provide additional annotations
beyond the runtime behavior of their programs.

The challenge with extrinsically typed languages is that they allow using constructors
in any possible combination, rather than prescribing the upper bound of combinations as in
the datatype mechanism of ML languages. Thus, the crux of typing extrinsically typed programs is
to determine a precise type based on how constructors are used. 
Since the way constructors are use may overlap is various ways, this form of reasoning about types
requires a notion of subtyping.
Type systems for extrinsically typed languages have relied on unions and intersections between types to 
represent precise types based on how expressions are used in combination. 

\paragraph{Gap.} 
Because extrinsically typed languages do not require users to specify the upper bounds of program expressions,
there are many untyped programs that cannot benefit from the typing techniques of 
intrinsically typed languages. Furthermore, extrinsically typed languages do not require users to provide proofs,
that have no runtime behavior, as is sometimes necessary in dependently typed systems to verify more expressive types.   
For instance, the liquid type system \cite{} can verify and infer some relational properties, 
but it requires users to specify ML-style base types and a set of logical qualifiers to draw from.
On the other hand, existing extrinsically typed techniques can not represent richer notions of relations 
beyond the mere shapes of expressions.
Thus, the challenge is to bring rich expressive types to extrinsically typed languages.

\paragraph{Innovation.} 
To overcome the limitations of intrinsic type systems and expand the kinds of programs and types that can be type checked, we introduce \textit{extrinsic relational type inference}: 
a novel system that automatically infers expressive properties from untyped functional programs. 

The main idea behind relational typing is to leverage subtyping as a means to express relations
between objects. This completely obviates the need for the two-level type language
used in liquid types or predicate subtyping. There is no special first-order predicate language. 
In relational typing, a relation is just a type in a subtyping lattice, just as a shape is just  
a type in a subtyping lattice. A subtyping judgment can degenerate into a typing judgment
when the left side or strong side of subtyping is a singleton type (type with a single inhabitant).
\TODO{insert example of (succ zero, cons nil) subs nat list}
Additionally, two separate relations may be compared via subtyping to say that one relation may hold true for a superset of inhabitants 
of another.
\TODO{insert example of even list subs nat list}
By embedding the notion of relations into subtyping the system can reuse techniques for inferring unions and
intersections over simple types, which are necessary in an extrinsic setting. 

In addition to checking that subtyping holds, the system is able to infer weak 
parameter types and strong return types of functions, which then serve as constraints
to be checked according to the applications of functions.

For comparison, the meaning of subtyping relations in relational types corresponds 
to the meaning of implication between qualifiers in liquid types.

While the purely functional setting presented in this work is not suitable for practical programming,
future work could extend it to incorporate side-effects to make it practical.
Alternatively, the purely functional setting could be viewed as an alternative formal foundation more
mathematics, allowing for greater proof automation by allowing reuse of proofs across the transitive closure of 
proposition subtyping.



\section{Overview}

\subsection{Language of types}

\paragraph{Parametric types}
Universal types. Existential type. System F-style. Parameterization of types indexed by types (i.e. second order).

\TODO{mention somwhere that the second order quantification serves two distinct purposes; 1. polymorphism as in System-F. 2. refinement as in first-order quantification of liquid types.
Relational types is able to leverage second-order quantification for refinement, eschewing the first-order quantification used in other systems.
}

\paragraph{Combination types.}
One of the advantages of untyped programs is that they may be written in a flexible manner.
Subtyping is necessary safely reflect the flexibility of compositions in programs, without too many false failures.
Another main advantage of untyped programs is that users don't have to provide type specifications.
Thus, a general way of constructing types from compositions encountered in the the program is necessary.
Some compositions indicate that a type should strengthen, and some compositions indicate that a type should weaken.
To this end, the type language uses intersection and union combinators, 
whose semantics are degenerate versions of those in set-theory.

For instance, when inferring the type of a function, 
the system's goal is to infer the weakest valid parameter type and the strongest valid return type for a function definition.
It strengthens the parameter type with intersection and weakens the return type with union according to the function body,
to arrive at a valid type for the function.  

By contrast, the liquid type language relies on the less flexible tagged unions of ML datatypes, 
which is sufficient in its setting since those types are specified by the user. 
Likewise, it does not rely on union to weaken to a valid return type. 
Instead, it weakens to the strongest valid return type by dropping conjunctions from 
the return type's qualifiers until a valid return type is found.

\paragraph{Inductive types.} Similar to ML datatypes.

\paragraph{Constraint types.}
In addition to expressing the shapes of terms, the system should be able express relations between terms,
such as "a list has the length of some natural number".
Rather than using a distinct syntax for relational predicates, 
the type language treats relations as just another type thereby reusing machinery already 
available for types, such as existential types, union types, and inductive types.
Since parametric types are second order, constraining relations requires subtyping.
Thus, parametric types are extended with constraints in the form of subtyping.



\begin{figure*}[h]

    \begin{lstlisting}[mathescape=true]

        let repeat = case x => fix(case self =>
            case ~zero @ => ~nil @
            case ~succ n => ~cons (x, self n)) in

        let fromList = fix(case self =>
            case ~nil @ => $\hdots$
            case ~cons (x, xs) => $\hdots$) in

        let fromNat = case x n => fromList (repeat x n)

        let fromUno = case (uno => content) => $\hdots$ in
        let fromDos = case (dos => content) => $\hdots$ in
        let fromBoth = case x => (fromUno x, fromDos, x)

        let lessOrEq = fix(case self =>
            case (~zero @, y) => ~true @
            case (~succ x, ~succ y) => self (x, y)
            case (~succ x, ~zero) => ~false @) in

        let max = (case (x, y) => 
            if lessOrEq (x, y) then y else x) in

        $\hdots$


    \end{lstlisting}

\caption{Example program}
\label{fig:program}
\end{figure*}


\subsection{Type Inference}

For a given program, type inference constructs a very precise type. Some programs are simple enough
such that type inference generates singleton types. 

\TODO{example of a inference of intersection of function param applied to multiple arguments (not novel)}

\TODO{example of a inference of intersection of param with multiple functions applied to it (not novel)}

\TODO{example of a inference of union type of branching (not novel)}

\TODO{break example program into parts; inline instead of using figure}

We illustrate the syntax and semantics of programs and types with the example program shown in \FIG{fig:program}.

\paragraph{Path typing.}
Consider the function $\obj{talky}$, which completes a simple English phrase:

\[
  \begin{array}[t]{@{} l}
    \obj{let talky = (}
      \\
      \I \obj{\$ <hello> @ => <world> @}
      \\
      \I \obj{\$ <good> @ => <morning> @} 
      \\
      \I \obj{\$ <thank> @ => <you> @} 
      \\
    \obj{)}
  \end{array}
\]

This program is defined by paths over hardcoded tags.
The system infers the type to be an intersection of implication types:
\[
  \begin{array}[t]{@{} l}
    \obj{TOP}
    \\
    \obj{\& (<hello> @ -> <world> @)}
    \\
    \obj{\& (<good> @ -> <morning> @)} 
    \\
    \obj{\& (<thank> @ -> <you> @)}
  \end{array}
\]

Essentially, the program is so simple, that its type has the exact same meaning merely dressed in a different syntax.

\paragraph{Path selection.}
Just as type inference constructs precise types for introduction forms, 
type inference can select the only viable paths of an application. In the most simple case where
the argument is a singleton, there can be only one viable path, just like the runtime semantics.   

Consider the application \obj{talky(x)} where \obj{x} has the type \obj{(<hello> @)|(<thank> @)}. 
Type inference breaks apart the intersection into paths and finds that only two of the three paths 
match the type of the argument. It determines the type of the application to be the type 
\obj{(<world> @)|(<you> @)}.

\paragraph{Relational typing.} 
Consider the function \obj{repeat} that takes a natural number and returns a list of that length. 

\[
  \begin{array}[t]{@{} l}
      \obj{let repeat = \$ x => loop(\$ self =>}
      \\
      \I \obj{\$ <zero> @ => <nil> @}
      \\
      \I \obj{\$ <succ> n => <cons>(x,self(n))}
      \\
      \obj{)}
  \end{array}
\]


Without specifying any requirements besides the function definition, type inference lifts 
the function into the definitional property as a type. 
To construct the type, type inference constructs a relation between nats and lists.
The type of \obj{repeat} depends on a least fixed point relation between nats and lists 
(parametrically named here for readability).

\[
  \text{natList}(\alpha) = \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT} 
      \\
      \I \obj{| (<zero> @)*(<nil> @)}
      \\
      \I \obj{| (EXI[N L ; N*L <: R](<succ> N)*(<cons> (}\alpha\obj{*L))}
      \\
      \obj{)} 
  \end{array}
\]

Using the \text{natList} relation, type inference then lifts the function repeat into its precise type form.

\[
  \obj{ALL[T] T -> ALL[X] X -> EXI[Y ; X*Y <: }\text{natList}(\obj{T}) \obj{] Y}
\]

It may be worth noting that there could be semantically equivalent recursive type in terms of intersections instead of unions. 

\TODO{forward reference to correctness/model semantics}

\[
  \begin{array}[t]{@{} l}
      \obj{ALL[T] GFP[R]( TOP} 
      \\
      \I \obj{\& (<zero> @)->(<nil> @)}
      \\
      \I \obj{\& (ALL[N L ; R <: N->L](<succ> N)->(<cons> T*L)}
      \\
      \obj{)} 
  \end{array}
\]


Type inference reasons in terms least fixed points, but the greatest fixed point form could
be handled with syntactic sugar and rewriting.  

Using the precise type form, type inference can leverage solving and checking subtyping constraints 
to reason in a number ways: it can reason forward from inputs to outputs (just like the runtime semantics), 
reason backwards from outputs to inputs (like Prolog), and check against weaker specifications. 


\paragraph{Fixed point forward path selection.} Consider the application \obj{repeat(<succ> <succ> <zero> @)(x)} where \obj{x}
has type \obj{T}. Type inference
constructs a singleton type, mirroring the results achieved by simply running the program.  
\[
  \obj{<cons> T * <cons> T * <nil> @}
\]

Path selection and relational selection demonstrate that the declarative type language is expressive enough
to perform evaluation. However, this simply reproduces the effect of the dynamic semantics, 
albeit in a declarative style. For types to be useful in practice, they need to offer ways to
express properties with incomplete information.
The next examples illustrate how the system can compose abstract properties to infer useful properties,
which are not reproducible by dynamic semantics.

\paragraph{Fixed point backwards path selection.} Now suppose we have a function \obj{foo} whose input
type is inferred to be an empty list or a singleton list, \obj{<nil> @ |  <cons> T * <nil> @}.
Given the application \obj{foo(repeat(n)(x))} where \obj{x} has type \obj{T}, type inference can reason backwards to learn
that the type of \obj{n} must be either zero or one. 
\[
  \obj{<zero> @ | <succ> <zero> @}
\]



\paragraph{Vertical weakening (Factoring).} 
Now suppose we have a function \obj{woo} whose input
type is inferred to be a list over elements of type \obj{T}.
\[
  \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT}
      \\
      \I \obj{| <nil> @ }
      \\
      \I \obj{| <cons> T*R}
      \\
      \obj{)}
  \end{array}
\]

Given the application \obj{woo(repeat(n)(x))} where \obj{x} has type \obj{T}, type 
inference discovers that the argument type depends on the relation \text{natList}(\obj{T}), 
and the relation can be factored into a weaker cross product of nats and lists. 
Therefore, the argument meets the requirements
of \obj{woo} and the type of \obj{n} must be the natural numbers.

\[
  \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT} 
      \\
      \I \obj{| <zero> @}
      \\
      \I \obj{| <succ> R}
      \\
      \obj{)} 
  \end{array}
\]


\paragraph{Horizontol weakening (infilling).} 
Now consider a function \obj{boo} whose input type is the natural numbers. 
Suppose we have the application \obj{boo(n)} where n guaranteed to be an even number.
\[
  \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT} 
      \\
      \I \obj{| <zero> @}
      \\
      \I \obj{| <succ> <succ> R}
      \\
      \obj{)} 
  \end{array}
\]
The application requires that type inference check that the nat type is weaker than the even type. 
Type inference sees that if both types were to unroll into an infinite sequence of values
every value in nat would also be in even, therefore the application type checks. 
In particular, type inference leverages the inductive hypothesis, by learning that weaker 
types hold for all the recursive constraints of the stronger type. 
In the case simple recursive types as shown above, the inductive hypothesis is merely a subtyping constraint
on a single variable.
In the case of comparing two relations such as \obj{natList}(\obj{T}) and a corresponding even version, 
the inductive hypothesis would be a subtyping constraint on a pair of variables, which may not be decomposable into
constraints on single variables, so type inference must learn relational constraints, in addition to simple constraints. 


\paragraph{Refinement.}
Consider the function \obj{fromBoth} that calls two functions on some variable of unknown value or type.  
The same variable is used as an argument to two separate functions that have different parameter types.
The type of the variable can be refined by intersecting both parameter types that it must satisfy.
\begin{mathpar}
\\
  \inferrule {} {
    \Delta \cdot \Gamma \vdash \obj{fromBoth} : \obj{(uno : X) \& (dos : Y) -> $\hdots$} 
  }
\\
\end{mathpar}

\paragraph{Path sensitivity.} Consider the function \obj{max} that chooses the maximum of two natural numbers. 
The function must satisfy the property that the result is greater or equal to each of the inputs. 
The system can infer this property by relying on multiple type inference mechanisms, including
relational typing, path selection, refinement, and a special form of refinement that refines a type
by specializing relations it belongs to. The \emph{if-then-else} expression is merely sugar for applying
a function with a \emph{true} path and \emph{false} path to a boolean expression. 
Note that the variables are used in both the condition and the bodies of the if-then-else expression.
To infer a precise type for the if-then-else expression, the types of the variables need to be refined according to 
each path's expected type, but without leaking the refinement outside of that path. 
That is, the refinements must be local or path sensitive.
Moreover, there must be enough paths of the applied function to handle all 
the possible values of the argument.

\TODO{make sure inductive type (LED) is explained clearly}

\TODO{max type inference is wrong; should be an intersection}
\begin{mathpar}
\\
  \inferrule {
    leq\_decide =  
    \left(
    \begin{array}[]{@{} l}
        \obj{induc[LED]} 
        \arcr
        \hspace{4mm} \obj{\{?zero * \_ * ?true\} |}
        \arcr
        \hspace{4mm} \obj{\{?succ X * ?succ Y * B  with X * Y * B <: LED\} |}
        \arcr
        \hspace{4mm} \obj{\{?succ \_ * ?zero * ?false\}}
    \end{array}
    \right)
    \\\\
    max\_spec =  
    \left(
    \begin{array}[]{@{} l}
        \obj{X * Y -> Y \& \{Z with (X * Z * ?true) <: $leq\_decide$\} |}
        \arcr
        \obj{X * Y -> X \& \{Z with (Z * Y * ?false) <: $leq\_decide$\}}
    \end{array}
    \right)
  } {
    \Delta \cdot \Gamma \vdash \obj{max} : max\_spec 
  }
\\
\end{mathpar}

\TODO{more motivating and elucidating examples}
% \paragraph{List bounds.}
% \paragraph{Generalization.} This is motivated by applying the same function to multiple arguments of varying types.
% \paragraph{Object oriented.}  

\section{Language}
The programming language is pure and functional. Its syntax and dynamic semantics 
are fairly standard. The main departure from tradition is that its function
and application rules subsume pattern matching. This departure enables a more direct  
correspondence between the structures of programs and their types, but it is 
not a necessary condition.
The syntax is given in \FIG{fig:syntax}.
It includes functions with pattern matching, records, a fixed point combinator, let binding, 
tags for discriminating cases, and application.
A function consists of a sequence of paths, where each path maps a pattern to an expression.
A record consists of a sequence of fields, where each field maps a unique label to an expression. 
The type language includes tag types, field types, implications, unions, intersections, 
inductions, existentials, universals, top, and bottom. 
The existential type consists of multiple bound variables, a payload containing the bound variables, 
and a subtyping constraint over the bound variables. 
If the bound variables aren't indicated, then all variables in the payload are
assumed to be bound variables. If the subtyping constraint isn't indicated, then it is assumed to 
be a tautology, such as (\obj{unit<:unit}).
The universal type consists of a bound variable, the variable's upper bound, and a payload. If the upper
bound is not indicated, it is assumed to be the top type (\obj{top}).
The typing semantics rely on a typing environment for keeping track of typings of term variables.
The subtyping semantics rely on subtyping environment for keeping track of and constraints on type variables. 
Note that the syntax of the subtyping environment allows an upper bound constraint over a type
rather than merely a type variable to allow for relational constraints. 


\TODO{update tag syntax: \obj{cons;cons;e:cons//cons//T}\ \ \obj{nil;():nil//unit}}


\subsection{Typing}
The typing is given in \FIG{fig:typing}.
Most of the rules are fairly standard. 
The rule for function typing is a bit special in that
it treats a function as a sequence of paths whose type is an intersection of implications,
rather than having a separate pattern matching rule. 
Likewise, the type of a record is an intersection of field types.
The let-binding rule allows for prenex polymorphism by generalizing via subtyping. 


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %% Typing 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{figure*}[h]
% \begin{flalign*}
%   &\boxed{\Gamma \entails e \hastype \tau}&
% \end{flalign*}
% \begin{mathpar}
%   \inferrule[var] { 
%     \obj{$x$:$\tau$} \in \Gamma
%   } {
%     \Gamma \entails x \hastype \tau 
%   } 

%   \inferrule[unit] { 
%   } {
%     \Gamma \entails \obj{()} \hastype \obj{unit}
%   } 


%   \inferrule[tag] { 
%     \Gamma \entails e \hastype \tau 
%   } {
%      \Gamma \entails (\obj{\#$l$ $e$}) \hastype (\obj{?$l$ $\tau$})
%   }

%   \inferrule[rec] { 
%     \bigand_i \Gamma \entails e_i \hastype  \tau_i  
%   } {
%     \Gamma \entails (\widebar{\obj{@$l_i$=$e_i$}}^i)
%     \hastype \obj{\&}_i({\obj{$l_i$:$\tau_i$}})
%   } 

%   \inferrule[fun] {
%     \bigand_i \Gamma_i \entails m_i \hastype \tau_i
%     \\
%     \bigand_i \Gamma;\Gamma_i \entails e_i \hastype \tau'_i
%   } {
%     \Gamma \entails (\widebar{\obj{path $m_i$=>$e_i$}}^i)
%     : \obj{\&}_i(\obj{$\tau_i$->$\tau'_i$})  
%   } 

%   \inferrule[proj] {
%     \Gamma \entails e \hastype \obj{$l$:$\tau$}
%   } {
%     \Gamma \entails \obj{$e$.$l$} \hastype \tau
%   } 

%   \inferrule[app] { 
%     \Gamma \entails e_f \hastype \obj{$\tau'$->$\tau$}
%     \\
%     \Gamma \entails e_a \hastype \tau'
%   } {
%     \Gamma \entails \obj{$e_f$($e_a$)} \hastype \tau
%   } 

%   \inferrule[let] { 
%     \Gamma \entails e_a \hastype \tau_a
%     \\
%     \bullet \entails  \tau_a \subtypes \tau'
%     \\
%     \Gamma;\obj{$x$:$\tau_a$} \entails e_b \hastype \tau
%   } {
%     \Gamma \entails (\obj{let $x$:$\tau'$ = $e_a$ in $e_b$}) 
%     \hastype \tau
%   } 

%   \inferrule[fix] { 
%     \Gamma \entails e \hastype \obj{$\tau$->$\tau$}
%   } {
%     \Gamma \entails \obj{loop($e$)} \hastype \tau
%   } 

%   \inferrule[subsump] { 
%     \Gamma \entails e \hastype \tau' 
%     \\
%     \bullet \entails \tau' \subtypes \tau
%   } {
%     \Gamma \entails e \hastype \tau
%   } 
% \end{mathpar}
% \caption{Typing}
% \label{fig:typing}
% \end{figure*}

\subsection{Subtyping}
The subtyping is given in \FIG{fig:subtyping}.
Some of the rules are fairly standard, including implication, the union rules, and intersection rules.
Note that in addition to left and right rules, union and intersection each have rules for 
interacting with implication's antecedent and consequent, respectively.
The constraint rule checks that a subtyping relation exists as a constraint in the subtyping environment.
The right induction rule is standard and simply unrolls the induction.
The left induction rule relies on the induction principle to construct an 
inductive constraint hypothesis.  
The field and tag rules simply check that the labels match and subtyping holds for their constituent types.
The existential rules are quite special, as they involve a subtyping constraint as part of 
a second-order comprehension. 
The left existential rule checks that subtyping holds for all variations of the payload 
where the subtyping constraint holds. 
The right existential rule checks that subtyping holds for some variation of the payload where the constraint holds.
The left universal rule checks that subtyping holds for some variation of the payload consistent with
the variable's upper bound. 
The right universal rule checks that subtyping holds for all variations of the payload consistent with
the variable's upper bound.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subtyping Solving (A) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %% Subtyping
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{figure*}[h]
% \begin{flalign*}
%   &\boxed{\Delta \entails \tau \subtypes \tau}&
% \end{flalign*}

% \begin{mathpar}

%   \inferrule[anteUnion] {
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$->$\tau_3$}
%     \\
%     \Delta \entails \tau_l \subtypes \obj{$\tau_2$->$\tau_3$}
%   } {
%     \Delta \entails \tau_l \subtypes \obj{($\tau_1$|$\tau_2$)->$\tau_3$}
%   }

%   \inferrule[leftUnion] {
%     \Delta \entails \tau_1 \subtypes \tau_r
%     \\
%     \Delta \entails \tau_2 \subtypes \tau_r
%   } {
%     \Delta \entails \obj{$\tau_1$|$\tau_2$} \subtypes \tau_r
%   }

%   \inferrule[rightUnion1] {
%     \Delta \entails \tau_l \subtypes \tau_1
%   } {
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$|$\tau_2$}
%   }

%   \inferrule[rightUnion2] {
%     \Delta \entails \tau_l \subtypes \tau_2
%   } {
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$|$\tau_2$}
%   }

%   \inferrule[ConsqInter] {
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$->$\tau_2$}
%     \\
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$->$\tau_3$}
%   } {
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$->($\tau_2$\&$\tau_3$)}
%   }

%   \inferrule[rightInter] {
%     \Delta \entails \tau_l \subtypes \tau_1
%     \\
%     \Delta \entails \tau_l \subtypes \tau_2
%   } {
%     \Delta \entails \tau_l \subtypes \obj{$\tau_1$\&$\tau_2$}
%   }

%   \inferrule[leftInter1] {
%     \Delta \entails \tau_1 \subtypes \tau_r
%   } {
%     \Delta \entails \obj{$\tau_1$\&$\tau_2$} \subtypes \tau_r
%   }

%   \inferrule[leftInter2] {
%     \Delta \entails \tau_2 \subtypes \tau_r
%   } {
%     \Delta \entails \obj{$\tau_1$\&$\tau_2$} \subtypes \tau_r
%   }

%   \inferrule[leftExis] { 
%     \F{freeTVs}(\tau_r) \cap \widebar{\alpha} \subseteq \emptyset 
%     \\
%     \bigand_{\Delta'}
%     (\Delta;\Delta' \entails \tau_1 \subtypes \tau_2)
%     \rightsquigarrow
%     (\Delta;\Delta' \entails \tau \subtypes \tau_r)
%   } { 
%     \Delta \entails \obj{\{$\widebar{\alpha}$//$\tau$ with $\tau_1$<:$\tau_2$\}}
%     \subtypes \tau_r
%   }

%   \inferrule[rightExis] { 
%     \F{freeTVs}(\tau_l) \cap \widebar{\alpha} \subseteq \emptyset 
%     \\
%     \Delta;\Delta' \entails \tau_l \subtypes \tau
%     \\
%     \Delta;\Delta' \entails \tau_1 \subtypes \tau_2
%   } { 
%     \Delta \entails \tau_l
%     \subtypes \obj{\{$\widebar{\alpha}$//$\tau$ with $\tau_1$<:$\tau_2$\}}
%   }

%   \inferrule[refl] {
%   } {
%     \Delta \entails \tau \subtypes \tau 
%   }

%   \inferrule[impli] {
%     \Delta \entails \tau_3 \subtypes \tau_1 
%     \\
%     \Delta \entails \tau_2 \subtypes \tau_4
%   } {
%     \Delta \entails \obj{$\tau_1$->$\tau_2$} \subtypes \obj{$\tau_3$->$\tau_4$}
%   } 


%   \inferrule[rightUniv] { 
%     \alpha \not\in \F{freeTVs}(\tau_l)
%     \\
%     \Delta;\obj{$\alpha$<:$\tau'$} \entails \tau_l \subtypes \tau
%   } { 
%     \Delta \entails \tau_l
%     \subtypes \obj{[$\alpha$<:$\tau'$]$\tau$}
%   }

%   \inferrule[leftUniv] { 
%     \alpha \not\in \F{freeTVs}(\tau_r)
%     \\
%     \Delta;\Delta' \entails \tau \subtypes \tau_r
%     \\
%     \Delta;\Delta' \entails \alpha \subtypes \tau'
%   } { 
%     \Delta \entails \obj{[$\alpha$<:$\tau'$]$\tau$}
%     \subtypes \tau_r
%   }

%   \inferrule[cons] {
%     \obj{$\tau_l$<:$\tau_r$} \in \Delta
%   } {
%     \Delta \entails \tau_l \subtypes \tau_r
%   }


%   % left-induc
%   \inferrule[leftInduc] { 
%     \alpha \not\in \F{freeTVs}(\tau_r)
%     \\
%     \Delta;\obj{$\alpha$<:$\tau_r$} \entails \tau 
%     \subtypes \tau_r
%   } { 
%     \Delta \entails \obj{induc[$\alpha$]$\tau$}
%     \subtypes \tau_r
%   }

%   \inferrule[field] {
%     \Delta \entails \tau_1 \subtypes \tau_2
%   } {
%     \Delta \entails \obj{$l$:$\tau_1$} \subtypes \obj{$l$:$\tau_2$}
%   } 


%   % right-induc
%   \inferrule[rightInduc] {
%     \alpha \not\in \F{freeTVs}(\tau_l)
%     \\
%     \Delta;\obj{$\alpha$<:induc[$\alpha$]$\tau$} \entails 
%     \tau_l \subtypes \tau
%   } {
%     \Delta \entails \tau_l
%     \subtypes \obj{induc[$\alpha$]$\tau$}
%   }

%   \inferrule[tag] {
%     \Delta \entails \tau_1 \subtypes \tau_2
%   } {
%     \Delta \entails (\obj{?$l$ $\tau_1$}) \subtypes (\obj{?$l$ $\tau_2$})
%   } 
% \end{mathpar}
% \caption{Subtyping}
% \label{fig:subtyping}
% \end{figure*}


\section{Analysis}

The analysis consists of two main parts. The top level is type inference, which corresponds to typing
and generates a type for an expression. When type inference encounters constraints that its types must adhere to,
it calls unification to solve these constraints. Note that since the types are expressive enough to represent constraints,
an alternative approach of generating constraints and solving them in separate stages could also be designed 
using the same structures. Additional structures for the analysis are given in \FIG{fig:internal}. 
Inference generates a solution set $T$, which contains triples, each with a type variable set, a subtyping environment, and a type.  
Unification generates a solution set $C$, which contains subtyping environments. 


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %% Internal Structures %%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{figure*}[h]
% \[
% \begin{array}{l @{} l}
%   \Omega 
%   &{} \owns \alpha 
%   \\
%   T 
%   &{} \owns (\Omega, \Delta, \tau)
%   \\
%   C 
%   &{} \owns \Delta
%   \\
% \end{array}
% \]
% \caption{Internal Structures}
% \label{fig:internal}
% \end{figure*}

\subsection{Type inference}
The type inference procedure is given in \FIG{fig:infer}.
The procedure depends on four parameters: an type variable set, a subtyping environment, 
a typing environment, and an expression.
The variable set indicates if a type variable's assigned type is allowed to be strengthened or weakened  
during unification.
The subtyping environment indicates the assumed constraints on types containing type variables,
including relational constraints and constraints over single type variables, 
which we also refer to as type assignments.
The typing environment indicates the assumed constraints on term variables.
The expression indicates the inhabitant of the type that is to be inferred.
The procedure returns a set of triples, where each triple consists of a variable set, a subtyping environment,
and a type.
The unit case simply returns a singleton set with the unit type and the environments unchanged. 
The variable case uses the variable as a key to find its type in the typing environment. 
It returns a singleton set containing the found type along with the adjustment set and subtyping environment.
The tag case infers the type of its constituent type and uses its label to construct a tag type.
The record case infers the type of its fields and intersects the constructed field types together.

The function case is of particular importance to type inference in an untyped setting.
For each path in the function, it extracts the term variables of the pattern and associates 
the term variables with fresh type variables. It infers the body of each path 
with an updated variable set and an updated typing environment containing the fresh
type variables of the pattern. By adding the pattern's type variables to the adjustment variable set,
it implies that the parameter type of the path can be strengthened by applications
occurring in the body of the path. This enables adjusting a parameter type to reflect all of its 
occurrences in the body, 
rather than reflecting just its first occurrence and failing on subsequent occurrences. 
Before returning the inferred implication type for the path, the case removes
the the pattern's type variables from the adjustment variable set, ensuring
that those type variables cannot be strengthened or weakened from the outside. 
As with the record case, the inferred implications are intersected together.

The projection case infers the type of the record expression. 
It then calls unify to solve for the projected type by finding
a single field type that is subtyped by the record type. 

The application case also plays an important role in type inference of untyped programs.
It creates a fresh type variable as a placeholder for the inferred type of the application result.
It infers the type of the function and the argument, and then solves for the result type
by unifying the function's type with an implication from the argument type to the result type.
It adds the result type variable to the adjustment variable set when unifying to allow inferring 
types accounting for all the paths that the function might take.
After unifying, it removes the result type variable from the adjustment variable set to ensure
that the type cannot be modified from the outside.
Additionally, since inference and unification actually return sets of solutions,
the application must type check for all function types and all argument types.
If even one combination cannot be unified then the inference of application fails,
indicated by breaking the for-loop, which then implicitly returns an empty set.  

\TODO{update application to merely require some function cases to type check}

the let-binding case infers the type of the argument and checks that
all possible types subtype the annotation and result in a well-typed body. 
It generalizes type variables in the inferred argument type while maintaining
the constraints indicated by the subtyping environment. 

\TODO{update let-binding to generalize only if something is a function-type: e.g. intersection, univeral, implication }

\TODO{update let-binding to merely require some bodies to type check}

The fix case infers inductive types for the parameters and bodies of its
target expression. Moreover, it inductively relates the parameter and body types to each other.
First, it infers the type of the target and calls unify to deconstruct it into the antecedent
and consequent of an implication type. According to the semantics of fix, the antecedent
represents and inductive hypothesis, while the consequent represents and inductive conclusion.
Thus, it uses the inferred structures of the antecedent and consequent to construct an 
inductive relation by ensuring that the antecedent subtypes the inductively bound variable of 
the resulting inductive type.
Finally, the implication type is projected from the constructed relation and generalized with universal.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %% Type inference 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{figure*}[h]
% \begin{flalign*}
%   &\boxed{\F{infer}(\Omega, \Delta, \Gamma, e) = T}&
% \end{flalign*}
% \[
% \begin{array}[t]{@{} l}
%     \F{infer}(\Omega, \Delta, \Gamma, e) \triangleq 
%     \\
%     \I \B{match}\ e

%     \\

%     \I \C{unit}
%     \\
%     \I \B{case } \obj{()} : \{(\Omega, \Delta, \obj{unit})\}

%     \\

%     \I \C{variable}
%     \\
%     \I \B{case } \obj{$x$} : 
%     \\
%     \I\I \B{match } (\obj{$x$:\_} \in \Gamma)
%     \\
%     \I\I \B{case } \F{some}(\tau) : \{(\Omega, \Delta, \tau)\}
%     \\
%     \I\I \B{case } \F{none} : \emptyset 

%     \\

%     \I \C{tag}
%     \\
%     \I \B{case } \obj{\#$l$ $e$}  :  
%     \\
%     \I\I \B{for } (\Omega, \Delta, \tau) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e): 
%      \\
%     \I\I\I \{(\Omega, \Delta, \obj{?$l$ $\tau$})\}

%     \\

%     \I \C{record}
%     \\
%     \I \B{case } \widebar{\obj{@$l$=$e$}}  :  
%     \\
%     \I\I T \leftarrow \{(\Omega, \Delta, \obj{top})\}
%     \\
%     \I\I \B{for } (\obj{@$l$=$e$}) \leftarrow \widebar{\obj{@$l$=$e$}}:
%     \\
%     \I\I\I T \leftarrow (
%     \\
%     \I\I\I\I \B{for } (\Omega, \Delta, \tau_{res}) \leftarrow T:
%     \\
%     \I\I\I\I \B{for } (\Omega, \Delta, \tau) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e): 
%     \\
%     \I\I\I\I\I \{(\Omega, \Delta, \obj{($l$:$\tau$)\&$\tau_{res}$})\}
%     \\
%     \I\I\I )
%     \\
%     \I\I T

%     \\

%     \I \C{function}
%     \\
%     \I \B{case } (\widebar{\obj{path $m$=>$e$}})  :  
%     \\
%     \I\I T \leftarrow \{(\Omega, \Delta, \obj{top})\}
%     \\
%     \I\I \B{for } (\obj{path $m$=>$e$}) \leftarrow (\widebar{\obj{path $m$=>$e$}}): 
%     \\
%     \I\I\I \Omega' \leftarrow \emptyset
%     \\
%     \I\I\I \Gamma' \leftarrow \bullet
%     \\
%     \I\I\I \B{for } x \leftarrow \F{freevars}(m):
%     \\
%     \I\I\I\I \alpha \leftarrow \F{freshTV}() 
%     \\
%     \I\I\I\I \Omega' \leftarrow \Omega' \cup \{\alpha\} 
%     \\
%     \I\I\I\I \Gamma' \leftarrow \Gamma';\obj{$x$:$\alpha$}
%     \\
%     \I\I\I T \leftarrow (
%     \\
%     \I\I\I\I \B{for } (\Omega, \Delta, \tau_{res}) \leftarrow T: 
%     \\
%     \I\I\I\I\I \Omega \leftarrow \Omega \cup \Omega'
%     \\
%     \I\I\I\I\I \B{for } (\Omega, \Delta, \tau_{m}) \leftarrow \F{infer}(\Omega, \Delta, (\Gamma;\Gamma'), m): 
%     \\
%     \I\I\I\I\I \B{for } (\Omega, \Delta, \tau_{e}) \leftarrow \F{infer}(\Omega, \Delta, (\Gamma;\Gamma'), e): 
%     \\
%     \I\I\I\I\I\I \Omega \leftarrow \Omega \backslash \Omega'
%     \\
%     \I\I\I\I\I\I \{(\Omega, \Delta, \obj{($\tau_{m}$->$\tau_{e}$)\&$\tau_{res}$})\}
%     \\
%     \I\I\I )
%     \\
%     \I\I T

%     \\

%     \I \C{projection}
%     \\
%     \I \B{case } \obj{$e$.$l$} :  
%     \\
%     \I\I \alpha \leftarrow \F{freshTV}()
%     \\
%     \I\I \B{for } (\Omega, \Delta, \tau) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e):
%     \\
%     \I\I \B{for } (\Omega, \Delta) \leftarrow \F{unify}(\Omega, \Delta, \tau, (\obj{$l$:$\alpha$})):
%     \\
%     \I\I\I \{(\Omega, \Delta, \alpha)\}
% \end{array}
% \begin{array}[t]{@{} l}
%     \I \C{application}
%     \\
%     \I \B{case } \obj{$e_f$($e_a$)} :  
%     \\
%     \I\I \alpha \leftarrow \F{freshTV}()
%     \\
%     \I\I \Omega \leftarrow \Omega \cup \{\alpha\}
%     \\
%     \I\I \B{for } (\Omega, \Delta, \tau_a) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e_a):
%     \\
%     \I\I \B{for } (\Omega, \Delta, \tau_f) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e_f):
%     \\
%     \I\I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau_f, (\obj{$\tau_a$->$\alpha$}))
%     \\
%     \I\I\I \B{if } \F{empty}(C) \B{ then } \B{break} \B{ else }
%     \\
%     \I\I\I\I \B{for } (\Omega, \Delta) \leftarrow C:
%     \\
%     \I\I\I\I\I \Omega \leftarrow \Omega \backslash \{\alpha\}
%     \\
%     \I\I\I\I\I \{(\Omega, \Delta, \alpha)\}

%     \\

%     \I \C{let}
%     \\
%     \I \B{case } (\obj{let $x$ : $\tau_p$ = $e_a$ in $e_b$}) :  
%     \\
%     \I\I \Omega_{stale} \leftarrow \F{staleTVs}()
%     \\
%     \I\I \B{for } (\Omega, \Delta, \tau_a) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e_a):
%     \\
%     \I\I\I C \leftarrow (
%     \\
%     \I\I\I\I \B{for } (\Omega, \Delta) \leftarrow \F{unify}(\Omega, \Delta, \tau_a, \tau_p):
%     \\
%     \I\I\I\I\I \tau_{\Delta} \leftarrow \F{pack}(\Omega_{stale}, \Delta, \tau_a)
%     \\
%     \I\I\I\I\I \alpha \leftarrow \F{freshTV}()
%     \\
%     \I\I\I\I\I \F{infer}(\Omega, \Delta, (\Gamma;\obj{$x$:[$\alpha$<:$\tau_{\Delta}$]$\alpha$}), e_b)
%     \\
%     \I\I\I ) 
%     \\
%     \I\I\I \B{if } \F{empty}(C) \B{ then } \B{break} \B{ else } C

%     \\

%     \I \C{fix}
%     \\
%     \I \B{case } \obj{loop($e$)} :  
%     \\
%     \I\I \Omega_{stale} \leftarrow \F{staleTVs}()
%     \\
%     \I\I \alpha_{IH} \leftarrow \F{freshTV}()
%     \\
%     \I\I \alpha_{IC} \leftarrow \F{freshTV}()
%     \\
%     \I\I \B{for } (\Omega, \Delta, \tau) \leftarrow \F{infer}(\Omega, \Delta, \Gamma, e):
%     \\
%     \I\I \B{for } (\Omega, \Delta) \leftarrow \F{unify}(\Omega, \Delta, \tau, (\obj{$\alpha_{IH}$->$\alpha_{IC}$})): 
%     \\
%     \I\I\I \tau_{rel} \leftarrow \F{makeRelation}(\Omega_{stale}, \Delta, \tau_{IH}, \tau_{IC})
%     \\
%     \I\I\I \alpha \leftarrow \F{freshTV}()
%     \\
%     \I\I\I \alpha_1 \leftarrow \F{freshTV}()
%     \\
%     \I\I\I \alpha_2 \leftarrow \F{freshTV}()
%     \\
%     \I\I\I \tau_{res} \leftarrow (
%     \\
%     \I\I\I\I \obj{[$\alpha$<:\{$\alpha_1$->$\alpha_2$ with ($\alpha_1$*$\alpha_2$)<:$\tau_{rel}$\}] }
%     \\
%     \I\I\I\I \alpha
%     \\
%     \I\I\I )
%     \\
%     \I\I\I \{(\Omega, \Delta, \tau_{res})\}

% \end{array}
% \]
% \caption{Type inference}
% \label{fig:infer}
% \end{figure*}


\subsection{Subtype unification}
The subtype unification procedure is given in \FIG{fig:unify}.
Unification depends on four parameters: a set of type variables, a subtyping environment, and two types.
The set of type variables indicates the type of variables that may be adjusted 
(triggered by the function and application cases of inference). 
The subtyping environment indicates constraints on type variables.
the left type indicates the stronger type, and the right type indicates the weaker type.
Both types may contain type variables that are unsolved or partially solved.
The procedure returns a set of subtyping environments.

The procedure begins by checking if the two types are syntactically equal.
If equal then subtyping holds but there is nothing that can be unified 
without circular references so the assumed subtyping environment is returned 
unchanged in a singleton set. 

The procedure then pattern matches on the left and right types. 
The first two cases handle assigning variables to types.
The right-variable case first looks up a solution  
for the variable. If a solution is found, then unification proceeds
between the original left type and the solution for the right type.
In the case where unification fails, but the type variable is adjustable,
the procedure updates the type variable with the union of the left type
and the found right type (assuming the constraint is well-formed, 
which includes avoiding circular references). 
If no solution is found for the right variable, then 
the procedure looks for any relational constraints in the subtyping environment
where the left side contains the type variable.
It checks that the left type is consistent with the relational constraints. 
If there are no relational constraints, then the variable is assigned
to the left type (if the constraint is well-formed).
The left-variable rule is similar to the right-variable rule with
one difference being that it uses intersection to strengthen the type variable 
in the case of adjustment. In the case of checking relational constraints, it
ensures that the right type is weaker than what the relational constraints would allow. 

The subsequent cases decompose the types into subproblems. 
The decomposition is given in \FIG{fig:unifyDecomp}. 
The order of the rules 
is critical to ensure that easier constraints are generated. To that end, cases that
strengthen the left side or weaken the right side occur before rules that
weaken the left side or strengthen the right side.

The left existential case first tries to unify the constraint. It's possible that the
constraint cannot be solved, but also isn't invalid, in which case unifying the existential type's constraint 
simply updates the subtyping environment with the unsolved relational constraint. 
With the updated environment, the procedure then unifies the existential type's payload with the right type.
It must do a safety check to ensure that 
the left existential's variables are merely assumed and not witnessed. 
If the constraint is solved then the procedure 
checks that the payload subtypes the right type for every constraint solution.

The right universal case updates the subtyping environment with the universal's variable constraint
and unifies the left type with the payload. As with left existential, the procedure checks that
the universal's type variable is merely assumed and not instantiated.

The left induction rule first tries to factor the inductive type and unify the weakened factored type
with the right type. For example, a relational type between a natural number and a list, can be factored into
a cross product of a natural number type and a list type. 
If factoring fails, then the procedure leverages the induction principle and substitutes the right type 
in for the inductive variable of the left type and unifies the new left type with the right type.    
Note that factoring is employed for the special
case where the right type has variables which cannot be unified 
using induction due to our circularity restriction.  

The cases for antecedent union, consequent intersection, left union, and right intersection
decompose into sub-problems in the same way as the declarative subtyping semantics.

The remaining cases are continued in \FIG{fig:unifyContinue}.
The right existential case simply unifies the left type with the existential's payload
and then unifies the existential's constraint, such that unifying the payload
may bear witness to a type that leads to verifying the constraint. 

\TODO{consider using both forward and backtracking in unification and subtyping rules. 
Since it is not certain which constraint is stronger (in contrast to prolog). Union solutions together}

The right existential case resembles the unification and backtracking approach in Prolog, 
where unification of the payload corresponds to unification of a query with the head of a horn clause,
and solving the existential's constraint after the payload unification corresponds to
solving the horn clause's body after the head's unification.  

The left universal case also unifies in a backtracking fashion analogous to Prolog.
The procedure unifies the universal's payload with the right type,
possibly instantiating the universal's type variable,
which may then be used to unify and check the universal's constraint.

The right induction case attempts to unroll the inductive type just enough
to unify with the left type. To avoid potential infinite unrolling
the procedure relies on a heuristic to see if the left type's pattern
lines up with parts of the the inductive type that are guaranteed to be well-founded. 
If the left type is a pattern with variables that prevents it from being reduced,
then the procedure checks if it is well-formed, meaning it could be solved 
if more information were specified, and then the unsolved relational constraint
is added to the subtyping environment. 

The remaining cases closely mirror their counterparts in the declarative subtyping rules.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% %% Subtype unification 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% \begin{figure*}[h]
% \begin{flalign*}
%   &\boxed{\F{unify}(\Omega, \Delta, \tau_{l}, \tau_{r}) = C}&
% \end{flalign*}
% \[
% \begin{array}[t]{@{} l}
%     \F{unify}(\Omega, \Delta, \tau_{l}, \tau_{r}) \triangleq 
%     \\
%     \I \B{if}\ \tau_l = \tau_r \B{ then } 
%     \\
%     \I\I \{\Delta\} 
%     \\
%     \I \B{else } \B{match}\ \tau_{l}, \tau_{r} 
%     \\

%     \I \C{right variable}
%     \\
%     \I \B{case } \tau_l, \alpha : 
%     \\
%     \I\I \B{match } (\obj{$\alpha$<:\_} \in \Delta)
%     \\
%     \I\I \B{case } \F{some}(\tau) :
%     \\
%     \I\I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau_l, \tau)
%     \\
%     \I\I\I \B{if } \neg \F{empty}(C) \B{ then } C
%     \\
%     \I\I\I \B{else if } (\alpha \in \Omega) \wedge 
%     \\
%     \I\I\I\I \F{constraintWF}(\Delta, \alpha, (\obj{$\tau_l$|$\tau$})) 
%     \\
%     \I\I\I \B{then } \{\Delta;\obj{$\alpha$<:($\tau_l$|$\tau$)}\}
%     \\
%     \I\I\I \B{else } \emptyset 
%     \\
%     \I\I \B{case } \F{none} :
%     \\
%     \I\I\I \Delta_{rel} \leftarrow \F{relCons}(\Delta, \alpha)  
%     \\
%     \I\I\I \B{if } \neg \F{empty}(\Delta_{rel}) \wedge 
%     \\
%     \I\I\I\I \F{strongEnough}(\alpha, \tau_l, \Delta_{rel}) \B{ then }
%     \\
%     \I\I\I\I \{\Delta\}
%     \\
%     \I\I\I \B{else if } \F{constraintWF}(\Delta, \alpha, \tau_l) \B{ then }
%     \\
%     \I\I\I\I \{\Delta;\obj{$\alpha$<:$\tau_l$}\}
%     \\
%     \I\I\I \B{else } \emptyset 
% \end{array}
% \begin{array}[t]{@{} l}
%   \I \C{left variable}
%   \\
%   \I \B{case } \alpha, \tau_r : 
%   \\
%   \I\I \B{match } (\obj{$\alpha$<:\_} \in \Delta)
%   \\
%   \I\I \B{case } \F{some}(\tau) :
%   \\
%   \I\I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau, \tau_r)
%   \\
%   \I\I\I \B{if } \neg \F{empty}(C) \B{ then } C
%   \\
%   \I\I\I \B{else if } (\alpha \in \Omega) \wedge 
%   \\
%   \I\I\I\I \F{constraintWF}(\Delta, \alpha, (\obj{$\tau_r$\&$\tau$})) 
%   \\
%   \I\I\I \B{then } \{\Delta;\obj{$\alpha$<:($\tau_r$\&$\tau$)}\}
%   \\
%   \I\I\I \B{else } \emptyset 
%   \\
%   \I\I \B{case } \F{none} :
%   \\
%   \I\I\I \Delta_{rel} \leftarrow \F{relCons}(\Delta, \alpha)  
%   \\
%   \I\I\I \B{if } \neg \F{empty}(\Delta_{rel}) \wedge 
%   \\
%   \I\I\I\I \F{weakEnough}(\alpha, \Delta_{rel}, \tau_r) \B{ then }
%   \\
%   \I\I\I\I \{\Delta\}
%   \\
%   \I\I\I \B{else if } \F{constraintWF}(\Delta, \alpha, \tau_r) \B{ then }
%   \\
%   \I\I\I\I \{\Delta;\obj{$\alpha$<:$\tau_r$}\}
%   \\
%   \I\I\I \B{else } \emptyset 

%   \\

%   \I \B{case}\ \tau_{l}, \tau_{r}:
%   \\
%   \I\I \F{unifyDecomp}(\Omega, \Delta, \tau_{l}, \tau_{r})
% \end{array}
% \]

% \caption{Subtype unification}
% \label{fig:unify}
% \end{figure*}

% \begin{figure*}[h]
% \begin{flalign*}
%   &\boxed{\F{unifyDecomp}(\Omega, \Delta, \tau_{l}, \tau_{r}) = C}&
% \end{flalign*}
% \[
% \begin{array}[t]{@{} l}
%     \F{unifyDecomp}(\Omega, \Delta, \tau_{l}, \tau_{r}) \triangleq 
%     \\
%     \I \B{match}\ \tau_{l}, \tau_{r} 
%     \\

%     \I \C{left existential}
%     \\
%     \I \B{case } \obj{\{$\widebar{\alpha}$//$\tau$ with $\tau_1$<:$\tau_2$\}}, \tau_r : 
%     \\
%     \I\I (\widebar{\alpha}, [\tau, \tau_1]) \leftarrow \F{rename}(\widebar{\alpha}, [\tau, \tau_1])
%     \\
%     \I\I C \leftarrow \F{unify}(\Delta, \tau_1, \tau_2)
%     \\
%     \I\I \B{match } \F{unsolved}(C)
%     \\
%     \I\I \B{case } \F{some}(\Delta) :
%     \\
%     \I\I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau, \tau_r)
%     \\
%     \I\I\I \B{if } \F{safe}(\widebar{\alpha}, \Delta, C) \B{ then }
%     C \B{ else } \emptyset 
%     \\
%     \I\I \B{case } \F{none} :
%     \\
%     \I\I\I \B{for } \Delta \leftarrow C:
%     \\
%     \I\I\I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau, \tau_r)
%     \\
%     \I\I\I\I \B{if } \F{empty}(C) \B{ then } 
%     \B{break} \B{ else } C 

%     \\

%     \I \C{right universal}
%     \\
%     \I \B{case } \tau_l, (\obj{[$\alpha$<:$\tau'$]$\tau$}) : 
%     \\
%     \I\I ([\alpha], [\tau]) \leftarrow \F{rename}([\alpha], [\tau])
%     \\
%     \I\I \Delta \leftarrow \Delta;\obj{$\alpha$<:$\tau'$}
%     \\
%     \I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau_l, \tau)
%     \\
%     \I\I \B{if } \F{safe}(\{\alpha\}, \Delta, C) \B{ then } C \B{ else } \emptyset 

%     \\

%     \I \C{left induction}
%     \\
%     \I \B{case } \obj{induc[$\alpha$]$\tau$}, \tau_r :
%     \\
%     \I\I \tau_{fac} \leftarrow \F{factor}(\obj{induc[$\alpha$]$\tau$})
%     \\
%     \I\I C \leftarrow \F{unify}(\Omega, \Delta, \tau_{fac}, \tau_r)
%     \\
%     \I\I \B{if } \neg \F{empty}(C) \B{ then } C
%     \\
%     \I\I \B{else }
%     \\
%     \I\I\I \tau \leftarrow \F{sub}(\bullet;\obj{$\alpha$<:$\tau_r$}, \tau) 
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau, \tau_r)
% \end{array}
% \begin{array}[t]{@{} l}

%     \I \C{antecedent union}
%     \\
%     \I \B{case } \tau_l, (\obj{($\tau_1$|$\tau_2$)->$\tau_{res}$}) : 
%     \\
%     \I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau_l, (\obj{$\tau_1$->$\tau_{res}$})):
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau_l, (\obj{$\tau_2$->$\tau_{res}$})) 

%     \\

%     \I \C{consequent intersection}
%     \\
%     \I \B{case } \tau_l, (\obj{$\tau_{arg}$->($\tau_1$\&$\tau_2$)}) : 
%     \\
%     \I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau_l, (\obj{$\tau_{arg}$->$\tau_1$})):
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau_l, (\obj{$\tau_{arg}$->$\tau_2$}))

%     \\

%     \I \C{left union}
%     \\
%     \I \B{case } (\obj{$\tau_1$|$\tau_2$}), \tau_r : 
%     \\
%     \I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau_1, \tau_r):
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau_2, \tau_r) 

%     \\

%     \I \C{right intersection}
%     \\
%     \I \B{case } \tau_l, (\obj{$\tau_1$\&$\tau_2$}) : 
%     \\
%     \I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau_l, \tau_1):
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau_l, \tau_2) 

%     \\

%     \I \C{Continue}
%     \\
%     \I \B{case } \tau_l, \tau_r : \F{unifyContinue}(\Omega, \Delta, \tau_l, \tau_r)
% \end{array}
% \]

% \caption{Subtype unification decomposition}
% \label{fig:unifyDecomp}
% \end{figure*}

% \begin{figure*}[h]
% \begin{flalign*}
%   &\boxed{\F{unifyContinue}(\Omega, \Delta, \tau_{l}, \tau_{r}) = C}&
% \end{flalign*}
% \[
% \begin{array}[t]{@{} l}
%     \F{unifyContinue}(\Omega, \Delta, \tau_{l}, \tau_{r}) \triangleq 
%     \\
%     \I \B{match}\ \tau_{l}, \tau_{r} 

%     \\

%     \I \C{right existential}
%     \\
%     \I \B{case } \tau_l, \obj{\{$\widebar{\alpha}$//$\tau$ with $\tau_1$<:$\tau_2$\}} : 
%     \\
%     \I\I (\widebar{\alpha}, [\tau, \tau_1]) \leftarrow \F{rename}(\widebar{\alpha}, [\tau, \tau_1])
%     \\
%     \I\I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau_l, \tau):
%     \\
%     \I\I\I\I \F{unify}(\Omega, \Delta, \tau_1, \tau_2)


%     \\
%     \I \C{left universal}
%     \\
%     \I \B{case } (\obj{[$\alpha$<:$\tau'$]$\tau$}), \tau_r : 
%     \\
%     \I\I ([\alpha], [\tau]) \leftarrow \F{rename}([\alpha], [\tau])
%     \\
%     \I\I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau, \tau_r):
%     \\
%     \I\I\I\I \F{unify}(\Omega, \Delta, \alpha, \tau')

%     \\

%     \I \C{right induction}
%     \\
%     \I \B{case } \tau_l, \obj{induc[$\alpha$]$\tau$} :
%     \\
%     \I\I \tau_l \leftarrow \F{sub}(\Delta, \tau_l)
%     \\
%     \I\I \B{if } \F{reducible}(\tau_l, \tau_r) \B{ then }
%     \\
%     \I\I\I \tau \leftarrow \F{sub}(\bullet;\obj{$\alpha$<:$\tau_r$}, \tau) 
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau_l, \tau)
%     \\
%     \I\I \B{else }
%     \\
%     \I\I\I \B{match } (\obj{$\tau_l$<:\_} \in \Delta)
%     \\
%     \I\I\I \B{case } \F{some}(\tau_{cache}) :
%     \\
%     \I\I\I\I \F{unify}(\Omega, \Delta, \tau_{cache}, \tau_r)
%     \\
%     \I\I\I \B{case } \F{none} :
%     \\
%     \I\I\I\I \B{if } \F{constraintWF}(\Delta, \tau_l, \tau_r) \B{ then }
%     \\
%     \I\I\I\I\I \{\Delta;\obj{$\tau_l$<:$\tau_r$}\}
%     \\
%     \I\I\I\I \B{else } \emptyset 
% \end{array}
% \begin{array}[t]{@{} l}
%     \I \C{right union}
%     \\
%     \I \B{case } \tau_l, (\obj{$\tau_1$|$\tau_2$}) : 
%     \\
%     \I\I \F{unify}(\Omega, \Delta, \tau_l, \tau_1) \cup \F{unify}(\Omega, \Delta, \tau_l, \tau_2) 

%     \\

%     \I \C{left intersection}
%     \\
%     \I \B{case } (\obj{$\tau_1$\&$\tau_2$}), \tau_r : 
%     \\
%     \I\I \F{unify}(\Omega, \Delta, \tau_1, \tau_r) \cup \F{unify}(\Omega, \Delta, \tau_2\ \tau_r) 

%     \\

%     \I \C{top}
%     \\
%     \I \B{case } \_, \obj{top} : \{\Delta\}

%     \\

%     \I \C{bottom}
%     \\
%     \I \B{case } \obj{bot}, \_ : \{\Delta\}

%     \\

%     \I \C{implication}
%     \\
%     \I \B{case } (\obj{$\tau_{par}$->$\tau_{body}$}), (\obj{$\tau_{arg}$->$\tau_{res}$}) : 
%     \\
%     \I\I \B{for } \Delta \leftarrow \F{unify}(\Omega, \Delta, \tau_{arg}, \tau_{par}):
%     \\
%     \I\I\I \F{unify}(\Omega, \Delta, \tau_{body}, \tau_{res})

%     \\

%     \I \C{field}
%     \\
%     \I \B{case } (\obj{$l_1$:$\tau_1$}), (\obj{$l_2$:$\tau_2$}) :
%     \\
%     \I\I \B{if } l_1 = l_2 \B{ then } \F{unify}(\Omega, \Delta, \tau_1, \tau_2)
%     \\
%     \I\I \B{else } \emptyset 

%     \\

%     \I \C{tag}
%     \\
%     \I \B{case } (\obj{?$l_1$ $\tau_1$}), (\obj{?$l_2$ $\tau_2$}) :
%     \\
%     \I\I \B{if } l_1 = l_2 \B{ then } \F{unify}(\Omega, \Delta, \tau_1, \tau_2)
%     \\
%     \I\I \B{else } \emptyset 
% \end{array}
% \]

% \caption{Subtype unification continuation}
% \label{fig:unifyContinue}
% \end{figure*}

\section{Correctness}

\TODO{introduce model typing and soundness properties}

\section{Experiments}

\TODO{develop 12 tree/list experiments}

\section{Related work}


\paragraph{Tree interpolation}
Exemplified by CHC duality solver.

\paragraph{Hindley-Milner type inference}
Exemplified by ML.

\paragraph{Logic programming.}
Exemplified by Prolog. 


Similar: both have backchaining. 

Different: RLT is fully declarative, lacks negations, but has implication. 

Different: RLT allows comparing inductive relations via subtyping. 

\paragraph{Semantic subtyping.} 
Exemplified by XDuce and CDuce. complete subtyping.

Similar: set-like combinators: union and intersection.

Different: RLT uses rigid syntactic rules; incomplete subtyping.

% set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
"semantics subtyping" means the semantics of types is determined indirectly by the semantics of another structure.
"syntactic subtyping" means the semantics of types is determined directly by the type structure

\paragraph{Extrinsic typing.}
Exemplified by Typescript, which is unsound. Maybe not as lenient?  
The static behavior of a program is not necessarily specified/prescribed; 
it may be over-approximated from the program composition. 
Intrinsic vs extrinsic is orthogonal to static vs dynamic, although static and dynamic are often used to mean the former.
All modern languages use a combination of static and dynamic type checking.
The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.

\paragraph{Refinement Types.}
Exemplified by Refinement ML. Base types with intersections and subtyping.

\paragraph{Predicate Subtyping.}
Exemplified by Liquid Types. An extension of refinement types.

Similar: both use type inference to infer expressive relational properties. 

Different: RLT starts with an invalid post-condition, then weakens return type to a valid post-condition from outside in by expanding unions.

Different: RLT starts with an invalid pre-condition, then strengthens parameter type to a valid pre-condition from inside out by adding intersections.

Different: Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.


\paragraph{Abstraction Refinement.} 
Similar: type unification over subtyping resembles abstraction refinement  
where solving for variables and failing on different sides of the subtyping relation corresponds to
solving with the abstractor vs solving with the refiner.

\paragraph{Craig interpolation.} 
Similar: extracting an inductive type with unions and intersections 
from a recursive program without needing to specify a predicate universe might be similar to
craig interpolation.

\paragraph{PDR.}
exemplified by IC3. 

Similar: RLT infers abstract type for return type, 
then safely constrains the variables in previous step (fix's antecedent) 
to subtype the least fixed point.
This lazily propagates the type for the last step to the previous steps.
This is safe as antecedent is stronger than consequent at any step.
Seems similar to the notion in PDR of propagating negation of loss points to previous steps. 

Different: RLT isn't cartesian



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\TODO{separate out syntactic sugar like pairs, pipe, and let, parens}

\begin{definition}(Expression syntax)
  \label{definition:expression_syntax}
  \[\begin{array}[t]{r@{}l}
    \nonterm{e} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      \obj{$x$} \sep 
      \obj{@} \sep
      \obj{<$l$>$e$} \sep 
      R \sep
      \obj{$e$,$e$} \sep
      F \sep 
      \obj{$e$.$l$} \sep
      \obj{($e$)($e$)} \sep
      \\
      \obj{$e$ |> $e$} \sep
      \obj{loop($e$)} \sep
      \obj{let $x$:$\tau$ = $e$ in $e$} \sep
      \obj{($e$)}
    \end{array}
    \\
    \nonterm{R} & \is \epsilon \sep R\ r
    \\
    \nonterm{r} & \is \obj{\$$l$=>$e$}
    \\
    \nonterm{F} & \is \epsilon \sep F\ f
    \\
    \nonterm{f} & \is \obj{\$$p$=>$e$}
    \\
    \\
    \nonterm{p} & \is 
      \obj{$x$} \sep
      \obj{@} \sep
      \obj{<$l$>$p$} \sep
      K \sep
      \obj{$p$,$p$} \sep
      \obj{($p$)} 
    \\
    \nonterm{K} & \is \epsilon \sep K\ k
    \\
    \nonterm{k} & \is \obj{\$$l$=>$p$}
    \\
    \\
    \nonterm{v} & \is 
      \obj{@} \sep
      \obj{<$l$> $v$} \sep
      G \sep
      \obj{$v$,$v$} \sep
      \obj{($v$)} \sep
      F 
    \\
    \nonterm{G} & \is \epsilon \sep G\ g
    \\
    \nonterm{g} & \is \obj{\$$l$=>$v$}
    \\
    \\
    \nonterm{\Sigma} & \is \epsilon \sep \Sigma\ \sigma
    \\
    \nonterm{\sigma} & \is x \slash v
  \end{array}\]
\end{definition}


\begin{definition}\boxed{e \rightsquigarrow e}\ Progression
  \label{definition:progression}
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{<$l$>$e$} \rightsquigarrow \obj{<$l$>$e'$}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{$R$\$$l$=>$e$} \rightsquigarrow \obj{$R$\$$l$=>$e'$}
    }

    \inferrule {
      R \rightsquigarrow R'
    } {
      \obj{$R$\$$l$=>$v$} \rightsquigarrow \obj{$R'$\$$l$=>$v$}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{$e$.$l$} \rightsquigarrow \obj{$e'$.$l$}
    }

    \inferrule {
      \obj{\$$l$=>$v$} \in G 
      \\
      \forall\ e .\ \obj{\$$l$=>$e$} \in G \implies e = v
    } {
      \obj{$G$.$l$} \rightsquigarrow v
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{($e$)($e_a$)} \rightsquigarrow \obj{($e'$)($e_a$)}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{($v$)($e$)} \rightsquigarrow \obj{($v$)($e'$)}
    }


    \inferrule {
      \obj{$F$($v$)} \rightsquigarrow e'
      \\
      \text{FV}(e) \subseteq \text{FV}(p)
    } {
      \obj{($F$\$$p$=>$e$)($v$)} \rightsquigarrow e' 
    }

    \inferrule {
      p \equiv v \given \Sigma 
      \\
      \forall e'.\ \neg F\obj{($v$)} \rightsquigarrow e' 
    } {
      \obj{($F$\$$p$=>$e$)($v$)} \rightsquigarrow e[\Sigma]
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{loop(e)} \rightsquigarrow \obj{loop(e')}
    }

    \inferrule {
    } {
      \obj{loop(\$$x$=>$e$)} \rightsquigarrow e[x \slash \obj{loop(\$$x$=>$e$)}]
    }



  \end{mathpar}
\end{definition}

\begin{definition}\boxed{e \rightsquigarrow e}\ Progression sugar
  \begin{mathpar}
    \inferrule {
      e_b \obj{(} e_a \obj{)} \rightsquigarrow e' 
    } {
      e_a \obj{|>} e_b \rightsquigarrow e' 
    }

    \inferrule {
      e \rightsquigarrow e' 
    } {
      \obj{(} e \obj{)} \rightsquigarrow e' 
    }

    \inferrule {
      \obj{\$left=>} e_l\ \obj{\$right=>} e_r \rightsquigarrow e' 
    } {
      e_l\obj{,}e_r \rightsquigarrow e' 
    }

    \inferrule {
      \obj{(\$ <true> @=>}e_t \obj{\ \$ <false> @=>}e_f \obj{)(}e_c\obj{)} \rightsquigarrow e'
    } {
      \obj{if}\ e_c\ \obj{then}\ e_t\ \obj{else}\ e_f \rightsquigarrow e' 
    }


    \inferrule {
      \obj{(\$} x \obj{=>} e_k \obj{)(} e \obj{)}
      \rightsquigarrow e'
    } {
      \obj{let}\ x \obj{:} \tau\ \obj{=}\ e\ \obj{in}\ e_k \rightsquigarrow e'
    }

    % \inferrule {
    %   e \rightsquigarrow e'
    % } {
    %   \obj{let $x$:$\tau$ = $e$ in $e_k$} \rightsquigarrow \obj{let $x$:$\tau$ = $e'$ in $e_k$}
    % }

    % \inferrule {
    % } {
    %   \obj{let $x$:$\tau$ = $v$ in $e$} \rightsquigarrow e[x \slash v]
    % }
  \end{mathpar}
\end{definition}


\begin{definition} (Type syntax)
  \label{definition:type_syntax}
  \[\begin{array}[t]{r@{}l}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \obj{@} \sep
      \obj{<}l\obj{>}\tau \sep 
      l\obj{->}\tau \sep 
      \tau\obj{->}\tau \sep 
      \tau\obj{|}\tau \sep 
      \tau\obj{\&}\tau \sep 
      \tau\obj{\textbackslash}\tau \sep 
      \\
      \obj{EXI[}\Alpha \ \Delta \obj{]} \tau \sep 
      \obj{ALL[}\Alpha \ \Delta \obj{]} \tau \sep 
      \obj{LFP[}\alpha\obj{]}\tau
    \end{array}
    \\
    \nonterm{\Alpha} & \is \epsilon \sep \Alpha\ \alpha 
    \\
    \nonterm{\Delta} & \is \epsilon \sep \Delta\ \delta
    \\
    \nonterm{\delta} & \is \obj{;} \tau \obj{<:} \tau
    \\
    \\
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ \gamma
    \\
    \nonterm{\gamma} & \is x : \tau
    \\
    \\
    \nonterm{M} & \is \epsilon \sep M\ m
    \\
    \nonterm{m} & \is \alpha
    \\
    \nonterm{N} & \is \epsilon \sep N\ n
    \\
    \nonterm{n} & \is \alpha
    \\
    \\
    \nonterm{Z} & \is \epsilon \sep Z\ z
    \\
    \nonterm{z} & \is \left< M, \Delta \right>
    \\
    \\
    \nonterm{\Tau} & \is \epsilon \sep \Tau\ \tau
    \\
    \\
    \nonterm{\Pi} & \is \epsilon \sep \Pi\ \pi
    \\
    \nonterm{\pi} & \is \left< M, \Delta, \tau \obj{->} \tau\right>
    \\
    \\
    \nonterm{\Omega} & \is \epsilon \sep \Omega\ \omega
    \\  
    \nonterm{\omega} & \is \alpha \slash \tau
  \end{array}\]
\end{definition}

\begin{definition} \boxed{\Gamma \entails e \hastype \tau \given Z}\ (Proof typing)
  \label{definition:proof_typing}
  \begin{mathpar}
    \inferrule {
      \left< M, \Delta \right> \in Z
    } {
      \Gamma \entails \obj{@} \hastype \obj{@} \given Z 
    }

    \inferrule {
      \left< M, \Delta \right> \in Z
      \\
      \obj{$x$:$\tau$} \in \Gamma
    } {
      \Gamma \entails x \hastype \tau \given Z 
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given Z 
    } {
      \Gamma \entails \obj{<$l$>$e$} \hastype \obj{<$l$>$\tau$} \given Z 
    }

    \inferrule {
      \Gamma \entails R \hastype \tau_0 \given Z_0
      \\
      Z_0 \looparrowright Z_1
      \\
      \Gamma \entails e \hastype \tau_1 \given Z_1
    } {
      \Gamma \entails R\ \obj{*$l$=$e$} \hastype \tau_0\ \obj{\&}\ \obj{$l$:$\tau_1$} \given Z_1
    }

    \inferrule {
      Z, \Gamma \entails F \liftfun \Pi, \Tau_n 
      \\
      \Gamma \entails \Pi \equiv \Tau 
    } {
      \Gamma \entails F \hastype \obj{\&}(\Tau) \given Z
    }

    \inferrule {
      \Gamma \entails e \hastype \tau_0 \given Z_0
      \\
      Z_0 \looparrowright Z_1
      \\
      \tau_0 \subtypes \obj{$l$:$\alpha$} \given Z_1
    } {
      \Gamma \entails \obj{$e$.$l$} \hastype \alpha \given Z_1
    }

    \inferrule {
      \Gamma \entails e_0 \hastype \tau_0 \given Z_0
      \\
      Z_0 \looparrowright Z_1
      \\
      \Gamma \entails e_1 \hastype \tau_1 \given Z_1
      \\
      Z_1 \looparrowright Z_2
      \\
      \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} \given Z_2
    } {
      \Gamma \entails \obj{$e_0$($e_1$)} \hastype \alpha \given Z_2
    }

    \inferrule {
      \Gamma \entails e \hastype \obj{$\alpha_{h^+}$->$\tau$} \given Z_0
      \\
      Z_0 \looparrowright Z_1
      \\
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \\\\
      \text{FTV}(\Gamma) \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \Gamma \entails \obj{loop($e$)} \hastype \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$;$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]]$\alpha_r'$} \given Z_0
    }
  \end{mathpar}
\end{definition}

\begin{definition} \boxed{Z, \Gamma \entails F \liftfun \Pi, T}
  \begin{mathpar}

    \inferrule {
      Z_0, \Gamma_0 \entails f \liftfun \Pi, T 
      \\
      p \hastype \tau_l \given \Gamma_1
      \\
      \text{neg}(\tau_l, T) = \tau_l'
      \\\\
      Z_0 \looparrowright Z_1
      \\
      \Gamma_0 \sqcup \Gamma_1 \entails e \hastype \tau_r \given Z_1
    } {
      Z_0, \Gamma_0 \entails F\ \obj{\$$p$=>$e$} \liftfun 
      \Pi \sqcup \widebar{\left< M, \Delta, \tau_l' \obj{->} \tau_r \right>}^{\left<M, \Delta\right> \in Z_1}, T\ \tau_0
    }
  \end{mathpar}
\end{definition}



\begin{definition} \boxed{Z \looparrowright Z}\ (Universe ordering)
  \label{definition:universe_ordering}
  \begin{mathpar}
    \inferrule {
      \forall M_1\ \Delta_1.\ \left<M_1,\Delta_1\right> \in Z_1 \implies 
      \exists M_0\ \Delta_0.\ \left<M_0,\Delta_0\right> \in Z_0 \land 
      M_0 \preceq M_1 \land \Delta_0 \preceq \Delta_1
    } {
      Z_0 \looparrowright Z_1
    }
  \end{mathpar}
\end{definition}


\TODO{bifurcate proof subtyping into either duals or weakening vs strengthening rules}

\TODO{separate out semantic sugar like combination of implication with union/intersection}

\TODO{note that constraint types are insufficient to represent union, when union is on the rhs (or intersection on the left)}

\TODO{add color to program and type syntax for readabilitiy}
\begin{definition}\boxed{\tau \subtypes \tau \given M, \Delta}\ (Proof subtyping)


  \label{definition:proof_subtyping}
  \begin{mathpar}
    \inferrule {
    } {
      \tau \subtypes \tau \given M, \Delta
    }

    \inferrule {
    } {
      \obj{BOT} \subtypes \tau_r \given M, \Delta
    }

    \inferrule {
    } {
      \tau_l \subtypes \obj{TOP} \given M, \Delta
    }

    \inferrule {
      \tau_l
      \subtypes
      \obj{($l$:$\tau_{rl}$)\&($l$:$\tau_{rr}$)}
      \given M, \Delta
    } {
      \tau_l \subtypes 
      \obj{$l$:($\tau_{rl}$\&$\tau_{rr}$)}
      \given M, \Delta
    }

    \inferrule {
      \tau_{ll} \subtypes \tau_r
      \given M_0, \Delta_0
      \\
      M_0 \preceq M_1
      \\\\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_{lr} \subtypes \tau_r
      \given M_1, \Delta_1
    } {
      \obj{$\tau_{ll}$|$\tau_{lr}$} \subtypes \tau_r
      \given M_1, \Delta_1
    }

    \inferrule {
      \tau_l \subtypes \tau_{rl}
      \given M_0, \Delta_0
      \\
      M_0 \preceq M_1
      \\\\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_{rr}
      \given M_1, \Delta_1
    } {
      \tau_l \subtypes \obj{$\tau_{rl}$\&$\tau_{rr}$} 
      \given M_1, \Delta_1
    }

    \inferrule {
      \tau_l \subtypes
      \obj{($\tau_{ra}$->$\tau_{rc}$)\&($\tau_{rb}$->$\tau_{rc}$)}
      \given M, \Delta
    } {
      \tau_l \subtypes 
      \obj{$\tau_{ra}$|$\tau_{rb}$->$\tau_{rc}$}
      \given M, \Delta
    }

    \inferrule {
      \tau_l \subtypes
      \obj{($\tau_{ra}$->$\tau_{rb}$)\&($\tau_{ra}$->$\tau_{rc}$)}
      \given M, \Delta
    } {
      \tau_l \subtypes \obj{$\tau_{ra}$->$\tau_{rb}$\&$\tau_{rc}$}
      \given M, \Delta
    }

    \inferrule {
      Q \given M_0, \Delta_0
      \\
      \Alpha\ \#\ \tau_r
      \\\\
      M_0 \sqcup \Alpha \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_r
      \given M_1, \Delta_1
    } {
      \obj{EXI[}\Alpha\ Q \obj{]}\tau_l \subtypes \tau_r
      \given M_1, \Delta_1
    }

    \inferrule {
      Q \given M_0, \Delta_0
      \\
      A\ \#\ \tau_l
      \\\\
      M_0 \sqcup \Alpha \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_r
      \given M_1, \Delta_1
    } {
      \tau_l \subtypes \obj{ALL[}\Alpha\ Q \obj{]}\tau_r
      \given M_1, \Delta_1
    }

    \inferrule {
      \alpha \notin M_0
      \\
      M_0, \Delta_0 \entails \Delta_m <:^\star \alpha \slash \tau_r
      \\
      M_0, \Delta_0 \entails \Tau <:^\dagger \alpha
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \sqcup \Delta_m \preceq \Delta_1
      \\
      \obj{|$(\Tau)$} <: \tau_r
      \given M_1, \Delta_1
    } {
      \alpha \subtypes \tau_r
      \given M_1, \Delta_1 \ \alpha <: \tau_r
    }

    \inferrule {
      \alpha \notin M_0
      \\\\
      M_0, \Delta_0 \entails \alpha \slash \tau_l <:^\star \Delta_m
      % \\
      % M_0, \Delta_0 \entails \alpha \star \Delta_{skol}
      \\
      M_0, \Delta_0 \entails \alpha <:^\dagger \Tau 
      \\
      M_0, \Delta_0 \entails \alpha \slash \tau_l \dagger \Delta_{rel}
      \\\\
      M_0 \preceq M_1
      \\
      \Delta_0 \sqcup \Delta_m \preceq \Delta_1
      \\
      \Delta_{rel}\ \obj{$\tau_l$<:\&$(\Tau)$} 
      % \sqcup \widebar{\obj{.$\tau_l$<:$\tau$}}^{\tau \in \Tau}
      \given M_1, \Delta_1
    } {
      \tau_l \subtypes \alpha
      \given M_1, \Delta_1
      % \sqcup \widebar{\tau[\alpha\slash\tau_l]<:z}^{\tau<:z \in \Delta_{skol}} 
      \ \tau_l<:\alpha 
    }

    \inferrule {
      \alpha \in M_0
      \\
      M_0, (\Delta_0 \sqcup \text{factor}(\Delta_0, \alpha)) \entails \alpha <: \Tau 
      \\\\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \obj{\&}(\tau) \subtypes \tau_r
      \given M_1, \Delta_1
    } {
      \alpha \subtypes \tau_r
      \given M_1, \Delta_1
    }

    \inferrule {
      \alpha \in M_0
      \\
      \Delta_0 \entails \Tau <: \alpha
      \\\\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \obj{|}(\Tau)
      \given M_1, \Delta_1
    } {
      \tau_l \subtypes \alpha
      \given M_1, \Delta_1
    }

    \inferrule {
      \tau_l \subtypes \tau_r \given M_0, \Delta_0
      \\\\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      Q
      \given M_1, \Delta_1
    } {
      \obj{ALL[$\Alpha$ $Q$]$\tau_l$}
      \subtypes 
      \tau_r
      \given M_1, \Delta_1 
    }

    \inferrule {
      \tau_l \subtypes \tau_r
      \given M_0, \Delta_0
      \\\\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      Q \given M_1, \Delta_1
    } {
      \tau_l
      \subtypes 
      \obj{EXI[$\Alpha$ $Q$]$\tau_r$}
      \given M_1, \Delta_1
    }

    \inferrule {
      \tau_{ll} \subtypes \tau_r
      \given M, \Delta
    } {
      \obj{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
      \given M, \Delta
    }

    \inferrule {
      \tau_{lr} \subtypes \tau_r
      \given M, \Delta
    } {
      \obj{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
      \given M, \Delta
    }

    \inferrule {
      \tau_l \subtypes \tau_{rl}
      \given M, \Delta
    } {
      \tau_l \subtypes \obj{$\tau_{rl}$|$\tau_{rr}$}
      \given M, \Delta
    }

    \inferrule {
      \tau_l \subtypes \tau_{rr}
      \given M, \Delta
    } {
      \tau_l \subtypes \obj{$\tau_{rl}$|$\tau_{rr}$}
      \given M, \Delta
    }
  \end{mathpar}
\end{definition}

\begin{definition} \boxed{\Alpha\ \#\ \tau}\ Fresh variables 
  \label{definition:fresh_variables}
  \begin{mathpar}
    \inferrule {
      \forall \alpha .\ \alpha \in \Alpha \implies \alpha \notin \text{FV}(\tau)
    } {
      \Alpha\ \#\ \tau
    }
  \end{mathpar}
\end{definition}

\begin{definition} \boxed{\tau \subtypes \tau \given M, \Delta}\ (Proof world subtyping)
  \label{definition:proof_world_subtyping}
  \begin{mathpar}
    \inferrule {
      \tau_l[\alpha\slash\tau_r] \subtypes \tau_r 
      \given M, \Delta
    } {
      \obj{LFP[$\alpha$]$\tau_l$} \subtypes \tau_r 
      \given M, \Delta
    }

    \inferrule {
      \text{decidable}(\Delta_0, \tau_l, \obj{LFP[$\alpha$]$\tau_r$})
      \\\\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_r[\alpha \slash \obj{LFP[$\alpha$]$\tau_r$}]
      \given M, \Delta_1
    } {
      \tau_l \subtypes \obj{LFP[$\alpha$]$\tau_r$}
      \given M, \Delta_1
    }

    \inferrule {
      m \in \text{FTV}(\tau_l) \\ m \in M_0
      \\
      \text{norm}(\obj{$\tau_l$<:LFP[$\alpha$]$\tau_r$}) = \obj{$\tau_l'$<:LFP[$\alpha$]$\tau_r'$}
      \\\\
      \obj{$\tau_l'$<:$\tau$} \in \text{norm}(\Delta_0)
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau \subtypes \obj{LFP[$\alpha$]$\tau_r'$}
      \given M_1, \Delta_1
    } {
      \tau_l \subtypes \obj{LFP[$\alpha$]$\tau_r$}
      \given M_1, \Delta_1
    }

    \inferrule {
      M_0, \Delta_0, \text{FV}(\tau_l) 
      \entails \Omega
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l[\Omega] \subtypes \obj{LFP[$\alpha$]$\tau_r$}
      \given M_1, \Delta_1
      \\
      \text{WF}(\tau_l\obj{<:}\obj{LFP[$\alpha$]$\tau_r$})
    } {
      \tau_l \subtypes \obj{LFP[$\alpha$]$\tau_r$}
      \given M_1, \Delta_1 \ \tau_l<:\obj{LFP[$\alpha$]$\tau_r$}
    }

    \inferrule {
      M, \Delta \entails \tau_l \subtypes \obj{$\tau_r$|$\tau_n$}
    } {
      M, \Delta \entails 
      \obj{$\tau_l$\textbackslash$\tau_n$} \subtypes \tau_r
    }

    \inferrule {
      \text{DF}(\obj{$\tau_r$\textbackslash$\tau_n$})
      \\
      \tau_l \subtypes \tau_r
      \given M, \Delta
      \\\\
      \forall M'\ \Delta' .\ 
      M \preceq M'
      \implies
      \Delta \preceq \Delta'
      \implies
      \neg(\tau_l \subtypes \tau_n \given M', \Delta')
    } {
      \tau_l \subtypes \obj{$\tau_r$\textbackslash$\tau_n$}
      \given M, \Delta
    }

    \inferrule {
      \tau_l \subtypes \tau_r
      \given M, \Delta 
    } {
      \obj{<$l$>$\tau_l$} \subtypes \obj{<$l$>$\tau_r$}
      \given M, \Delta 
    }

    \inferrule {
      \tau_l \subtypes \tau_r
      \given M, \Delta 
    } {
      \obj{$l$:$\tau_l$} \subtypes \obj{$l$:$\tau_r$}
      \given M, \Delta 
    }

    \inferrule {
      \tau_{rl} \subtypes \tau_{ll}
      \given M_0, \Delta_0
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_{lr} \subtypes \tau_{rr}
      \given M_1, \Delta_1 
    } {
      \obj{$\tau_{ll}$->$\tau_{lr}$} \subtypes \obj{$\tau_{rl}$->$\tau_{rr}$}
      \given M_1, \Delta_1 
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\tau \subtypes \tau \given Z}\ (Proof universe subtyping)
  \label{definition:proof_universe_subtyping}
  \begin{mathpar}
    \inferrule {
      \left< M, \Delta \right> \in Z 
      \\
      \forall  M\ \Delta .\  
      \tau_l \subtypes \tau_r \given M, \Delta 
      \iff
      \left< M, \Delta \right> \in Z 
    } {
      \tau_l \subtypes \tau_r \given Z 
    }

  \end{mathpar}
\end{definition}

\begin{definition}\boxed{Q \given M, \Delta}
  \begin{mathpar}
    \inferrule {
      Q \given M_0, \Delta_0
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_r \given M_1, \Delta_1
    } {
      Q \obj{.$\tau_l$<:$\tau_r$}
      \given
      M_1, \Delta_1
    }

    \inferrule {
    } {
      M, \Delta \entails \epsilon
    }
  \end{mathpar}
\end{definition}

\begin{definition}(Collection)
  \[\begin{array}[t]{r@{}l}
    \nonterm{C} & \is \epsilon \sep C\ c
  \end{array}\]
\end{definition}
\begin{definition}\boxed{C \sqcup  C = C}
  \[\begin{array}{rclr}
    C \sqcup \epsilon 
    &=& 
    C
    & \C{empty} 
    \\

    C \sqcup (C'\ c) 
    &=& 
    (C \sqcup C')\ c
    & \C{step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{C \sqcap  C = C}
  \[\begin{array}{rclr}
    C \sqcap \epsilon 
    &=& 
    \epsilon 
    % & \C{empty} 
    \\

    C \sqcap (C'\ c) 
    &=& 
    \begin{cases}
      (C \sqcap C')\ c & \text{if } c \in C\\
      (C \sqcap C') & \text{otherwise}
    \end{cases}
    % & \D{Step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\widebar{\ c\ }^{\vec{t}[P]} \circeq C}\ Comprehension 
  \begin{mathpar}
    \inferrule {
      \forall 
    } {
      \widebar{\ c\ }^{A[P]} \circeq C
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\text{map}(C, t) = C}
  \[\begin{array}{rclr}
    \text{map}(\epsilon, t)
    &=& 
    \epsilon
    & \C{empty} 
    \\

    \text{map}(C\ c, t)
    &=& 
    \text{map}(C, t) \sqcup t(c)
    & \C{step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\widebar{\ c\ }^{c \in C} \circeq C}\ Map sugar 
  \[\begin{array}{rclr}
    \widebar{\ c'\ }^{c \in C} 
    &\circeq& 
    \text{map}(C, \lambda c . c')
    % & \C{comprehension} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{c \in C}
  \begin{mathpar}
    \inferrule {
      c \notin C
    } {
      c \in C\ c 
    }

    \inferrule {
      c \in C
    } {
      c \in C\ c' 
    }
  \end{mathpar}
\end{definition}


\begin{definition} \boxed{C \preceq C}
  \begin{mathpar}
    \inferrule {
    } {
      C \preceq C 
    }

    \inferrule {
      C \preceq C' 
    } {
      C \preceq C'\ c 
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\obj{|}(\Tau) = \tau}
  \[\begin{array}{rclr}
    \obj{|}(\epsilon)
    &=& 
    \obj{BOT}
    & \C{empty} 
    \\

    \obj{|}(\Tau\ \tau)
    &=& 
    \obj{|}(\Tau) \obj{|} \tau
    & \C{step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\obj{\&}(\Tau) = \tau}
  \[\begin{array}{rclr}
    \obj{\&}(\epsilon)
    &=& 
    \obj{TOP}
    & \C{empty} 
    \\

    \obj{\&}(\Tau\ \tau)
    &=& 
    \obj{\&}(\Tau) \obj{\&} \tau
    & \C{step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{M, \Delta \entails m <:^\star \alpha}\ Lower skolem subtyping 
  \begin{mathpar}
    \inferrule {
      m \in M
      \\
      m <: \alpha \in \Delta
    } {
      M, \Delta \entails  m <:^\star \alpha
    }

    % \inferrule {
    %   m' \in M
    %   \\
    %   M, \Delta \entails m <:^\star m' 
    %   \\
    %   m' <: \alpha \in \Delta
    % } {
    %   M, \Delta \entails  m <:^\star \alpha
    % }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{M, \Delta \entails \Delta <:^\star \alpha \slash \tau}\ Universal lower skolem subtyping
  \begin{mathpar}
    \inferrule {
      \forall m\ \tau .\ m <: \tau \in \Delta' \iff  M, \Delta \entails 
      m \in M
      \land
      m <: \alpha \in \Delta
      % m <:^\star \alpha
    } {
      M, \Delta \entails \Delta' <:^\star \alpha \slash \tau
    }
  \end{mathpar}
\end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\star m}\ Upper skolem subtyping 
%   \begin{mathpar}
%     \inferrule {
%       m \in M
%       \\
%       \alpha <: m \in \Delta
%     } {
%       M, \Delta \entails  \alpha <:^\star m 
%     }
%   \end{mathpar}
% \end{definition}

\begin{definition}\boxed{M, \Delta \entails \alpha \slash \tau <:^\star \Delta}\ Universal upper skolem subtyping
  \begin{mathpar}
    \inferrule {
      \forall \tau\ m .\ \tau <: m \in \Delta' \iff  
      m \in M
      \land
      \alpha <: m \in \Delta
% M, \Delta \entails \alpha <:^\star m 
    } {
      M, \Delta \entails \alpha <:^\star \Delta' 
    }
  \end{mathpar}
\end{definition}


% \begin{definition}\boxed{M, \Delta, \Delta \entails M \lessdot \alpha}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \epsilon \lessdot \alpha
%     }

%     \inferrule {
%       m \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails M_1 \lessdot \alpha
%       \\\\
%       M_0, \Delta_0, \Delta_0 \entails M_2 \lessdot m 
%     } {
%       M_0, \Delta_0, \Delta_1 \ m<:\alpha 
%       \entails M_1 \sqcup M_2 \ m \lessdot \alpha
%     }

%     \inferrule {
%       \neg (\tau_l \in M_0 \land \tau_r = \alpha)
%       \\\\
%       M_0, \Delta_0, \Delta_1 \entails M_1 \lessdot \alpha
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r
%       \entails M_1 \lessdot \alpha
%     }
%   \end{mathpar}
% \end{definition}


\begin{definition}\boxed{M, \Delta \entails \tau <:^\dagger \alpha}\ Lower transitive subtyping 
  \begin{mathpar}
    \inferrule {
      \tau \notin M
      \\
      \tau <: \alpha \in \Delta 
    } {
      M, \Delta \entails \tau <:^\dagger \alpha
    }

    \inferrule {
      m \in M
      \\
      M, \Delta \entails \tau <:^\dagger m 
      \\
      m <: \alpha \in \Delta 
    } {
      M, \Delta \entails \tau <:^\dagger \alpha
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{M, \Delta \entails \Tau <:^\dagger \alpha}\ Universal lower transitive subtyping
  \begin{mathpar}
    \inferrule {
      \forall \tau .\ \tau \in \Tau \iff  M, \Delta \entails \tau <:^\dagger \alpha
    } {
      M, \Delta \entails \Tau <:^\dagger \alpha
    }
  \end{mathpar}
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\begin{definition}\boxed{M, \Delta \entails \alpha <:^\dagger \tau}\ Upper transitive subtyping 
  \begin{mathpar}
    \inferrule {
      \tau \notin M
      \\
      \alpha <: \tau \in \Delta 
    } {
      M, \Delta \entails \alpha <:^\dagger \tau
    }

    \inferrule {
      m \in M
      \\
      \alpha <: m \in \Delta 
      \\
      M, \Delta \entails m <:^\dagger \tau 
    } {
      M, \Delta \entails \alpha <:^\dagger \tau 
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{M, \Delta \entails \alpha <:^\dagger \Tau}\ Universal upper transitive subtyping
  \begin{mathpar}
    \inferrule {
      \forall \tau .\ \tau \in \Tau \iff  M, \Delta \entails \alpha <:^\dagger \Tau
    } {
      M, \Delta \entails \alpha <:^\dagger \Tau
    }
  \end{mathpar}
\end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \Tau \ll \alpha}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \epsilon \ll \alpha
%     }

%     \inferrule {
%       \tau \notin M
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau \ll \alpha
%     } {
%       M, \Delta_0, \Delta_1 \ \tau<:\alpha \entails \Tau\ \tau \ll \alpha
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau_0 \ll \alpha
%       \\
%       M, \Delta_0, \Delta_0 \entails \Tau_1 \ll z 
%     } {
%       M, \Delta_0, \Delta_1 \ m<:\alpha \entails \Tau_0 \sqcup \Tau_1 \ll \alpha
%     }

%     \inferrule {
%       \tau_r \neq \alpha
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau \ll \alpha
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \Tau \ll \alpha
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \lessdot M}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \lessdot \epsilon
%     }

%     \inferrule {
%       m \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot M_1 
%       \\\\
%       M_0, \Delta_0, \Delta_0 \entails m \lessdot M_2 
%     } {
%       M_0, \Delta_0, \Delta_1 \ \alpha<:m \entails \alpha \lessdot M_1 \sqcup M_2\ m 
%     }

%     \inferrule {
%       \neg (\tau_r \in M_0 \land \tau_l = \alpha)
%       \\\\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot M_1
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \lessdot M_1
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \ll \Tau}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \ll \epsilon
%     }

%     \inferrule {
%       \tau \notin M
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau
%     } {
%       M, \Delta_0, \Delta_1 \ \alpha<:\tau \entails \alpha \ll \Tau\ \tau
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau_0
%       \\
%       M, \Delta_0, \Delta_0 \entails m \ll \Tau_1
%     } {
%       M, \Delta_0, \Delta_1 \ \alpha<:m \entails \alpha \ll \Tau_0 \sqcup \Tau_1
%     }

%     \inferrule {
%       \tau_l \neq \alpha
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \star \tau <: m}\ Relational transitive skolem subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l) 
%       \\
%       m \in M
%     } {
%       M, \Delta \entails \alpha \star \tau <: m 
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l) 
%       \\
%       m \in M
%       \\
%       \tau <: m \in \Delta
%       \\
%       M, \Delta \entails m <:^\star m' 
%     } {
%       M, \Delta \entails \alpha \star \tau <: m' 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \star \Delta}\ Universal relational transitive skolem subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau_l\ \tau_r .\ \tau_l <: \tau_r \in \Delta \iff  M, \Delta \entails \alpha \star \tau_l <: \tau_r
%     } {
%       M, \Delta \entails \alpha \star \Delta 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \lessdot \Delta}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \lessdot \epsilon
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau)
%       \\
%       m_0 \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot \Delta_2
%       \\
%       M_0, \Delta_0, \Delta_0 \entails m_0 \lessdot M_1 
%     } {
%       M_0, \Delta_0
%       \entails
%       \Delta_1 \ \tau<:m_0
%       \entails
%       \alpha 
%       \lessdot 
%       \Delta_2 \sqcup \widebar{\tau<:m_1}^{m_1 \in M_1}\ \tau<:m_0
%     }

%     \inferrule {
%       \neg (\tau_r \in M_0 \land \alpha \in \text{FTV}(\tau_l))
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot \Delta_2 
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \lessdot \Delta_2
%     }
%   \end{mathpar}
% \end{definition}

\begin{definition}\boxed{M, \Delta \entails \alpha \dagger \tau <: \tau}\ Relational subtyping 
  \begin{mathpar}
    \inferrule {
      \alpha \neq \tau_l
      \\
      \alpha \in \text{FTV}(\tau_l) 
    } {
      \Delta \entails \alpha \dagger \tau_l <: \tau_r 
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{M, \Delta \entails \alpha \slash \tau \dagger \Delta}\ Relational substitution 
  \begin{mathpar}
    \inferrule {
      \forall \tau_l\ \tau_r .\ \tau_l[\alpha\slash\tau] <: \tau_r \in \Delta' \iff  M, \Delta \entails \alpha \dagger \tau_l <: \tau_r
    } {
      M, \Delta \entails \alpha \slash \tau \dagger \Delta' 
    }
  \end{mathpar}
\end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \ll \Delta}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \ll \epsilon
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l)
%       \\
%       \tau \notin M 
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Delta_2 \ \tau_l<:\tau_r
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau)
%       \\
%       m \in M 
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%       \\\\
%       M, \Delta_0, \Delta_0 \entails z \ll \Delta_3 
%     } {
%       M, \Delta_0, \Delta_1 \ \tau<:z \entails \alpha \ll \Delta_2 \sqcup \Delta_3
%     }

%     \inferrule {
%       \alpha \notin \text{FTV}(\tau_l)
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Delta_2
%     }
%   \end{mathpar}
% \end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subtyping Solving (Inductive) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}\boxed{M, \Delta, \Alpha \entails \Omega}
  \begin{mathpar}
    \inferrule {
    } {
      M, \Delta, \epsilon \entails \epsilon
    }

    \inferrule {
      \alpha \notin M 
      \\
      \forall \tau .\ \tau<:\alpha \notin \Delta
      \\
      M, \Delta, A \entails \Omega
    } {
      M, \Delta, A \ \alpha \entails \Omega
    }

    \inferrule {
      \alpha \notin M 
      \\
      \exists \tau .\  \tau<:\alpha \in \Delta
      \\
      M, \Delta, \Alpha \entails \Omega
    } {
      M, \Delta, \Alpha\ \alpha 
      \entails 
      \Omega\ \alpha \slash \obj{|}(\widebar{\ \tau\ }^{\tau<:\alpha \in \Delta})
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{N, M \entails \Pi \equiv \Tau}
  \begin{mathpar}
    \inferrule {
    } {
      N, M \entails \epsilon \equiv \epsilon 
    }

    \inferrule {
      N, M \entails \Pi \equiv \Tau 
      \\
      \text{FTV}(\tau_l) = A_l
      \\
      \text{FTV}(\tau_r) = A_r
      \\\\
      \Delta \entails N \sqcup M \sqcup A_l \sqcup A_r \pitchfork \Delta' 
      \\
      N, M, \Delta' \entails \tau_l\obj{->}\tau_r \equiv^{+} \tau
    } {
      N, M \entails \Pi \left<M, \Delta, \tau_l \obj{->} \tau_r \right> \equiv \Tau\ \tau 
    }
  \end{mathpar}
\end{definition}

\begin{definition}
\boxed{N \entails \alpha \cdot Z \cdot \obj{$\alpha$->$\alpha$} \fallingdotseq \alpha \cdot \Tau}
\ (Fixpoint duality)

\TODO{Note the reason for excluding rigids and skolems from quantification is a way to improve precision, but not necessary for soundness. (Right?). Need to conjure up an example to support this idea.}
  % NOTE: read "z, \- a0 Circle W  . a1 -> a2 --> T" as 
  % - forall x y, (LFP[a] intersect vec{W}: a1 -> a2) <: (x -> y) iff (x, y) <: union of vec{T}
  \begin{mathpar}
    \inferrule {
    } {
      N \entails 
      \alpha_{h^+} \cdot \epsilon \cdot \obj{$\alpha_l$->$\alpha_r$} 
      \fallingdotseq 
      \alpha_{h^-} \cdot \epsilon 
    }

    \inferrule {
      N \entails 
      \alpha_{h^+} \cdot Z \cdot \obj{$\alpha_l$->$\alpha_r$} 
      \fallingdotseq 
      \alpha_{h^-} \cdot \Tau
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
      \\\\
      N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\\\
      N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \equiv^{-} \tau
      % TODO: should skolems be included using universal constraint? 
    } {
      N \entails 
      \alpha_{h^+} \cdot Z \ \left< M,\Delta \right> \cdot \obj{$\alpha_l$->$\alpha_r$} 
      \fallingdotseq 
      \alpha_{h^-} \cdot \Tau\ \tau
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \Alpha \pitchfork \Delta}\ Influential Filter 
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \Alpha \pitchfork \epsilon 
    }

    \inferrule {
      \alpha \in \Alpha  
      \\
      \alpha \in \text{FTV}(\tau_l) \sqcup \text{FTV}(\tau_r)
      \\
      \Delta \entails \Alpha \pitchfork \Delta'
    } {
      \Delta \ \tau_l<:\tau_r \entails N \pitchfork \Delta' \ \tau_l<:\tau_r
    }

    \inferrule {
      \forall \alpha .\ \alpha \in \Alpha \implies \alpha \notin \text{FTV}(\tau_l) \sqcup \text{FTV}(\tau_r)
      \\
      \Delta \entails \Alpha \pitchfork \Delta'
    } {
      \Delta \ \tau_l<:\tau_r \entails \Alpha \pitchfork \Delta'
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \Tau \subtypes \alpha}
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \epsilon \subtypes \alpha
    }

    \inferrule {
      \Delta \entails \Tau \subtypes \alpha
    } {
      \Delta \ \tau<:\alpha \entails \Tau\ \tau \subtypes \alpha
    }

    \inferrule {
      \tau_r \neq \alpha
      \\
      \Delta \entails \Tau \subtypes \alpha
    } {
      \Delta \ \tau_l<:\tau_r \entails \Tau \subtypes \alpha
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \alpha \subtypes \Tau}
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \alpha \subtypes \epsilon
    }

    \inferrule {
      \Delta \entails \alpha \subtypes \Tau
    } {
      \Delta \ \alpha<:\tau \entails \alpha \subtypes \Tau\ \tau
    }

    \inferrule {
      \tau_l \neq \alpha
      \\
      \Delta \entails \alpha \subtypes \Tau
    } {
      \Delta \ \tau_l<:\tau_r \entails \alpha \subtypes \Tau
    }
  \end{mathpar}
\end{definition}



\begin{definition}\boxed{\text{outer}(+|-) = \obj{ALL}|\obj{EXI}}
  \[\begin{array}{rclr}
    \\
    \text{outer}(+) 
    &=& 
    \obj{EXI} 
    & \C{positive} 
    \\
    \text{outer}(-) 
    &=& 
    \obj{ALL} 
    & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\text{inner}(+|-) = \obj{ALL}|\obj{EXI}}
  \[\begin{array}{rclr}
    \\
    \text{inner}(+) 
    &=& 
    \obj{ALL} 
    & \C{positive} 
    \\
    \text{inner}(-) 
    &=& 
    \obj{EXI} 
    & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\text{quantify}^{+|-}(\Alpha, \Delta, \Alpha, \Delta, \tau) = \tau}
  \[\begin{array}{rclr}
    \text{quantify}^{+|-}(\epsilon, \epsilon, \epsilon, \epsilon, \tau) 
    &=& 
    \tau
    \\
    \text{quantify}^{+|-}(\epsilon, \epsilon, \Alpha_i, \Delta_i, \tau) 
    &=& 
    \text{inner}(+|-)\obj{[}\Alpha_i\obj{ }\Delta_i\obj{]}\tau
    \\
    \text{quantify}^{+|-}(\Alpha_o, \Delta_o, \epsilon, \epsilon, \tau) 
    &=& 
    \text{outer}(+|-)\obj{[}\Alpha_o\obj{ }\Delta_o\obj{]}\tau
    \\
    \text{quantify}^{+|-}(\Alpha_o, \Delta_o, \Alpha_i, \Delta_i, \tau) 
    &=& 
    \text{outer}(+|-)\obj{[}\Alpha_o\obj{ }\Delta_o\obj{]}
    \text{inner}(+|-)\obj{[}\Alpha_i\obj{ }\Delta_i\obj{]}
    \tau
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\Alpha, \Alpha, \Delta \entails \tau \equiv^{+|-} \tau}
  \begin{mathpar}
    \inferrule {
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
      \\\\
      (\text{FTV}(\Delta)\ \text{FTV}(\tau))\ \sqcap\ \Alpha_z = \Alpha_o
      \\
      (\text{FTV}(\Delta_i)\ \text{FTV}(\tau))\ \backslash\ \Alpha_z \ \backslash\ \Alpha_r = \Alpha_i
      \\\\
      \text{quantify}^{+|-}(\Alpha_o, \Delta_o, \Alpha_i, \Delta_i, \tau) = \tau'
    } {
      \Alpha_r, \Alpha_z, \Delta \entails \tau \equiv^{+|-} \tau'
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Alpha, \Delta \entails \Delta \wr \Delta}
  \begin{mathpar}
    \inferrule {
    } {
      \Alpha_z, \epsilon \entails \epsilon \wr \epsilon 
    }

    \inferrule {
      \text{FTV}(\tau_l)\ \text{FTV}(\tau_r) = \Alpha_q
      \\
      \forall \alpha .\ \alpha \in \Alpha_q \implies \alpha \in \Alpha_z
      \\
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
    } {
      \Alpha_z, \Delta \ \tau_l<:\tau_r \entails \Delta_o \ \tau_l<:\tau_r \wr \Delta_i 
    }

    \inferrule {
      \text{FTV}(\tau_l)\ \text{FTV}(\tau_r) = \Alpha_q
      \\
      \alpha \in \Alpha_q \\ \alpha \notin \Alpha_z
      \\
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
    } {
      \Alpha_z, \Delta \ \tau_l<:\tau_r \entails \Delta_o \wr \Delta_i \ \tau_l<:\tau_r
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\VDash e}
  \label{definition:expression_good_formation}
  \begin{mathpar}
    \inferrule {
      e = v
    } {
      \VDash e
    } 

    \inferrule { 
      e \rightsquigarrow e' 
      \\
      \VDash e'
    } {
      \VDash e
    } 
  \end{mathpar}
\end{definition}

\begin{theorem}(Typing Soundness)
  \label{theorem:typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \entails e \hastype \tau \given Z
    } {
      \VDash e
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } \entails e \hastype \tau \given Z$
    \item \Z $\B{let } \Omega\ \Gamma' \ \tau' \B{ s.t. } \Omega, \Gamma' \satisfies e \hastype \tau'$ by \D{Lemma \ref{theorem:proof_typing_soundness}}
    \item \Z $\Omega, \Sigma \satisfies \Gamma'$ by ...
    \item \Z $\VDash e[\Sigma]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $e[\Sigma] = e$ by ...
    \item \Z $\VDash e$ by substitution 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof typing consistency)
  \label{theorem:proof_typing_consistency}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \Omega .\ \Omega \satisfies Z
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\begin{theorem}(Proof typing soundness)
  \label{theorem:proof_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \Omega .\ \Omega, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}


\begin{theorem}(Proof typing weak soundness)
  \label{theorem:proof_typing_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \forall \Omega .\ \Omega \satisfies Z \implies \Omega, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}

  \TODO{rewrite inductive hypotheses with just the conclusion implied by the case conditions}

  \TODO{rewrite cases with universal/implication in conclusion/hypotheses}

  Proof: 
  \item $
    \B{assume } 
    \Gamma \entails e \hastype \tau \given Z 
  $ 
    \item \Z $\B{induct on } \Gamma \entails e \hastype \tau \given Z$ 

    \item \Z $\B{case } e = \obj{@} \I \tau = \obj{@}$ 
      \item \Z\Z $\B{let } \Omega$ by definition
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{@} \hastype \obj{@}$ by definition
      \item \Z\Z $\Omega, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \Omega .\ \Omega, \Gamma \satisfies e \hastype \tau$ by witness 

    \item \Z $\B{case } e = x \I \obj{$x$:$\tau$} \in \Gamma$ 
    \item \Z $\B{wrt } x$ 
      \item \Z\Z $\B{let } \Omega$ by definition
      \item \Z\Z $\Omega, \Gamma \satisfies x \hastype \tau$  by definition
      \item \Z\Z $\Omega, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \Omega .\ \Omega, \Gamma \satisfies e \hastype \tau$ by witness 

  \item \Z $\B{case } 
    \Gamma \entails e' \hastype \tau' \given Z
    \I
    \tau = \obj{<$l$>$\tau'$}
    \I
    e = \obj{<$l$>$e'$} 
  $ 
  \item \Z $\B{hypo } 
      \Gamma \entails e' \hastype \tau' \given Z  
      \implies
      \Omega, \Gamma \satisfies e' \hastype \tau'
  $ 
  \item \Z $\B{wrt } e' \ \tau'$ 
    \item \Z\Z $\B{let } \Omega $ by definition
    \item \Z\Z $
      \Omega, \Gamma \satisfies e' \hastype \tau'
    $ by application
    \item \Z\Z $
      \Omega, \Gamma \satisfies \obj{<$l$>$e'$} \hastype \obj{<$l$>$\tau'$}
    $ by definition
    \item \Z\Z $
      \Omega, \Gamma \satisfies e \hastype \tau 
    $ by substitution
    \item \Z\Z $
      \exists \Omega .\ \Omega, \Gamma \satisfies e \hastype \tau 
    $ by witness 

  \item \Z \TODO{remaining trivial introduction cases} 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item \Z $\B{case } $ 
  \item \Z $\B{hypo } $ 
  \item \Z $\B{wrt } $ 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %   \inferrule {
  %     \Gamma \entails R \hastype \tau_0 \given Z_0
  %     \\
  %     Z_0 \looparrowright Z_1
  %     \\
  %     \Gamma \entails e \hastype \tau_1 \given Z_1
  %   } {
  %     \Gamma \entails R\ \obj{*$l$=$e$} \hastype \tau_0\ \obj{\&}\ \obj{$l$:$\tau_1$} \given Z_1
  %   }

  %   \inferrule {
  %     Z, \Gamma \entails F \liftfun \Pi, \Tau_n 
  %     \\
  %     \Gamma \entails \Pi \equiv \Tau 
  %   } {
  %     \Gamma \entails F \hastype \obj{\&}(\Tau) \given Z
  %   }
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau_0 \subtypes \obj{$l$->$\alpha$} \given Z_1
    \I
    e = \obj{$e_0$.$l$} \I \tau = \alpha \I Z = Z_1
  $
   
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0 
    \implies 
    \Omega, \Gamma \satisfies e_0 \hastype \tau_0
  $ 
  \item \Z $\B{wrt } \Omega\ e' \ l \ \alpha \ \tau_0 \ Z_0 \ Z_1$ 

    \item \Z\Z $
      \Omega, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application

    \item \Z\Z $
      \B{let }
      M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \obj{$l$->$\alpha$} \given M, \Delta
    $ by theorem \ref{theorem:proof_subtyping_choice}


    \item \Z\Z $
      \Omega \satisfies \tau_0  \subtypes \obj{$l$->$\alpha$}
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness}
    \item \Z\Z $
      \Omega, \Gamma \satisfies e_0 \hastype \obj{$l$->$\alpha$}
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \Omega, \Gamma \satisfies \obj{$e_0$.$l$} \hastype \alpha 
    $ by theorem \ref{theorem:model_subtyping_record_elimination} 
    \item \Z\Z $
      \Omega, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \Omega .\ \Omega, \Gamma \satisfies e \hastype \tau
    $ by witness 


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \I
    e = \obj{$e_0$($e_1$)} 
    \I 
    \tau = \alpha 
    \I
    Z = Z_2
  $ 
  \item \Z $ 
    Z_1 \looparrowright Z_2
    \I
    \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} \given Z_2
  $ 
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \implies 
    \Omega, \Gamma \satisfies e_0 \hastype \tau_0
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \implies 
    \Omega, \Gamma \satisfies e_1 \hastype \tau_1
  $ 
  \item \Z $\B{wrt } e_0\ e_1\ \alpha\ \tau_0\ \tau_1\ Z_0\ Z_1\ Z_2 $ 
    \item \Z\Z $
      \Omega, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application
    \item \Z\Z $
      \Omega, \Gamma \satisfies e_1 \hastype \tau_1
    $ by application

    \item \Z\Z $
      \B{let } M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} \given \left<M, \Delta \right>
    $ by theorem \ref{theorem:proof_subtyping_choice} 
    \item \Z\Z $
      \Omega, \Gamma \satisfies \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness} 
    \item \Z\Z $
      \Omega \satisfies e_0 \hastype \obj{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \Omega, \Gamma \satisfies \obj{$e_0$($e_1$)} \hastype \alpha
    $ by theorem \ref{theorem:model_typing_implication_elimination} 
    \item \Z\Z $
      \Omega, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \Omega .\ \Omega, \Gamma \satisfies e \hastype \tau
    $ by substitution 

  \item \Z $\B{case } 
    e = \obj{loop($e'$)} 
  $ 
  \item \Z $\contin  
    \tau = \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFLFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$} 
  $
  \item \Z $\contin 
    Z = Z_0 
  $
  \item \Z $\contin  
    \Gamma \entails e' \hastype \obj{$\alpha_{h^+}$->$\tau'$} \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau' \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
  $ 
  \item \Z $\contin  
    \text{FTV}(\Gamma) \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{hypo } 
    \forall \Omega .\ \Omega \satisfies Z_0 \implies
    \Omega, \Gamma \satisfies e' \hastype \obj{$\alpha_{h^+}$->$\tau'$}
  $ 
  \item \Z $\B{wrt } e'\ \tau'\ \alpha_{h^+}\ \alpha_l\ \alpha_r\ \alpha_{h^-}\ \alpha_l'\ \alpha_r'\ \Tau\ Z_0\ Z_1 $ 
    \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies Z$
      \item \Z\Z\Z $\Omega \satisfies Z_0$ by substitution
      \item \Z\Z\Z $
        \Omega, \Gamma \satisfies e' \hastype \obj{$\alpha_{h^+}$->$\tau'$}
      $ by instantiation and application
      \item \Z\Z\Z $
        \Omega \satisfies \tau' \subtypes 
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$}
      $ by theorem \ref{theorem:fixpoint_duality_soundness}

      \item \Z\Z\Z $
        \Omega \satisfies \tau' \subtypes \tau
      $ by substitution  

      \item \Z\Z\Z $
        \Omega \satisfies e' \hastype \obj{$\alpha_{h^+}$->$\tau$}
      $ by theorem \ref{theorem:model_subtyping_elimination} 

      \item \Z\Z\Z $
        \Omega \satisfies \obj{loop($e'$)} \hastype \tau 
      $ by theorem \ref{theorem:model_typing_implication_independence}

      \item \Z\Z\Z $
        \Omega \satisfies e \hastype \tau 
      $ by substitution 

    \item \Z\Z $
      \forall \Omega .\ \Omega \satisfies Z \implies \Omega \satisfies e \hastype \tau 
    $ by implication and generalization 

  \item \Z $\Omega, \Gamma \satisfies e \hastype \tau$
    by induction
  \item $\square$
\end{theorem}

\begin{theorem}(Fixpoint duality soundness (new))
  \label{theorem:fixpoint_duality_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \\
      \text{FTV}(\tau) \subseteq N
      \\
      \alpha_l \notin N
      \\
      \alpha_r \notin N
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \Omega \satisfies 
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\TODO{Cretin's corresponding theorem is Theorem 101 on p. 134}

\TODO{See how Cretin proves this without using subject reduction}

\begin{theorem}(Fixpoint duality soundness old)
  \label{theorem:fixpoint_duality_soundness_old}
  \begin{mathpar}
    \inferrule { 
      Z_0 \looparrowright Z_1
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \forall \tau .\ 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume }
    Z_0 \looparrowright Z_1
    \I
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $ 
  \item \Z $\B{induct on }
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{case }
    Z_1 = \epsilon \I \Tau = \epsilon
  $
    \item \Z\Z $\B{for } \tau$
      \item \Z\Z\Z $\B{assume }
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      $
        \item \Z\Z\Z\Z $
          \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given \epsilon 
        $ by substitution

        \item \Z\Z\Z\Z $
          \B{let } M\ \Delta\ \B{ s.t. } \left<M, \Delta\right> \in \epsilon 
        $ by theorem \ref{theorem:universe_proof_typing_worldly}  

        \item \Z\Z\Z\Z $\bot$ by theorem \ref{theorem:empty_containment_absurd}
      \item \Z\Z\Z $
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
        \implies
        \tau
        \subtypes
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
        \given Z_0
      $ by implication
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by generalization 
  \item \Z $\B{case }
    Z_1 = Z\ \left<M, \Delta \right> \I \Tau = \Tau_i\ \tau_i
  $
  \item \Z $\contin
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \obj{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
  $
  \item \Z $\contin
    M, \Delta, \Delta \entails \alpha_{h^+} \subtypes \Tau_h
    \I
    M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
    \I
    M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
  $
  \item \Z $\contin
    \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\ \tau_r .\ \tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
  $
  \item \Z $\contin
    N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
    \I
    \Delta \entails \Alpha \pitchfork \Delta_i  
  $
  \item \Z $\contin
    N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \equiv^{-} \tau_i
  $
  \item \Z $\B{hypo }
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \obj{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
    \implies
    \\
    \forall \tau .\ 
    \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z
    \implies
    \tau
    \subtypes
    \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
    \given Z_0
  $
  \item \Z $\B{wrt }
    Z\ M\ \Delta\ \Tau_i\ \tau_i
  $

    \item \Z\Z $\B{for } \tau \B{ assume }
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
    $
      \item \Z\Z\Z $
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z\ \left<M, \Delta\right>
      $ by substitution

      \item \Z\Z\Z $
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      $ by theorem \ref{theorem:proof_subtyping_decomposition}

      \item \Z\Z\Z $
        \tau
        \subtypes
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by instantiation and application 
      \item \Z\Z\Z $
        \tau
        \subtypes
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by theorem \ref{theorem:universe_proof_typing_fixpoint_extension}
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by implication and generalization 


  \item \Z $
    \forall \tau .\ 
    \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
    \implies
    \tau
    \subtypes
    \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    \given Z_0
  $ by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint extension)
  \label{theorem:universe_proof_typing_fixpoint_extension}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r$} 
      \\\\
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \equiv^{-} \tau_i
    } {
      \Omega \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing case soundness)
  \label{theorem:universe_proof_typing_case_soundnes}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \equiv^{-} \tau_i
    } {
      \Omega \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau_i$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint union)
  \label{theorem:universe_proof_typing_fixpoint_union}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau$)]$\alpha_r$} 
      \\
      \Omega \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau$]$\alpha_r$} 
    } {
      \Omega \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau\ \tau$)]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}\ Influential soundness 
  \label{theorem:influential_soundness}

  \TODO{Prove that any constraints on non-influential variables with have been transitively applied to the influential variables}

  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given M, \Delta
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      \text{FTV}(\tau) \subseteq \Alpha
      \\\\
      N, M, \Delta \sqcup \Delta' \given \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \equiv^- \tau
      \\
      N, M, \Delta_i \sqcup \Delta' \given \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \equiv^- \tau_i
    } {
      \Omega \satisfies \tau \subtypes \tau_i 
      \land
      \Omega \satisfies \tau_i \subtypes \tau
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

% \begin{theorem}(Universe proof typing implication expansion)
%   \label{theorem:universe_proof_typing_implication}
%   \begin{mathpar}
%     \inferrule { 
%       M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
%       \\
%     } {
%       \obj{\&$(\Tau_l)$->|$(\Tau_r)$}
%       \subtypes
%       \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:(\&$(\Tau_l)$,|$(\Tau_r)$)]$\alpha_r$} 
%       \given M, \Delta
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Universe proof typing implication expansion)
  \label{theorem:universe_proof_typing_implication_expansion}
  \begin{mathpar}
    \inferrule { 
    } {
      \obj{$\tau_l$->$\tau_r$}
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:($\tau_l$,$\tau_r$)]$\alpha_r$} 
      \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\forall x \in X .\ \exists y .\ (x,y) \in (X \times Y)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\neg (\exists x \in X \land \nexists y \in Y)$} 
  \item $\square$
\end{theorem}

\begin{theorem}(Upper bound interpretation sound)
  \label{theorem:upper_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \alpha \subtypes \Tau 
    } {
     \alpha \subtypes \obj{\&$(\Tau)$} \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Lower bound interpretation sound)
  \label{theorem:lower_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \Tau \subtypes \alpha
      \\
    } {
     \obj{|$(\Tau)$} \subtypes \alpha \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Universe proof typing worldly)
  \label{theorem:universe_proof_typing_worldly}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta\ .\ \left<M, \Delta\right> \in Z
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Empty containment absurd)
  \label{theorem:empty_containment_absurd}
  \begin{mathpar}
    \inferrule { 
      \left<M, \Delta\right> \in \epsilon 
    } {
      \bot
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing implication independence)
  \label{theorem:model_typing_implication_independence}
  \begin{mathpar}
    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$->$\tau_r$} 
      \\
      \Omega \satisfies \tau_r
    } {
      \Omega, \Gamma \satisfies \obj{loop($e$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


% \begin{theorem}(Proof typing fix interpolation weakest pre-condition)
%   \label{theorem:fix_duality}
%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \obj{$\alpha_0$->$\alpha_1$->$\alpha_2$} \given Z_1
%       \\\\
%       \text{FTV}(\Gamma) \entails \alpha_0 \cdot Z_1 \cdot \obj{$\alpha_1$->$\alpha_2$} \fallingdotseq \alpha_3 \circlearrowright \Tau_{rel}
%     } {
%       \obj{ALL[$\alpha_4$]$\alpha_4$->EXI[$\alpha_5$.($\alpha_4$,$\alpha_5$)<:LFP[$\alpha_3$.|$(\Tau_{rel})$]]$\alpha_5$} 
%       \subtypes
%       \obj{$\alpha_1$->$\alpha_2$}
%       \given Z_1
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Proof subtyping decomposition)
  \label{theorem:proof_subtyping_decomposition}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z\ \left<M, \Delta\right>
    } {
      \tau_l \subtypes \tau_r \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Proof subtyping choice)
  \label{theorem:proof_subtyping_choice}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta .\ \tau_l \subtypes \tau_r \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Model subtyping elimination)
  \label{theorem:model_subtyping_elimination}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \tau_l \subtypes \tau_r
      \\
      \Omega, \Gamma \satisfies e \hastype  \tau_l  
    } {
      \Omega, \Gamma \satisfies e \hastype \tau_r 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \Omega \satisfies \tau_l \subtypes \tau_r
    \I
    \Omega, \Gamma \satisfies e \hastype  \tau_l  
  $
  \item \Z $\B{invert on } \Omega \satisfies \tau_l \subtypes \tau_r$
  \item \Z $\B{case } \forall e'\ \Gamma' .\ \Omega, \Gamma' \satisfies e' \hastype  \tau_l  \implies \Omega, \Gamma' \satisfies e' \hastype \tau_r$
  \item \Z\Z $\Omega, \Gamma \satisfies e \hastype  \tau_l  \implies \Omega, \Gamma \satisfies e \hastype \tau_r$ by instantiation
  \item \Z\Z $\Omega, \Gamma \satisfies e \hastype \tau_r$ by application 
  \item \Z $\Omega, \Gamma \satisfies e \hastype \tau_r$ by inversion
  \item $\square$ by implication
\end{theorem}


\begin{theorem}(Model typing record elimination)
  \label{theorem:model_subtyping_record_elimination}
  \begin{mathpar}
    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \obj{$l$->$\tau$}
    } {
      \Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \Omega, \Gamma \satisfies e \hastype \obj{$l$->$\tau$}
  $ 
    \item \Z $\B{induct on } 
      \Omega, \Gamma \satisfies e \hastype \obj{$l$->$\tau$}
    $ 
    \item \Z $\B{case }
      e = G
      \I
      \obj{\$$l$=>$v$} \in G
      \I
      \Omega, \Gamma \satisfies v \hastype \tau
      \I
      \forall v' .\ \obj{\$$l$=>$v'$} \in G \implies v' = v 
    $ 
    \item \Z $\B{wrt }
      G\ v 
    $
  
      \item \Z\Z $
        \Omega, \Gamma \satisfies G \hastype \obj{$l$->$\tau$}
      $ by substitution

      \item \Z\Z $
        \obj{$G$.$l$} \rightsquigarrow v
      $ by definition 

      \item \Z\Z $
        \B{let } \Sigma \B{ s.t. } \Omega, \Gamma \satisfies \Sigma 
      $ by theorem \ref{...} 
      \item \Z\Z $
        \obj{$G$.$l$}[\Sigma] \rightsquigarrow v
      $ by definition 
      \item \Z\Z $
        v = v[\Sigma \sqcup \epsilon] 
      $ by definition 
      \item \Z\Z $
        \obj{$G$.$l$}[\Sigma] \rightsquigarrow v[\Sigma \sqcup \epsilon] 
      $ by substitution 
      \item \Z\Z $
        \Omega, \epsilon \satisfies \epsilon 
      $ by definition 

      \item \Z\Z $
        \Omega, \Gamma \sqcup \epsilon \satisfies v \hastype \tau
      $ by definition 
      \item \Z\Z $
        \Omega, \Gamma \satisfies \obj{$G$.$l$} \hastype \tau 
      $ by definition 
      \item \Z\Z $
        \Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
      $ by substitution


    \item \Z $\B{case }
      \Omega, \Sigma \satisfies \Gamma
      \I
      e[\Sigma] \rightsquigarrow e'[\Sigma \sqcup \Sigma']
      \I
      \Omega, \Sigma' \satisfies \Gamma'
      \I
      \Omega, \Gamma \sqcup \Gamma' \satisfies e' \hastype \obj{$l$->$\tau$}
    $
    \item \Z $\B{hypo }
      \Omega, \Gamma \sqcup \Gamma' \satisfies e' \hastype \obj{$l$->$\tau$}
      \implies
      \Omega, \Gamma \sqcup \Gamma' \satisfies \obj{$e'$.$l$} \hastype \tau
    $
    \item \Z $\B{wrt }
      \Sigma\ e'\ \Sigma'\ \Gamma'
    $
      \item \Z\Z $
        \Omega, \Gamma \sqcup \Gamma' \satisfies \obj{$e'$.$l$} \hastype \tau
      $ by application
      \item \Z\Z $
        \obj{$e[\Sigma]$.$l$} \rightsquigarrow \obj{$e'[\Sigma \sqcup \Sigma']$.$l$}
      $ by definition 
      \item \Z\Z $
        \obj{$e[\Sigma]$.$l$} = \obj{$e$.$l$}[\Sigma]
      $ by definition 
      \item \Z\Z $
        \obj{$e'[\Sigma \sqcup \Sigma']$.$l$} = \obj{$e'$.$l$}[\Sigma \sqcup \Sigma']
      $ by definition 
      \item \Z\Z $
        \obj{$e$.$l$}[\Sigma] \rightsquigarrow \obj{$e'$.$l$}[\Sigma \sqcup \Sigma']
      $ by substitution 
      \item \Z\Z $
        \Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
      $ by definition 

    \item \Z $
      \Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
    $ by induction 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof subtyping consistency)
  \label{theorem:proof_subtyping_consistency}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \Omega .\ 
      \Omega \satisfies \Delta
    } 
  \end{mathpar}
\end{theorem}

\begin{theorem}(Proof subtyping soundness)
  \label{theorem:proof_subtyping_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \Omega .\ 
      \Omega \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}
\end{theorem}


\begin{theorem}(Proof subtyping weak soundness)
  \label{theorem:proof_subtyping_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \forall \Omega .\ 
      \Omega \satisfies \Delta
      \implies
      \Omega \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}

\TODO{skolems simply remove variables from soundness consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (EXI[X . 1 <: X, X <: 3] X) <: 2  -| 1 <: X, X <: 3, ..., X <: 2  
% FAILS, not considered for soundness
% (EXI[X . 1 <: X, X <: 2] X) <: 2  -| 1 <: X, X <: 2, ..., X <: 2  
% PASSES, is considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2 <: (EXI[X . 1 <: X, X <: 3] X)  -| 2 <: X, ..., 1 <: X, X <: 3 
% PASSES, is considered for soundness
% 2 <: (EXI[X . X <: 1 ] X)  -| 2 <: X, ..., X <: 1
% FAILS, not considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Proof: 
  \item \TODO{think about how to handle the mutually recursive definition} 
  \item $\B{assume } 
    \tau_l \subtypes \tau_r \given M, \Delta 
  $
    \item \Z $\B{induct on } \tau_l \subtypes \tau_r \given M, \Delta$

    \item \Z $\B{case } \tau_l = \tau \I \tau_r = \tau$
    \item \Z $\B{wrt } \tau $
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \tau \subtypes \tau$
        by theorem \ref{theorem:model_typing_reflexivity}
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_l = \obj{BOT}$
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \obj{BOT} \subtypes \tau_r$ by definition
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_r = \obj{TOP}$
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \obj{TOP}$ by definition
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } 
      \tau_r = \obj{$l$->($\tau_{rl}$\&$\tau_{rr}$)}
      \I
      \tau_l
      \subtypes
      \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
      \given M, \Delta
    $
    \item \Z $\B{hypo }
      \forall \Omega .\ 
      \Omega \satisfies \Delta
      \implies
      \Omega \satisfies \tau_l \subtypes \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
    $ 
    \item \Z $\B{wrt } l\ \tau_{rl}\ \tau_{rr}$ 
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
        by application
        \item \Z\Z\Z $\B{for } e\ \Gamma \B{ assume } \Omega, \Gamma \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies e \hastype \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
          by theorem \ref{theorem:model_typing_subsumption} 
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies e \hastype \obj{$l$->$\tau_{rl}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies e \hastype \obj{$l$->$\tau_{rr}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau_{rl}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau_{rr}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies \obj{$e$.$l$} \hastype \obj{$\tau_{rl}$\&$\tau_{rr}$}$ by definition
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies e \hastype \obj{$l$->($\tau_{rl}$\&$\tau_{rr}$)}$ by theorem \ref{theorem:model_typing_record_introduction} 
          \item \Z\Z\Z\Z $\Omega, \Gamma \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e\ \Gamma .\ \Omega, \Gamma \satisfies e \hastype \tau_l \implies 
          \Omega, \Gamma \satisfies e \hastype \tau_r
        $ by implication and generalization
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$
        by definition 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 


    \item \Z $\B{case } 
      \tau_l = \obj{$\tau_{ll}$|$\tau_{lr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      \tau_{ll} \subtypes \tau_r
      \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_{lr} \subtypes \tau_r
      \given M_1, \Delta_1
    $

    \item \Z $\B{hypo } 
      \forall \Omega .\ \Omega \satisfies \Delta_0 \implies \Omega \satisfies \tau_{ll} \subtypes \tau_r
      \I
      \forall \Omega .\ \Omega \satisfies \Delta_1 \implies \Omega \satisfies \tau_{lr} \subtypes \tau_r
    $
    \item \Z $\B{wrt } \tau_{ll}\ \tau_{lr}$

      \item \Z\Z $\B{for } \Omega \B{ assume } M, \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\Omega \satisfies \tau_{lr} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\Omega \satisfies \Delta_0$ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\Omega \satisfies \tau_{ll} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\Omega \satisfies \obj{$\tau_{ll}$|$\tau_{lr}$} \subtypes \tau_r$ 
        by definition
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ 
        by substitution 

      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \obj{$\tau_{rl}$\&$\tau_{rr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin 
      \tau_l \subtypes \tau_{rl} \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_{rr} \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \Omega .\ \Omega \satisfies \Delta_0 \implies \Omega \satisfies \tau_l \subtypes \tau_{rl} 
      \I
      \forall \Omega .\ \Omega \satisfies \Delta_1 \implies \Omega \satisfies \tau_l \subtypes \tau_{rr} 
    $
    \item \Z $\B{wrt } $
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_{rr}$ by instantiation and application 
        \item \Z\Z\Z $\Omega \satisfies \Delta_0 $ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_{rl}$ by instantiation and application 
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \obj{$\tau_{rl}$\&$\tau_{rr}$}$ by definition 
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ by substitution
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization


    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \obj{($\tau_{ra}$->$\tau_{rc}$)\&($\tau_{rb}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes 
    %   \obj{$\tau_{ra}$|$\tau_{rb}$->$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \obj{($\tau_{ra}$->$\tau_{rb}$)\&($\tau_{ra}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \obj{$\tau_{ra}$->$\tau_{rb}$\&$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } 
      \tau_l = \obj{EXI[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A\ \#\ \tau_r
      \I
      M_0 \sqcup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_b \subtypes \tau_r
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \Omega .\ \Omega \satisfies \Delta_1 \implies \Omega \satisfies M_1, \tau_b \subtypes \tau_r 
    $
    \item \Z $\B{mutu } 
      \forall \Omega .\ \Omega \satisfies \Delta_0 \implies \Omega \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\Omega \satisfies \tau_b \subtypes \tau_r$ by application
        \item \Z\Z\Z $\Omega \satisfies \Delta_0 $ by theorem \ref{theorem:model_subtyping_sequence_prefix}
        \item \Z\Z\Z $\Omega \satisfies Q$ by application
        \item \Z\Z\Z $\B{for } e \B{ assume } \Omega \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\Omega \satisfies e \hastype \obj{EXI[$\Alpha$ $Q$]$\tau_b$}$ by substitution
          \item \Z\Z\Z\Z $\Omega \satisfies e \hastype \tau_r$ by theorem \ref{theorem:model_typing_existential_elimination} 
        \item \Z\Z\Z $\forall e .\ \Omega \satisfies e \hastype \tau_l 
          \implies \Omega \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \obj{ALL[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A\ \#\ \tau_l
      \I
      M_0 \sqcup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_b
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \Omega .\ \Omega \satisfies \Delta_1 \implies \Omega \satisfies \tau_l \subtypes \tau_b 
    $
    \item \Z $\B{mutu } 
      \forall \Omega .\ \Omega \satisfies \Delta_0 \implies \Omega \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_b$ by application 
        \item \Z\Z\Z $\Omega \satisfies \Delta_0$ by theorem \ref{theorem:model_subtyping_sequence_prefix} 
        \item \Z\Z\Z $\Omega \satisfies Q$ by application 
        \item \Z\Z\Z $\B{for } e \B{ assume } \Omega \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\Omega \satisfies e \hastype \obj{ALL[$\Alpha$ $Q$]$\tau_b$}$ by theorem \ref{theorem:model_typing_universal_introduction} 
          \item \Z\Z\Z\Z $\Omega \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e .\ \Omega \satisfies e \hastype \tau_l 
          \implies \Omega \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\Omega \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization
      \item \Z\Z \TODO{...} 

% e :  ALL[a b . 3 <: a ] (a,b) \implies e : (a,b)
    \item \Z $\B{case } 
      \tau_l = \alpha
      \I
      M = M_1
      \I
      \Delta = \Delta_1\ \alpha <: \tau_r
    $
    \item \Z $\contin
      \alpha \notin M_0
      \I
      M_0, \Delta_0 \entails \Delta_m <:^\star \alpha \slash \tau_r
      \I
      M_0, \Delta_0 \entails \Tau <:^\dagger \alpha
      \I
      M_0 \preceq M_1
    $
    \item \Z $\contin
      \Delta_0 \sqcup \Delta_m \preceq \Delta_1
      \I
      \obj{|$(\Tau)$} <: \tau_r \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } \forall \Omega .\ \Omega \satisfies \Delta_1 \implies
      \Omega \satisfies \obj{|$(\Tau)$} <: \tau_r
    $
    \item \Z $\B{wrt } \alpha\ M_1\ \Delta_1\ M_0\ \Delta_0\ \Delta_m\ \Tau$
      \item \Z\Z $\B{for } \Omega \B{ assume } \Omega \satisfies \Delta$
        \item \Z\Z\Z $\Omega \satisfies \Delta_1 \obj{($\alpha$<:$\tau_r$)}$ by substitution
        \item \Z\Z\Z $\Omega \satisfies \alpha <: \tau_r$ by theorem \ref{theorem:model_subtyping_sequence_last} 
        \item \Z\Z\Z $\Omega \satisfies \tau_l <: \tau_r$ by substitution 
      \item \Z\Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \notin M_0
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot M
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot \Delta_{skol}
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Tau 
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Delta_{rel}
    %   \\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \widebar{\obj{.$\tau_0[\alpha\slash\tau_l]$<:$\tau_1$}}^{\tau_0<:\tau_1 \in \Delta_{rel}} \sqcup \widebar{\obj{.$\tau_l$<:$\tau$}}^{\tau \in \Tau}
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    %   \sqcup \widebar{\tau_l<:z}^{z \in M}
    %   \sqcup \widebar{\tau[\alpha\slash\tau_l]<:z}^{\tau<:z \in \Delta_{skol}} \ \tau_l<:\alpha 
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \alpha <: \tau \in (\Delta_0 \sqcup \text{factor}(\Delta_0, \alpha))
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau \subtypes \tau_r
    %   \given M_1, \Delta_1
    % } {
    %   \alpha \subtypes \tau_r
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \tau <: \alpha \in \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau_l \subtypes \tau
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q
    %   \given M_1, \Delta_1
    % } {
    %   \obj{ALL[$\Alpha$ $Q$]$\tau_l$}
    %   \subtypes 
    %   \tau_r
    %   \given M_1, \Delta_1 
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r
    %   \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q \given M_1, \Delta_1
    % } {
    %   \tau_l
    %   \subtypes 
    %   \obj{EXI[$\Alpha$ $Q$]$\tau_r$}
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{ll} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \obj{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{lr} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \obj{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rl}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \obj{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rr}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \obj{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\forall \Omega .\ \Omega \satisfies \Delta \implies \Omega \satisfies \tau_l \subtypes \tau_r$ 
    by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem} Model typing existential elimination 
  \label{theorem:model_typing_existential_elimination}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies e \hastype \obj{EXI[$\Alpha$ $Q$]$\tau_l$}
      \\
      \Omega \satisfies Q
      \\
      \Omega \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha\ \#\ \tau_r
    } {
      \Omega \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: 
% depends on proof subtyping 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ... |= 2 : (EXI[X . 1 <: X, X <: 3] X)
% X/1 |= 1 <: X, X <: 3
% -------------------------
% X/1 |= 2 : 1 (FAIL) 
% -------------------------
% X/1 |= 2 : 4  (PASS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% X <: 4  -| X, 1 <: X, X <: 3

\end{theorem}

\begin{theorem} Model typing universal introduction 
  \label{theorem:model_typing_universal_introduction}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies e \hastype \tau_l
      \\
      \Omega \satisfies Q
      \\
      \Omega \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha\ \#\ \tau_l
    } {
      \Omega \satisfies e \hastype \obj{ALL[$\Alpha$ $Q$]$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}
\end{theorem}





\begin{theorem} Model subtyping sequence last 
  \label{theorem:model_subtyping_sequence_last}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \Delta\ \obj{($\tau_l$<:$\tau_r$)}
    } {
      \Omega \satisfies \tau_l \subtypes \tau_r 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence reduction 
  \label{theorem:model_subtyping_sequence_reduction}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \Delta\ \delta
    } {
      \Omega \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence prefix  
  \label{theorem:model_subtyping_sequence_prefix}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \Delta'
      \\
      \Delta \preceq \Delta'
    } {
      \Omega \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence uncat 
  \label{theorem:model_subtyping_sequence_uncat}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \Delta \sqcup \Delta'
    } {
      \Omega \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} concatenation prefix 
  \label{theorem:concatenation prefix}
  \begin{mathpar}
    \inferrule { 
    } {
      \Delta \preceq \Delta \sqcup \Delta'
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model subtyping unsub left 
  \label{theorem:Modle_subtyping_unsub_left}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_l \in \Omega
    } {
      \Omega \satisfies \alpha \subtypes \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping unsub right 
  \label{theorem:Modle_subtyping_unsub_right}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_r \in \Omega
    } {
      \Omega \satisfies \tau_l \subtypes \alpha
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping something 
  \label{theorem:Modle_subtyping_something}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \Delta 
      \\
      M, \Delta \entails \Tau \subtypes^\star \alpha  
    } {
      \alpha\slash\obj{|$(\Tau)$} \in \Omega
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem} Model typing record introduction 
  \label{theorem:model_typing_record_introduction}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \obj{$e$.$l$} \hastype \tau
    } {
      \Omega \satisfies e \hastype \obj{$l$->$\tau$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing implication introduction 
  \label{theorem:model_typing_implication_introduction}
  \TODO{this is really messed up}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies \obj{$e_0$($e_1$)} \hastype \tau_r
      \\
      \Omega \satisfies e_1 \hastype \tau_l
      \\
      \forall \tau .\ \Omega \satisfies e_1 \hastype \tau \implies \tau_l \subtypes \tau
    } {
      \Omega \satisfies e_0 \hastype \obj{$\tau_l$->$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing intersection elimination 
  \label{theorem:model_typing_intersection_elimination}
  \begin{mathpar}
    \inferrule { 
      \Omega \satisfies e \hastype \tau_l \& \tau_r
    } {
      \Omega \satisfies e \hastype \tau_l 
      \land
      \Omega \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model typing reflexivity
  \label{theorem:model_typing_reflexivity}
  \begin{mathpar}
    \inferrule { 
    } {
      \Omega \satisfies \tau \subtypes \tau
    } 
  \end{mathpar}
  Proof:
  \item $\B{for } e\ \Gamma \B{ assume } \Omega, \Gamma \satisfies e \hastype \tau$
    \item \Z $\Omega, \Gamma \satisfies e \hastype \tau$ by identity
  \item $\forall e\ \Gamma .\ \Omega, \Gamma \satisfies e \hastype \tau \implies \Omega, \Gamma \satisfies e \hastype \tau$
  by implication and generalization
  \item $\square$ by definition
\end{theorem}


\begin{theorem}(Model typing subsumption)
  \label{theorem:model_typing_subsumption}
  \begin{mathpar}
    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \tau_l 
      \\
      \Omega, \Gamma \satisfies \tau_l <: \tau_r
    } {
      \Omega, \Gamma \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } \Omega, \Gamma \satisfies e \hastype \tau_l 
  \I \Omega, \Gamma \satisfies \tau_l <: \tau_r
  $
    \item \Z $\B{invert on}\ \Omega, \Gamma \satisfies \tau_l <: \tau_r$
    \item \Z $\B{case}\ \forall e' .\ \Omega, \Gamma \satisfies e' : \tau_l \implies \Omega, \Gamma \satisfies e' : \tau_r$
      \item \Z\Z $\forall e' .\ \Omega, \Gamma \satisfies e' : \tau_l \implies \Omega, \Gamma \satisfies e' : \tau_r$ by identity
    \item \Z $\forall e' .\ \Omega, \Gamma \satisfies e' : \tau_l \implies \Omega, \Gamma \satisfies e' : \tau_r$ by inversion
    \item \Z $\Omega, \Gamma \satisfies e : \tau_l \implies \Omega, \Gamma \satisfies e : \tau_r$ by instantiation 
    \item \Z $\Omega, \Gamma \satisfies e : \tau_r$ by application
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}(Model typing implication elimination)
  \label{theorem:model_typing_implication_elimination}
  \begin{mathpar}
    \inferrule { 
      \Omega, \Gamma \satisfies e_0 \hastype \tau_l \obj{->} \tau_r
      \\
      \Omega, \Gamma \satisfies e_1 \hastype \tau_l
    } {
      \Omega, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume }
    \Omega, \Gamma \satisfies e_0 \hastype \tau_l \obj{->} \tau_r
    \I 
    \Omega, \Gamma \satisfies e_1 \hastype \tau_l
  $ 

    \item \Z $\B{let } \Sigma \B{ s.t. } \Omega, \Sigma \satisfies \Gamma$ by theorem \ref{...}
    \item \Z $\B{induct on } \Omega, \Gamma \satisfies e_0 \hastype \tau_l \obj{->} \tau_r$

    \item \Z $\B{case }$ \TODO{...}

    % \inferrule { 
    %   \Omega, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_p
    %   \\
    %   \Omega, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    %   \\\\
    %   \forall e .\ 
    %     \Omega, \Gamma \satisfies e \hastype \tau_l 
    %     \implies
    %     \Omega, \Gamma \satisfies e \hastype \tau_p 
    %     \land
    %     (\forall \tau_n\ \tau .\ \Omega, \Gamma \satisfies F \hastype \obj{$\tau_n$->$\tau$} \implies \neg (\Omega, \Gamma \satisfies e \hastype \tau_n))
    % } {
    %   \Omega, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \inferrule { 
    %   \Omega, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    % } {
    %   \Omega, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % } 
    \item \Z $\B{case }
      e_0 = \obj{$F$\$$p$=>$e_2$}
      \I
      \Omega, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    $ 
    \item \Z $\B{hypo }
      \Omega, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
    $
    \item \Z $\B{wrt }
      F\ p\ e_2 
    $
      \item \Z\Z $\VDash \obj{$F$($e_1$)}[\Sigma] $
      by theorem \ref{theorem:model_typing_soundness}
      \item \Z\Z $\B{invert on } \VDash \obj{$F$($e_1$)}[\Sigma]$
      \item \Z\Z $\B{case } \obj{$F$($e_1$)}[\Sigma] = v$
      \item \Z\Z $\B{wrt } v$
        \item \Z\Z\Z $\obj{$F$($e_1$)}[\Sigma] \neq v$ by definition 
        \item \Z\Z\Z $\bot$ by application
      \item \Z\Z $\B{case } 
        (\obj{$F$($e_1$)})[\Sigma] \rightsquigarrow e_3
        \I
        \Omega, \Gamma \satisfies e_3 \hastype \tau_r
      $
      \item \Z\Z $\B{wrt } e_3$
        \item \Z\Z\Z $(\obj{$F$($e_1$)})[\Sigma] = \obj{$F[\Sigma]$($e_1[\Sigma]$)}$ by definition
        \item \Z\Z\Z $\obj{$F[\Sigma]$($e_1[\Sigma]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\B{let } F' \B{ s.t. } F[\Sigma] = F'$ by theorem \ref{...} \TODO{...}
        \item \Z\Z\Z $\B{let } e_1' \B{ s.t. } e_1[\Sigma] = e_1'$ by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\text{FV}(e_2[\Sigma\backslash\text{FV}(p)]) \subseteq \text{FV}(p)$ 
        by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\obj{$F'$($e_1'$)} \rightsquigarrow e_3$ by substitution 
        \item \Z\Z\Z $\obj{($F'$\$$p$=>$e_2[\Sigma\backslash\text{FV}(p)]$)($e_1'$)} \rightsquigarrow e_3$ by definition 
        \item \Z\Z\Z $(\obj{$F[\Sigma]$\$$p$=>$e_2[\Sigma\backslash\text{FV}(p)]$)($e_1[\Sigma]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $(\obj{($F$\$$p$=>$e_2$)($e_1$)})[\Sigma] = \obj{($F[\Sigma]$\$$p$=>$e[\Sigma\backslash\text{FV}(p)]$)($e_1[\Sigma]$)}
        $ by definition
        \item \Z\Z\Z $(\obj{($F$\$$p$=>$e_2$)($e_1$)})[\Sigma] \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% OLD 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \item \Z $\B{case }
    %   \Omega, \Gamma \sqcup \Gamma' \satisfies p \hastype \tau_l
    %   \I
    %   \Omega, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    % $
    % \item \Z $ 
    %   \contin
    %   F = \epsilon \lor \Omega, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r
    %   \I
    %   e_0 = \obj{($F$\$$p$=>$e$)} 
    % $
    % \item \Z $
    %   \B{hypo} \  \Omega, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r \implies \Omega, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
    % $
    % \item \Z $
    %   \B{wrt} \ F \ p \ e \ \Gamma' \  
    % $
    %   \item \Z\Z $F = \epsilon \lor \Omega, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r$ by application
    %   \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)} \hastype \tau_l \obj{->} \tau_r$ by substitution 
    %   \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_reduced_implication_elimination}
    %   \item \Z\Z $\Omega, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r$ by substitution 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \item \Z $\B{case }
      \Omega, \Sigma \satisfies \Gamma
      \I
      e_0[\Sigma] \rightsquigarrow e_0'
      \I
      \Omega, \Gamma \satisfies e_0' \hastype \tau_l \obj{->} \tau_r
    $
    \item \Z $\B{hypo}\ 
      \Omega, \Gamma \satisfies e_0' \hastype \tau_l \obj{->} \tau_r
      \implies
      \Omega, \Gamma \satisfies \obj{$e_0'$($e_1$)} \hastype \tau_r
    $
    \item \Z $ 
    \B{wrt}\ \Sigma\ e_0' 
    $
      \item \Z\Z $\Omega, \Gamma \satisfies e_0'\obj{(}e_1\obj{)} \hastype \tau_r$ by application 
      \item \Z\Z $e_0[\Sigma]\obj{(}e_1\obj{)} \rightsquigarrow e_0'\obj{(}e_1\obj{)}$
      \item \Z\Z ($e_0\obj{(}e_1\obj{)})[\Sigma] \rightsquigarrow e_0'\obj{(}e_1\obj{)}$
      \item \Z\Z $\Omega, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r$ 

    \item \Z $\Omega, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r$ by induction
  \item $\square$
\end{theorem}

\begin{theorem}\ Model typing reduced implication elimination  

  \label{theorem:model_typing_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)} \hastype \tau_l \obj{->} \tau_r
      \\
      \Omega, \Gamma \satisfies e_1 \hastype \tau_l
      \\
      F = \epsilon \lor \Omega, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
    } {
      \Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume } \VDash e_1[\Sigma]$


    \item \Z $\B{let } \Sigma \B{ s.t. } \Omega, \Sigma \satisfies \Gamma $ by theorem \ref{theorem:model_typing_assignability} 
    \item \Z $\VDash e_1[\Sigma]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $\B{induct on } \VDash e_1[\Sigma]$

    \item \Z $\B{case } e_1[\Sigma] = v_1 $
    \item \Z $\B{wrt } v_1$  
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_fully_reduced_implication_elimination}

    \item \Z $\B{case}\ e_1[\Sigma] \rightsquigarrow e_1' \I \VDash e_1'$
    \item \Z $\B{hypo}\ \VDash e_1' \implies \Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1'$)} \hastype \tau_r$
    \item \Z $\B{wrt}\ e_1' $

      \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1'$)} \hastype \tau_r$ by application
      \item \Z\Z $\obj{($F$\$$p$=>$e$)$[\Sigma]$($e_1[\Sigma]$)} \rightsquigarrow \obj{($F$\$$p$=>$e$)$[\Sigma]$($e_1'$)}$ by definition 
      \item \Z\Z $\forall x .\ x \notin \B{FV}(e_1')$ by theorem \ref{theorem:reduction_closed} 
      \item \Z\Z $e_1' = e_1'[\Sigma]$ by by theorem \ref{theorem:closed_substitution} 
      \item \Z\Z $\obj{($F$\$$p$=>$e$)$[\Sigma]$($e_1[\Sigma]$)} \rightsquigarrow \obj{($F$\$$p$=>$e$)$[\Sigma]$($e_1'[\Sigma]$)}$ by substitution 
      \item \Z\Z $(\obj{($F$\$$p$=>$e$)($e_1$)})[\Sigma] \rightsquigarrow (\obj{($F$\$$p$=>$e$)($e_1'$)})[\Sigma]$ by definition 
      \item \Z\Z $\Sigma \sqcup \epsilon = \Sigma$ by definition 
      \item \Z\Z $(\obj{($F$\$$p$=>$e$)($e_1$)})[\Sigma] \rightsquigarrow (\obj{($F$\$$p$=>$e$)($e_1'$)})[\Sigma \sqcup \epsilon]$ by substitution 
      \item \Z\Z $\Gamma \sqcup \epsilon = \Gamma$ by definition
      \item \Z\Z $\Omega, \epsilon \satisfies \epsilon$ by definition
      \item \Z\Z $\Omega, \Gamma \sqcup \epsilon \satisfies \obj{($F$\$$p$=>$e$)($e_1'$)}$ by substitution 
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r$ by definition
    \item \Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r$ by induction
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}\ Model typing fully reduced implication elimination 
  \label{theorem:model_typing_fully_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)} \hastype \tau_l \obj{->} \tau_r
      \\
      F = \epsilon \lor \Omega, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
      \\
      \Omega \satisfies e_1 \hastype \tau_l
      \\
      \Omega, \Sigma \satisfies \Gamma 
      \\
      e_1[\Sigma] = v_1
      \\
    } {
      \Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume}\ F = \epsilon \lor \Omega, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r$
    \TODO{add more assumptions}
    \item \Z $\Omega \satisfies e_1[\Sigma] \hastype \tau_l$ by theorem \ref{theorem:model_typing_valuation} 
    \item \Z $\Omega \satisfies v_1 \hastype \tau_l$ by substitution 
    \item \Z $\B{invert on}\ F = \epsilon \lor \Omega, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r$
    \item \Z $\B{case } F = \epsilon$ 
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{$F$\$$p$=>$e$} \hastype \tau_l \obj{->} \tau_r$ by theorem \ref{theorem:model_typing_unwrapping} 
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{\$$p$=>$e$} \hastype \tau_l \obj{->} \tau_r$ by substitution 

      \item \Z\Z $\B{let}\ \Sigma' \B{ s.t. } p \equiv v_1 \given \Sigma'$ 
      by theorem \ref{theorem:model_typing_pattern_matching} 

      \item \Z\Z $\B{for } e'$ 
        \item \Z\Z\Z $\neg \epsilon[\Sigma]\obj{($v_1$)} \rightsquigarrow e'$ by definition
        \item \Z\Z\Z $\neg F[\Sigma]\obj{($v_1$)} \rightsquigarrow e'$ by substitution 
      \item \Z\Z $\forall e' .\ \neg F[\Sigma]\obj{($v_1$)} \rightsquigarrow e'$ by generalization 

      \item \Z\Z $\obj{($F[\Sigma]$\$$p$=>$e[\Sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\Sigma\backslash\B{FV}(p)][\Sigma]$ by definition 

      \item \Z\Z $\forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\Sigma')$ 
      by theorem \ref{theorem:pattern_matching_consistency}
      \item \Z\Z $\Sigma\backslash\B{FV}(p) = \Sigma\backslash\B{dom}(\Sigma')$ 
      by theorem \ref{theorem:consistency_diffing}
      \item \Z\Z $e[\Sigma\backslash\B{dom}(\Sigma')][\Sigma'] = e[\Sigma \sqcup \Sigma']$ 
      by theorem \ref{theorem:concatenation_substitution}

      \item \Z\Z $\obj{($F[\Sigma]$\$$p$=>$e[\Sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\Sigma\backslash\B{dom}(\Sigma')][\Sigma]$ 
        by substitution
      \item \Z\Z $\obj{($F[\Sigma]$\$$p$=>$e[\Sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\Sigma \sqcup \Sigma']$ 
        by substitution 
      \item \Z\Z $\obj{($F$\$$p$=>$e$)$[\Sigma]$($v_1$)} \rightsquigarrow e[\Sigma \sqcup \Sigma']$ by definition 
      \item \Z\Z $\obj{($F$\$$p$=>$e$)$[\Sigma]$($e_1[\Sigma]$)} \rightsquigarrow e[\Sigma \sqcup \Sigma']$ by substitution  

      \item \Z\Z $\obj{($F$\$$p$=>$e$)$[\Sigma]$($e_1[\Sigma]$)} = (\obj{($F$\$$p$=>$e$)($e_1$)})[\Sigma]$ by definition  
      \item \Z\Z $(\obj{($F$\$$p$=>$e$)($e_1$)})[\Sigma] \rightsquigarrow e[\Sigma \sqcup \Sigma']$ by substitution  

      \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition

    \item \Z $\B{case } \Omega, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r$ 
      \item \Z\Z $\B{let } e' \B{ s.t. } (\obj{$F$($e_1$}))[\Sigma] \rightsquigarrow e' \land \Omega, \Gamma \satisfies e' \hastype \tau_r$ by theorem \ref{theorem:model_typing_function_progress}
      \item \Z\Z $(\obj{($F$\$$p$=>$e$)($e_1$)})[\Sigma] \rightsquigarrow e'$ by definition 
      \item \Z\Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
    \item \Z $\Omega, \Gamma \satisfies \obj{($F$\$$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
  \item $\square$ by implication
\end{theorem}


\begin{theorem}\ (Pattern matching consistency)
  \label{theorem:pattern_matching_consistency}
  \begin{mathpar}
    \inferrule {
      p \equiv v \given \Sigma
    } {
      \forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\Sigma)
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}\ (Consistency diffing)
  \label{theorem:consistency_diffing}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \in X_l \iff x \in X_r 
    } {
      \Sigma\backslash X_l = \Sigma\backslash X_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Concatenation Substitution )
  \label{theorem:concatenation_substitution}
  \begin{mathpar}
    \inferrule {
    } {
      e[\Sigma\backslash\B{dom}(\Sigma')][\Sigma'] = e[\Sigma \sqcup \Sigma']
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}(Model typing valuation)
  \label{theorem:model_typing_valuation}
  \begin{mathpar}
    \inferrule {
      \Omega, \Gamma \satisfies e \hastype \tau 
      \\
      \Omega, \Sigma \satisfies \Gamma
    } {
      \Omega \satisfies e[\Sigma] \hastype \tau 
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \Omega, \Gamma \satisfies e \hastype \tau 
    \I
    \Omega, \Sigma \satisfies \Gamma
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing pattern matching)
  \label{theorem:model_typing_pattern_matching}
  \begin{mathpar}
    \inferrule {
      \Omega, \Gamma \satisfies \obj{\$$p$=>$e$} \hastype \tau_l \obj{->} \tau_r
      \\
      \Omega \satisfies v \hastype \tau_l 
    } {
      \exists \Sigma .\  p \equiv v \given \Sigma
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \Omega, \Gamma \satisfies \obj{\$$p$=>$e$} \hastype \tau_l \obj{->} \tau_r
    \I
    \Omega \satisfies v \hastype \tau_l 
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Well-formed function valuation)
  \label{theorem:wellformed_function_valuation}
  \begin{mathpar}
    \inferrule {
      \VDash F
    } {
      \exists v .\ v = F 
    } 
  \end{mathpar}
\end{theorem}
\begin{proof}
  \item $\B{assume } \VDash F$ 
    \item \Z $\B{invert on } \VDash F$
    \item \Z $\B{case } v = F$
      \item \Z\Z $v = F$ by identity
    \item \Z $\B{case } F \rightsquigarrow e$
    \item \Z $\B{wrt } e$
      \item \Z\Z $\neg F \rightsquigarrow e$ by definition
      \item \Z\Z $\bot$ by application 
    \item \Z $v = F$ by inversion 
  \item $\square$
\end{proof}


\begin{theorem}(Reduction closed)
  \label{theorem:reduction_closed}
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \forall x .\ x \notin \B{FV}(e')
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    e \rightsquigarrow e'
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Closed substitution)
  \label{theorem:closed_substitution}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \notin \B{FV}(e)
    } {
      e = e[\Sigma]
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \forall x .\ x \notin \B{FV}(e)
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}



% \begin{theorem}(Progress of pattern matching)
%   \label{theorem:pattern_matching_progress}
%   \begin{mathpar}
%     \inferrule {
%       \obj{*$p$=>$e$} \in F 
%       \\
%       p \equiv v \given \Sigma 
%       \\
%       \forall e' .\ \obj{*$p$=>$e'$} \in F \implies e' = e 
%     } {
%       \exists e' .\ F\obj{(}v\obj{)} \rightsquigarrow e'
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{for } p\ e\ F\ v\ \Sigma\ \B{assume }
%       \obj{*$p$=>$e$} \in F 
%       \I
%       p \equiv v \given \Sigma 
%       \I
%       \forall e' .\ \obj{*$p$=>$e'$} \in F \implies e' = e 
%   $

%   \item \Z $\B{case }
%     F = F'\ \obj{*$p$=>$e$} 
%     \I
%     \obj{*$p$=>$e$} \notin F'
%   $

%   \item \Z\Z $\B{for } e'$
%   \item \Z\Z\Z $\B{case}\ F'\obj{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\obj{(}F'\ \obj{*}p\obj{=>}e\obj{)(} v \obj{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z\Z\Z $F\obj{(}v\obj{)} \rightsquigarrow e'$ by substitution 
%   \item \Z\Z\Z $\B{case}\ \neg F'\obj{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\obj{(}F'\ \obj{*}p\obj{=>}e\obj{)(} v \obj{)} \rightsquigarrow e[\Sigma]$ by definition
%   \item \Z\Z\Z\Z $F\obj{(}v\obj{)} \rightsquigarrow e[\Sigma]$ by substitution 
%   \item \Z\Z\Z $\exists e'' .\ F\obj{(}v\obj{)} \rightsquigarrow e''$ by decidability of $F'\obj{($v$)} \rightsquigarrow e'$
%   \item \Z\Z $\forall e' .\ \exists e'' .\ F\obj{(}v\obj{)} \rightsquigarrow e''$ by summarization
%   \item \Z\Z $\exists e'' .\ F\obj{(}v\obj{)} \rightsquigarrow e''$ by independence 

%   \item \Z $\B{case }
%     F = F'\ f 
%     \I
%     \obj{*$p$=>$e$} \in F' 
%   $
%   \item \Z\Z $\B{let } e' \B{ s.t. } F'\obj{(}v\obj{)} \rightsquigarrow e'$ by induction hypothesis
%   \item \Z\Z $F'\ f\obj{(}v\obj{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z $F\obj{(}v\obj{)} \rightsquigarrow e'$ by definition
%   \item \Z $\exists e' .\ F\obj{(}v\obj{)} \rightsquigarrow e'$ by induction on $\obj{*$p$=>$e$} \in F$
%   \item $\square$
% \end{theorem}

\begin{theorem}(Model typing assignability)
  \label{theorem:model_typing_assignability}
  \begin{mathpar}
    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \tau
    } {
      \exists \Sigma .\ \Omega, \Sigma \satisfies \Gamma 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem}(Model typing soundness)
  \label{theorem:model_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \tau
    } {
      \forall \Sigma .\ 
      \Omega, \Sigma \satisfies \Gamma
      \implies
      \VDash e[\Sigma]
    } 
  \end{mathpar}
  Proof:
  \item \TODO{redo using universal/implication}
  \item $\B{assume }
        \Omega, \Sigma \satisfies \Gamma 
        \I \Omega, \Gamma \satisfies e \hastype \tau
  $
    \item \Z $\B{case } e = \obj{@}$
      \item \Z\Z $\B{let } v \B{ s.t. } \obj{@} = v$
      \item \Z\Z $e[\Sigma] = v$
      \item \Z\Z $ \VDash e[\Sigma]$


    \item \Z $\B{case } 
      \Omega, \Gamma \satisfies e' \hastype \tau'
      \I 
      e = \obj{<}l\obj{>}e' 
      \I 
      \tau = \obj{<}l\obj{>}\tau'
    $
      \item \Z\Z $\Vdash e'$ by induction hypothesis
      \item \Z\Z $\B{case } e'[\Sigma] = v$
        \item \Z\Z\Z $\B{let } v' \B{ s.t. } \obj{<}l\obj{>}v = v'$
        \item \Z\Z\Z $\obj{<}l\obj{>}e'[\Sigma] = v'$
        \item \Z\Z\Z $(\obj{<}l\obj{>}e')[\Sigma] = v'$
        \item \Z\Z\Z $e[\Sigma] = v'$
        \item \Z\Z\Z $\VDash e[\Sigma] $

      \item \Z\Z $\B{case } e'[\Sigma] \rightsquigarrow e'' \I \VDash e''$
        \item \Z\Z\Z $\obj{<}l\obj{>}e'[\Sigma] \rightsquigarrow \obj{<}l\obj{>} e''$
        \item \Z\Z\Z $\VDash \obj{<}l\obj{>}e'' $
        \item \Z\Z\Z $\VDash \obj{<}l\obj{>}e'[\Sigma] $
        \item \Z\Z\Z $\VDash (\obj{<}l\obj{>}e')[\Sigma] $
        \item \Z\Z\Z $\VDash e[\Sigma] $

      \item \Z\Z $\VDash e[\Sigma] $ by cases on $\VDash e' $

    \item \Z \TODO{remaining introduction cases}

    \item \Z $\B{case } 
      x \hastype \tau \in \Gamma
      \I 
      x \slash v \in \Sigma
      \I 
      e = x
    $
      \item \Z\Z $x[\Sigma] = v$
      \item \Z\Z $e[\Sigma] = v$
      \item \Z\Z $\VDash e[\Sigma] $

    \item \Z $\B{case } 
      e[\Sigma] \rightsquigarrow e' 
      \I 
      \Omega, \Gamma \satisfies e' \hastype \tau
    $ 
      \item \Z\Z $\VDash e'[\Sigma] $ by induction hypothesis
      \item \Z\Z $\VDash e[\Sigma] $

    \item \Z $\VDash e[\Sigma] $ by induction on $\Omega, \Gamma \satisfies e \hastype \tau$
  \item $\square$
  \item \TODO{Cretin's corresponding theorem is by definition of pretypes on p. 125}
\end{theorem}

\noindent
\B{NOTE: } The induction hypothesis includes the generalized assumption, e.g. $\forall e' .\ e' < e \implies Q(e')$ if inducting on $e$ or $\forall e' .\ (P(e') \implies P(e)), P(e') \implies Q(e')$ if inducting on predicate $P$

\noindent
\B{NOTE: } we induct on $\Omega, \Gamma \satisfies e \hastype \tau$ instead of $e$, as the predicate acts as a guard/ordering in lieu of a decreasing e.
This allows us to use the induction hypothesis on the reduction step result in the elimination case.

\noindent
\B{NOTE: } Kozen says, "Intuitively, one can appeal to the coinductive hypothesis as long as there
has been progress in observing the elements of the stream (guardedness) and there is no
further analysis of the tails (opacity)".  Kozen demonstrates a legal proof by induction on infinite streams too

% \begin{theorem}(Progress of proof typing)
%   \label{theorem:proof_typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       e \B{ progressive}
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}

% \begin{theorem}(Preservation of proof typing)
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%       \\
%       e \rightsquigarrow e'
%     } {
%       \Gamma \entails e' \hastype \tau \given Z  
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}


\begin{definition}\boxed{\Omega, \Gamma \satisfies e \hastype \tau}\ Model typing
  \label{definition:model_typing}
  \begin{mathpar}
    \inferrule { 
      \alpha \slash \tau \in \Omega
      \\
      \Omega, \Gamma \satisfies e \hastype \tau
    } {
      \Omega, \Gamma \satisfies e \hastype \alpha 
    } 

    \inferrule { 
      \alpha \slash \tau \notin \Omega
      \\
      \Omega, \Gamma \satisfies e \hastype \obj{TOP} 
    } {
      \Omega, \Gamma \satisfies e \hastype \alpha 
    } 

    \inferrule { 
    } {
      \Omega, \Gamma \satisfies \obj{@} \hastype \obj{@}
    } 

    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \tau
    } {
      \Omega, \Gamma \satisfies \obj{<$l$>$e$} \hastype \obj{<$l$>$\tau$}
    } 

    \inferrule { 
      \obj{\$$l$=>$v$} \in G 
      \\
      \Omega, \Gamma \satisfies v \hastype \tau 
      \\\\
      \forall v' .\ \obj{\$$l$=>$v'$} \in G \implies v' = v
    } {
      \Omega, \Gamma \satisfies G \hastype \obj{$l$->$\tau$}
    } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ORIGINAL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \inferrule { 
    %   F = \epsilon \lor \Omega, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    %   \\
    %   \Omega, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_l
    %   \\
    %   \Omega, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    % } {
    %   \Omega, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ALTERNATIVE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \inferrule { 
      \Omega, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_p
      \\
      \Omega, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
      \\\\
      \forall e .\ 
        \Omega, \Gamma \satisfies e \hastype \tau_l 
        \implies
        \Omega, \Gamma \satisfies e \hastype \tau_p 
        \land
        (\forall \tau_n\ \tau .\ \Omega, \Gamma \satisfies F \hastype \obj{$\tau_n$->$\tau$} \implies \neg (\Omega, \Gamma \satisfies e \hastype \tau_n))
    } {
      \Omega, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \inferrule { 
      \Omega, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    } {
      \Omega, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DERIVABLE??
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \inferrule { 
    %   \Omega, \Gamma \satisfies F \hastype \obj{$\tau_n$->$\tau_r$}
    %   \\
    %   \Omega, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_p
    %   \\
    %   \Omega, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    %   \\\\
    %   \forall e .\ 
    %     \Omega, \Gamma \satisfies e \hastype \tau_l 
    %     \implies
    %     \Omega, \Gamma \satisfies e \hastype \tau_p 
    %     \lor
    %     \Omega, \Gamma \satisfies e \hastype \tau_n 
    % } {
    %   \Omega, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % } 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$}
    } {
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$|$\tau_r$}
    } 

    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_r$}
    } {
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$|$\tau_r$}
    } 

    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$}
      \\
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_r$}
    } {
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$\&$\tau_r$}
    } 

    \inferrule { 
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$}
      \\
      \neg\ (\Omega, \Gamma \satisfies e \hastype \obj{$\tau_r$})
    } {
      \Omega, \Gamma \satisfies e \hastype \obj{$\tau_l$\textbackslash$\tau_r$}
    } 

    \inferrule { 
      \Omega \sqcup \Omega' \satisfies Q
      \\
      \Omega \sqcup \Omega' \satisfies e \hastype \tau
    } {
      \Omega \satisfies e \hastype \obj{EXI[$\Alpha$ $Q$]$\tau$}
    } 

    \inferrule { 
      \forall \Omega' .\ \Omega \sqcup \Omega' \satisfies Q \implies 
      \Omega \sqcup \Omega', \Gamma \satisfies e \hastype \tau
    } {
      \Omega, \Gamma \satisfies e \hastype \obj{ALL[$\Alpha$ $Q$]$\tau$}
    } 

    \inferrule { 
      \Omega \ \alpha \slash \obj{LFP[$\alpha$]$\tau$} \satisfies e \hastype \tau
    } {
      \Omega, \Gamma \satisfies e \hastype \obj{LFP[$\alpha$]$\tau$}
    } 



    \inferrule { 
      x \hastype \tau \in \Gamma 
    } {
      \Omega, \Gamma \satisfies x \hastype \tau 
    } 

    \inferrule { 
      \Omega, \Sigma \satisfies \Gamma 
      \\
      e[\Sigma] \rightsquigarrow e'[\Sigma']
      \\
      \Omega, \Sigma' \satisfies \Gamma' 
      \\
      \Omega, \Gamma' \satisfies e' \hastype \tau 
    } {
      \Omega, \Gamma \satisfies e \hastype \tau 
    } 

  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Omega, \Sigma \satisfies \Gamma}
  \label{definition:model_typing_environment}
  \begin{mathpar}
    \inferrule { 
    } {
      \Omega, \Sigma \satisfies \epsilon  
    } 

    \inferrule { 
      \Omega, \Sigma \satisfies \Gamma 
      \\
      \Omega \satisfies v \hastype \tau 
    } {
      \Omega, \Sigma \ x \slash v \satisfies \Gamma \ x:\tau 
    } 
  \end{mathpar}
\end{definition}



\begin{definition}\boxed{\Omega \satisfies \tau <: \tau}
  \label{definition:model_subtyping}
  \begin{mathpar}
    \inferrule { 
      \forall e\ \Gamma .\ 
      \Omega, \Gamma \satisfies e \hastype \tau_l \implies 
      \Omega, \Gamma \satisfies e \hastype \tau_r 
    } {
      \Omega \satisfies \tau_l <: \tau_r
    } 
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\Omega \satisfies Q}
  \label{definition:model_sequence_subtyping}
  \begin{mathpar}
    \inferrule { 
    } {
      \Omega \satisfies \epsilon 
    } 

    \inferrule { 
      \Omega \satisfies Q
      \\
      \Omega \satisfies \tau_l <: \tau_r
    } {
      \Omega \satisfies Q\ \obj{.$\tau_l$<:$\tau_r$}
    } 
  \end{mathpar}
\end{definition}

\end{document}