\documentclass[acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage[dvipsnames]{xcolor}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={let, fix, in}
}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]
% \newtheorem{proof}{Proof}[section]


\title{Extrinsic Type Inference (DRAFT 2025-04-11)}
\author{Thomas Logan}

\begin{document}

\newcommand{\Par}[1]{\paragraph{\textbf{#1}}}
\newcommand*{\code}{\fontfamily{pcr}\selectfont}
\newcommand{\J}[1]{\texttt{\small \code #1}}
\newcommand{\lab}[1]{\small \text{\color{Gray}\ [#1]}}
\newcommand{\entails}{\vdash}
\newcommand{\satisfies}{\vDash}
\newcommand{\given}{\dashv}
\newcommand{\with}{\ \diamond\ }
\newcommand{\notfree}{\ \#\ }
\newcommand{\consis}{\ \star}
\newcommand{\safe}{\ \checkmark}
\newcommand{\relational}{\ \Re}


\newcommand{\unique}{\ \dagger}

\newcommand{\factorsinto}{\Vvdash}


\newcommand{\allsafe}{\ \Re\checkmark}

\newcommand{\qua}{.\ }



\newcommand{\ignore}{\varnothing}
\newcommand{\invar}{\mho}
\newcommand{\closed}{\bullet}
\newcommand{\local}{\blacktriangle}
\newcommand{\open}{\circ}


\newcommand{\up}{\ \land\ }
\newcommand{\down}{\ \lor\ }

% \newcommand{\tl}{\textasciitilde{}}

\newcommand{\multi}[1]{\widebar{\ #1\ }}
\newcommand{\hastype}{:}
\newcommand{\pattype}{\ \lozenge\ }
\newcommand{\liftfun}{:}
 
\newcommand{\subtypes}{<:}
\newcommand{\supertypes}{:>}
\newcommand{\I}{\hspace{4mm}}
\newcommand{\Z}{.\hspace{4mm}}
\newcommand{\Alpha}{\mathrm{A}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\F}[1]{\text{#1}}
\newcommand{\bigand}{\bigwedge\nolimits}
\newcommand{\bigor}{\bigvee\nolimits}
\newcommand{\C}[1]{\color{teal} \rhd\ \emph{#1}}
\newcommand{\com}[1]{\color{Gray}\I \emph{#1}}
\newcommand{\D}[1]{\small \textsc{#1}}
% \newcommand{\fig}[1]{Fig. {\color{red} \fig{#1}}}
\newcommand{\FIG}[1]{Fig. {\color{red} \ref{#1}}}
\newcommand{\TODO}[1]{\noindent \B{\color{red} TODO: #1}}

\newcommand{\is}{\ ::=\ }
\newcommand{\sep}{\ \ |\ \ }
\newcommand{\nonterm}[1]{#1\ }
\newcommand{\contin}{|\ \ \ \ \ \ \ }
\newcommand{\wrt}{\B{wrt }}
% \newcommand{\let}{\B{let }}
% \newcommand{\for}{\B{for }}


\newcommand{\pc}{\noindent \ \ $\diamond$ \ \ }

 
     


\newcommand{\tl}{\textasciitilde{}}
\newcommand{\typdiff}{\J{\textbackslash}}

\maketitle


\section{Introduction}
\label{sec:introduction}

Automatically catching errors in programs is a hard enough problem
that many languages require users to provide simple specifications to limit the space of correctness.
In languages such as as Java or ML, programmers must declare each data constructor along with the weakest space it belongs to. 
That is, the data constructors are intrinsically typed.
The clever design of ML allows annotations to be fairly sparse by 
having types specified at constructor declarations and relying on type inference elsewhere.
However, one of the drawbacks of intrinsically typed languages is that they prevent reusing of
constructors in contexts that are weaker than or incomparable to their declared spaces. 
For instance, if a programmer declares data constructors \emph{cons} and \emph{nil} to belong to type list,
and \emph{node} and \emph{empty} to belong to type tree, then it is impossible to construct a function
that accepts either a list or a tree, or returns either a list or a tree. The only option would be to define
a new datatype that contains isomorphs of all of the above the data constructors, which would 
likely add overhead to development, compilation, and execution.


For various reasons, which may include the reusability drawbacks just mentioned, 
intrinsically typed languages have lost favor,
and untyped languages, 
such as Javascript and Python, have increased in popularity. 
Untyped languages remove the burden on the programmer to prescribe the weakest space each data constructor belongs to, 
which in turn allows programmers to mix and match data constructors in
various contexts, with the potential for enhancing the reusability and clarity of code.
However, the automatic detection of errors is still important. Python and Javascript have 
evolved over the years to include extrinsic types, whereby the programmer annotates particular uses of
their data constructors with types, rather than the declarations of data constructors.
 
Because extrinsically typed languages do not require users to specify the weakest space each data constructor belongs to,
extrinsically typed languages lack the type inference capabilities of intrinsically typed languages, such as ML. 
A lack of type inference is a significant drawback, since it results in code cluttered with annotations in order
to achieve any safety assurance.

There have been some relaxations of intrinsic type systems, allowing for sightly more code reusability.
Refinement types (Pfenning) \cite{} allow reusing data constructors in stronger spaces than their intrinsic types, by
inferring refinement types for particular uses.
Unfortunately, refinements aren't sufficient to handle the full range of data constructor reusability allowed by untyped languages.

In order to achieve a language with a high degree of both code reusability and type inference, 
we introduce a novel type system with extrinsic type inference. 
To avoid hindering the reusability allowed in untyped programming, 
the type system must allow the type of a given data constructor in one context
to be stronger, weaker, or incomparable to the type of 
the same data constructor in a different context. 
Due to the fact that a data constructor can belong to infinitely many types of varying precision,
the system leverages subtyping to check, construct, and notate types.

As a byproduct of inferring extrinsic types using subtyping, the system also happens to infer the principal types for 
certain kinds of higher-order functions, which was first solved by SuperF \cite{}. 
However, SuperF's programming language and type system is purposefully 
restricted, and it isn't sufficient for the high-degree of code reusability allowed by untyped languages.

Our extrinsic type system relies on intersection, union, along with their indexed version, and inductive types, in order 
to construct strong types from the observed programs. 
To keep things simple, we restrict the reasoning of inductive types to scalars. In future work, 
we will extend the system to include inductive relational reasoning. By adding inductive relational
reasoning to the extrinsic type system, one effectively gets an extrinsic alternative to CHC solving \cite{} 
or liquid types \cite{}.


In section \ref{sec:overview}, we give examples of the expressions and types that the system reasons with
and demonstrate a few of the ways the system can reason. 
In section \ref{sec:structures}, we define the forms of expressions, types, and ancillaries. 
In section \ref{sec:dynamic_system}, we define the ground truth.
In section \ref{sec:static_system}, we describe the verification and type inference mechanisms.

When possible we will guide the design of definitions by soundness and/or completeness properties,
which, in effect, constrain the space of correct designs with upper and/or lower bounds, respectively. 
The derivations of these properties are hinted at by the inductive nature of the definitions 
along with other properties mentioned throughout.
Proofs of these properties are in the appendix \TODO{...}, section \ref{sect:appendix}.

\section{Overview}
\label{sec:overview}
We designed the type system around a simple applicative language with pattern matching,
since such a language is syntactically close to predicate logic. Likewise,
we designed the language of types to share many similarities with predicate logic. 
To get a feel for the languages and reasoning capabilities, it's best to start by
looking at a few examples.


\Par{Finite Isomorphism.}
A function can be constructed from multiple paths. 
Consider the function $\J{talky}$, which completes a simple English phrase.

\[
  \begin{array}[t]{@{} l}
    \J{let talky = (}
      \\
      \I \J{? <hello> @ => <world> @}
      \\
      \I \J{? <good> @ => <morning> @} 
      \\
      \I \J{? <thank> @ => <you> @} 
      \\
    \J{)}
  \end{array}
\]

\noindent
Since there is no recursion, the number of paths is finite.
For these simple finite functions, the type system constructs
an isomorphic type without any weakening in precision. 

\[
  \begin{array}[t]{@{} l}
    \J{TOP}
      \\
      \J{\& <hello> @ -> <world> @}
      \\
      \J{\& <good> @ -> <morning> @} 
      \\
      \J{\& <thank> @ -> <you> @} 
  \end{array}
\]

\noindent
Each path is represented using the path type,
and the paths are joined together using the intersection type.

\Par{Selection.}
Although the type of function $\J{talky}$ is no weaker than the actual function,
lifting into the type syntax avails it to approximate reasoning at application.
Consider an application of the function to a variable argument. 

\[
  \begin{array}[t]{@{} l}
    \J{let x : <hello> @ | <thank> @ = ... in}
    \\
    \J{...}
    \\
    \J{talky(x)} 
    \\
    \J{...}
  \end{array}
\]

\noindent
If the type system affirms the type annotation,
then it goes on to infer the type of the application. 
\[
  \J{<world> @ | <you> @}
\]

\noindent
In effect, the type system applies application to all possible arguments
and unions the results derived from only the paths of those arguments. 

\Par{Learning.}
The paths of a function are not always syntactically apparent. 
If a variable is applied to arguments, the variable should implicitly behave 
like a function, or else the program is erroneous. 
Consider the higher order function $\J{foo}$ which takes a function as input
and applies it to the number two and the boolean true.

\[
  \J{let foo = ? f => (f(<succ> <succ> <zero> @), f(<true> @))}
\]

\noindent
Type systems for System F have traditionally struggled to find the best
type for such programs. If restricted to unqualified parametric types, there are many choices,
without there being a clear best or principal type, 
which is because it's not possible to find the weakest type for the function parameter
$\J{f}$.
One possibility is that the type system requires that $\J{f}$ is a function that wraps its
input in an option. 

\[
  \J{f : ALL[X] X -> <some> X}
\]

\noindent
Another possibility is that the type system requires that $\J{f}$ is a function that wraps its
input in an list. 

\[
  \J{f : ALL[X] X -> (LFP[R] <nil> @ | <cons> X*R)}
\]

\noindent
Both are valid, but neither is weaker than the other. The problem is that unqualified parametric
types are insufficient for describing the weakest safe input type.
It was not until SuperF introduced a technique for solving subtyping constraints
that a principal type could be automatically constructed for functions like $\J{foo}$
Our extrinsic type system relies on similar principles of solving subtyping constraints,
and likewise, can construct the weakest safe type for $\J{f}$, and thus the principal type for $\J{foo}$.

\[
  \J{ALL[X Y] (<succ> <succ> <zero> @ -> X) \& (<true> @ -> Y) -> X*Y}
\]

\noindent
Although the subtyping constraints are not present in the type's notation,
the intersection of paths is chosen because it represents the weakest type
consistent with the subtyping constraints on a variable representing the parameter's type. 
Suppose the type system chooses the variable type $\J{F}$ for the input parameter $\J{f}$.
Eventually, due to the applications of the parameter $\J{f}$, the type
system will attempt to find a solution to two constraints on $\J{F}$
\[
  \begin{array}[t]{@{} l}
    \J{F} \subtypes \J{(<succ> <succ> <zero> @ -> X)}
    \\
    \J{F} \subtypes \J{(<true> @ -> Y)}
  \end{array}
\]


\Par{Factorization.}
A function can represent infinite paths by using recursion.
Consider the function $\J{repeat}$, which takes an item and a natural number
as inputs and returns a list of that item repeated the input number of times.

\[
  \begin{array}[t]{@{} l}
      \J{let repeat = ? x => loop(? self =>}
      \\
      \I \J{? <zero> @ => <nil> @}
      \\
      \I \J{? <succ> n => <cons>(x,self(n))}
      \\
      \J{)}
  \end{array}
\]

\noindent
One possibility for constructing the type of the recursive function would
be to follow the idea of finite isomorphism and construct a type 
that preserves all the paths. If our type system had a greatest fixed point
type constructor, then we could concisely represent such a type with minimal
rewriting.

\[
  \begin{array}[t]{@{} l}
      \J{ALL[T] T -> GFP[R]( TOP} 
      \\
      \I \J{\& <zero> @ -> <nil> @}
      \\
      \I \J{\& (ALL[N L](R <: N->L) <succ> N -> <cons> T*L)}
      \\
      \J{)} 
  \end{array}
\]

\noindent
Although the strength of precision of this type would be very beneficial,
reasoning with such a type would be complicated. To keep the type system as
simple as possible for the purpose of extrinsic type inference with a high-degree
of code reusability, we leave such relational reasoning of inductive and co-inductive types out of
the type system. 
In this work, the type system actually avoids constructing a relational type, and instead, it
constructs a type that is significantly weaker than the actual behavior of the function,
by factoring the paths into an inductive space of inputs and an inductive space of outputs. 

\[
  \begin{array}[t]{@{} l}
      \J{ALL[T] T ->} 
      \\
      \I \J{(LFP[R] <zero> @ | <succ> R)}
      \\
      \I \J{->}
      \\
      \I \J{(LFP[R] <nil> @ | <cons> T*R)}
  \end{array}
\]

\noindent
This eager weakening approximation enables the type system
to simply reason with inductive scalars and avoids the need for complicated
relational reasoning. In a follow up paper,
we will show how to remedy this limitation by augmenting the type system with
mechanisms for inductive relational reasoning.

\Par{Scalar Unrolling.} 
Since the inputs to functions may have inductive types, the type 
system must be able to check for errors at function application by unrolling
inductive types.
Consider applying the function $\J{repeat}$ to some item and the number two, 
which results in the type system checking that two is in fact an instance of the natural numbers.

\[
  \J{ <succ> <succ> <zero> @} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
\]

\noindent
The type system confirms that two is a valid input by unrolling the inductive type three times.
Unfortunately, because the type system eagerly factored the type of $\J{repeat}$, it
is unable to infer a stronger type for the application than the original list type. 
In the followup paper, inductive relational reasoning will remedy this limitation.


\Par{Scalar Induction.} 
Another scenario that may arise is one in which the input to a function has an inductive type.
Consider the application of the function $\J{repeat}$ to a variable whose type represents the even natural numbers.

\[
  \begin{array}[t]{@{} l}
    \J{let x : (LFP[R] <zero> @ | <succ> <succ> R) = ... in}
    \\
    \J{...}
    \\
    \J{repeat(...)(x)} 
    \\
    \J{...}
  \end{array}
\]

\noindent
The application results in the type system checking that natural numbers are weaker than even numbers. 

\[
  \begin{array}[t]{@{} l}
    \J{LFP[R] <zero> @ | <succ> <succ> R}
    \\
    \subtypes
    \\
    \J{LFP[R] <zero> @ | <succ> R}
  \end{array}
\]

\noindent
Since even numbers are represented inductively, the type system performs mathematical induction
proving under the assumption that the subtyping relation holds for the self reference of the even numbers. 

\[
  \begin{array}[t]{@{} l}
    \J{E} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
    \\
    \entails
    \\
    \J{(<zero> @ | <succ> <succ> E)} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
  \end{array}
\]

\noindent
In practice, the type system actually substitutes the supertype into
the self reference of the subtype, if the self reference occurs in a positive position of the subtype.

\[
  \begin{array}[t]{@{} l}
    \J{(<zero> @ | <succ> <succ> (LFP[R] <zero> @ | <succ> R))} 
    \\
    \subtypes 
    \\
    \J{(LFP[R] <zero> @ | <succ> R)}
  \end{array}
\]

\noindent
In effect, by using mathematical induction, the type system ensures that 
every type contained within the type of even natural numbers is also
contained within the type of natural numbers.
In followup work, we will extend this inductive reasoning to handle inductive relations. 

\Par{Multi-specialization} 
Functions on lists can be generic, in that they may be independent of the item values, as in $\J{repeat}$,
or they may factor out the details that depend on item values, as in $\J{sort}$. 
\[
  \begin{array}[t]{@{} l}
    \J{let sort : ALL[X] (X*X->} \text{bool} \J{) -> }\text{list}(\J{X}) \J{ -> } \text{list}(\J{X}) \J{ = }
    \\
    \J{? compare => ...}
  \end{array}
\]
\noindent
The notation $\text{bool}$ and $\text{list}(\J{X})$ are meta-language terms representing types.
The function $\J{sort}$ can be specialized by passing in different implementations of comparison functions.
In intrinsically typed languages, the programmer would need a different specialization for every predefined
datatype (in ML) or class hierarchy (in Java). 

\[
  \begin{array}[t]{@{} l}
    \J{let scalarSort = sort(scalarCompare) in}
    \\
    \J{let lexicoSort = sort(lexicoCompare) in} 
    \\
    \J{...} 
  \end{array}
\]

\noindent
Having many different specializations burdens the client of
the generic function to know many different names for roughly the same behavior and can obscure the meaning
of code at the call site. 
Untyped languages can bypass this rigidity found in extrinsically typed by specializing in multiple ways.

\[
  \begin{array}[t]{@{} l}
    ...
    \\
    \J{let standardCompare = (? a,b =>} 
    \\
    \I \J{if isNat(a) and isNat(b) then} 
    \\
    \I\I \J{scalarCompare(a,b)}
    \\
    \I \J{else assert isNatList(a) and isNatList(b) then} 
    \\
    \I\I \J{lexicoCompare(a,b)}
    \\
    \J{) in} 
    \\
    \J{let standardSort : (TOP}
    \\
    \I \J{\& (}\text{nat}\J{*}\text{nat}\J{->}\text{bool} \J{) -> }\text{list}(\text{nat}) \J{ -> } \text{list}(\text{nat})
    \\
    \I \J{\& (}\text{list}(\text{nat})\J{*}\text{list}(\text{nat})\J{->}\text{bool} \J{) -> }\text{list}(\text{list}(\text{nat})) \J{ -> } \text{list}(\text{list}(\text{nat}))
    \\
    \J{) = sort(standardCompare) in}
    \\
    \J{...} 
  \end{array}
\]

\noindent
Some intrinsically typed languages also have ways to perform multi-specialization, but they introduce additional
complexity, since data constructors can't be mixed in arbitrary ways. In Lean and Haskell, multi-specialization
is achieved via type classes \cite{}. 
The notion of type classes, among other things, translates the notion of pattern matching to the syntactic category of types.

\section{Structures}
\label{sec:structures}
To demonstrate the capabilities of the extrinsic type system, we rely on an applicative
programming language with pattern matching, but without effects.
The design attempts to keep the forms of expressions and types relatively 
similar to each other when their semantics are also similar. 
It should not be difficult to modify the techniques presented towards
languages based on conditional branching instead of pattern matching. However,
extensions to include effects would require 
significant modifications to the current system.

\begin{definition} Expressions
  \label{def:expressions}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{e} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      x \sep 
      \J{@} \sep
      r \sep
      f \sep 
      e\J{.}l \sep
      e\J{(}e\J{)} \sep
      \\
      \J{loop(}e\J{)} \sep
      \J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e \sep
      s
    \end{array}
    & \com{expression}
    \\
    \nonterm{r} & \is \epsilon \sep r\ \J{<}l\J{>}e 
    & \com{record}
    \\
    \nonterm{f} & \is \epsilon \sep f\ \J{?}p\J{=>}e
    & \com{function}
    \\
    \nonterm{s} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      e \J{,} e \sep
      e\ \J{|>}\ e \sep
      \J{if}\ e\ \J{then}\ e\ \J{else}\ e \sep
      \J{let}\ x\ \J{=}\ e\ \J{in}\ e
    \end{array}
    & \com{sugar}
  \end{array}\]
\end{definition}

\noindent
A program is an expression $e$, which may be composed of variables $x$, unit $\J{@}$,
records $... \J{<}l\J{>} e ...$, functions $...\J{?}p \J{=>} e ...$, record
projection $e\J{.}l$, function application, $e\J{(}e\J{)}$, recursion $\J{loop(}e\J{)}$,
or bindings with type annotations, $\J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e$.
A record $r$ is constructed from zero or more entries $r$, where an entry
is a label associated with an expression $\J{<}l\J{>}e$.
A function $f$ is constructed from zero or more paths $f$, where a path is distinguished by a pattern
and leads to an expression $\J{?}p \J{=>} e$.
That is, construction of branches is inherent to functions and decoupled from pattern matching.
Therefore, pattern matching is subsumed by function application.

Projection $e\J{.}l$ allows getting the value from a particular entry in a record. 
Application $e\J{(}e\J{)}$ handles instantiation functions and pattern matching. 
Recursion $\J{loop(}e\J{)}$ is represented using a fixed point combinator $\J{loop}$.
A binding with type annotation $\J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e$ allows the programmer 
to verify expressions against a custom specification, instead of relying on merely 
the specification generated by type inference.
The annotation is used in two ways. First, the type system checks that specification is an approximation
of the expression bound to the variable. Second, the type system checks that the approximation,
although possibly weaker than the inferred type, is sufficient for the continuing expression to be error-free. 

\begin{definition} 
  \label{def:expression_desugaring}
  Expression Desugaring
  \hfill 
  \boxed{\llbracket s \rrbracket^\square = e}
  \\
  \begin{align*}
      \llbracket e_l \J{,} e_r \rrbracket^\square &= \J{<left>}\ e_l \ \J{<right>}\ e_r
      \\
      \llbracket e_l\ \J{|>}\ e_r \rrbracket^\square &= e_r\J{(}e_l\J{)}
      \\
      \llbracket \J{if}\ e_c\ \J{then}\ e_t\ \J{else}\ e_f \rrbracket^\square &= 
      \begin{array}[t]{@{} l}
        e_c \J{ |> (}
          \\
          \I \J{? <true> @ => } e_t
          \\
          \I \J{? <false> @ => } e_f
          \\
        \J{)}
      \end{array}
      \\
      \llbracket \J{assert}\ e_c\ \J{then}\ e_t \rrbracket^\square &= 
      \begin{array}[t]{@{} l}
        e_c \J{ |> (? <true> @ => } e_t \J{)}
      \end{array}
      \\
      \llbracket e_l\ \J{and}\ e_r \rrbracket^\square &= 
      \begin{array}[t]{@{} l}
        e_l \J{ |> (}
          \\
          \I \J{? <true> @ => } e_r
          \\
          \I \J{? <false> @ => <false> @}
          \\
        \J{)}
      \end{array}
      \\
      \llbracket \J{let}\ x\ \J{=}\ e\ \J{in}\ e' \rrbracket^\square &= (\J{?}x \J{=>} e')\J{(}e\J{)}
  \end{align*}

\end{definition} 

\noindent
For convenience and clarity, expressions include syntactic sugar for tuples $e\J{,}e$, 
unannotated bindings $\J{let}\ x\ \J{=}\ e\ \J{in}\ e$, data flow $e\ \J{|>}\ e$,
and conditional branching $\J{if}\ e\ \J{then}\ e\ \J{else}\ e$.
For any metalanguage statement or term containing sugar $s$, we assume that $s$ is implicitly replaced with $\llbracket s \rrbracket^\square$.

\begin{definition} Patterns 
  \label{def:patterns}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{p} & \is 
      x \sep
      \J{@} \sep
      k
    & \com{pattern}
    \\
    \nonterm{k} & \is \epsilon \sep k\ \J{<}l\J{>}p
    & \com{record}
  \end{array}\]
\end{definition}

\noindent
A pattern $p$ may be composed of variables $x$, unit $\J{@}$, or records $k$. 

\begin{definition} Values 
  \label{def:values}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{v} & \is 
      \J{@} \sep
      g \sep
      f
    & \com{value}
    \\
    \nonterm{g} & \is \epsilon \sep g\ \J{<}l\J{>}v
    & \com{record}
  \end{array}\]
\end{definition}

\noindent
A value $v$ may be composed of unit $\J{@}$, records $g$, or functions $f$. 

\begin{definition} Types 
  \label{def:types}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \kappa \sep 
      \phi \sep 
      \psi \sep 
      \J{LFP[}\alpha\J{]}\tau \sep
      \tau \typdiff \eta \sep
      \gamma
    \end{array}
    & \com{type}
    \\
    \nonterm{\kappa} & \is 
    \begin{array}[t]{@{}l}
      \J{<} l \J{>} \tau \sep 
      \tau\J{->}\tau
    \end{array}
    & \com{implication}
    \\
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{|}\tau \sep 
      \J{EXI[}\Theta\J{]} \Delta\ \tau
    \end{array}
    & \com{expansion}
    \\
    \nonterm{\psi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{\&}\tau \sep 
      \J{ALL[}\Theta\J{]} \Delta\ \tau
    \end{array}
    & \com{refinement}
    \\
    \nonterm{\eta} & \is 
    \begin{array}[t]{@{}l}
      \J{EXI[}\Theta \J{]} \rho \sep 
      \rho
    \end{array}
    & \com{subtracted}
    \\
    \nonterm{\rho} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \J{<}l\J{>}\rho \sep 
      \rho\J{\&}\rho \sep
      \rho\J{*}\rho
    \end{array}
    & \com{pattern}
    \\
    \nonterm{\gamma} & \is 
    \begin{array}[t]{@{}l}
      \J{TOP} \sep \J{BOT} \sep 
      \tau \J{*} \tau 
    \end{array}
    & \com{sugar}
  \end{array}\]
\end{definition}

\noindent
Types provide the representation for approximate specification.
To accommodate a high degree of data constructor reusability,
it is important that the forms of types accommodate a wide range of precision.
To manage the complexity of the various forms, we subdivide the type forms
according to some themes.
A type $\tau$ may be composed of unit $\J{@}$, variables $\alpha$, 
implication $\kappa$, expansions $\phi$, refinements $\psi$,
least fixed points $\J{LFP[}\alpha \J{]} \tau$,
differences $\tau \typdiff \eta$, and sugar $\gamma$.

An implication type $\kappa$ reflects the structure of 
its inhabitants and may take the form of  
entries $\J{<}l\J{>}\tau$ or paths $\tau \J{->} \tau$.

An expansion type $\phi$ is either a binary union $\tau \J{|} \tau$ or 
an indexed union $\J{EXI[}\Theta\ \Delta\J{]}\tau$.
An expansion type is weaker than its constituent types. 
An indexed union is parametrized by type variables $\Theta$ 
and qualified by subtyping constraints $\Delta$.
It represents the compounded union of all instantiations of its constituent type 
consistent with its subtyping constraints.
In effect, the qualification by subtyping constraints provides an upper bound, in which
the weaker the qualification, the weaker the indexed union.

A refinement type $\psi$ is either a binary intersection $\tau \J{\&} \tau$ or 
an indexed intersection $\J{ALL[} \Theta\ \Delta \J{]}\tau$.
A refinement type is strengthened relative to its constituent types. 
An indexed intersection is parametrized by type variables $\Theta$ 
and qualified by subtyping constraints $\Delta$.
It represents the compounded intersection of all instantiations of its constituent type 
consistent with its subtyping constraints.
In effect, the qualification by subtyping constraints provides a lower bound, in which
the weaker the qualification, the stronger the indexed intersection.

A least fixed point type $\J{LFP[}\alpha \J{]}$ 
enables the representation of an infinite space of data,
e.g. natural numbers or lists. 
A difference type represents subtracting one space from another.
Its subtracted type $\eta$ has a restricted form of either
a pattern type $\rho$ or an unqualified indexed union 
over a pattern $\J{EXI[}\Theta \J{]} \rho$, for which the type system
is complete, thus making its negation sound.  
This restricted form is of no hindrance to type inference, since the 
subtracted types arise only from patterns, whose forms are sufficiently
limited.
A pattern type $\rho$ reflects the forms of pattern expressions, consisting of 
variables $\alpha$, unit $@$, entries $\J{<} l \J{l} \rho$, intersections $\rho \J{\&} \rho$,
and pairs $\rho \J{*} \rho$ (whose form is just syntactic sugar).


\begin{definition} 
  \label{def:type_desugaring}
  Type Desugaring 
  \hfill 
  \boxed{\llbracket \gamma \rrbracket^\square = \tau}
  \\
  \begin{align*}
    \llbracket \J{TOP} \rrbracket^\square &= \J{EXI[} \alpha \J{]} \alpha
    \\
    \llbracket \J{BOT} \rrbracket^\square &= \J{ALL[} \alpha \J{]} \alpha
    \\
    \llbracket \tau_l \J{*} \tau_r \rrbracket^\square &= (\J{<left>}\ \tau_l)  \J{\&} (\J{<right>}\ \tau_r)
  \end{align*}
\end{definition} 

\noindent
For convenience and clarity, types include syntactic sugar for top $\J{TOP}$, 
bottom $\J{BOT}$, and pairs $\tau \J{*} \tau$.
For any metalanguage statement or term containing sugar $\gamma$, we assume that $\gamma$ is implicitly replaced with $\llbracket \gamma \rrbracket^\square$.


\begin{definition} Ancillaries 
  \label{def:type_ancillaries}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\Theta} & \is \epsilon \sep \Theta\ \alpha 
    & \com{type var seq}
    \\
    \nonterm{\Delta} & \is \epsilon \sep \Delta \  \tau \J{<:} \tau
    & \com{subtyping environ}
    \\
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ x \hastype \tau
    & \com{typing environ}
    \\
    \nonterm{\Pi} & \is \epsilon \sep \Pi\ (\Theta, \Delta, \tau) 
    & \com{colony seq}
    \\
    \nonterm{\Xi} & \is \epsilon \sep \Xi\ \eta 
    & \com{subtracted type seq}
  \end{array}\]
\end{definition}


There are a few ancillary structures, upon which both the representation of types and the reasoning with types depend.
A type variable sequence $\Theta$ is either empty $\epsilon$ or a smaller sequence extended by a single variable $\Theta\ \alpha$
A subtyping environment $\Delta$ is either empty $\epsilon$ or a smaller environment extended by a single
subtyping constraint $\Delta \  \tau \J{<:} \tau$.
A typing environment $\Gamma$ is either empty $\epsilon$ or a smaller environment extended by a single
typing constraint over a variable $\Gamma\ x \subtypes \tau$.
a World $\Omega$ is simply a pair of a type variables sequence and a subtyping environment $\Theta, \Delta$.
A world represents the context for judging a typing or a subtyping relation.


For clarity, we omit writing $\epsilon$ explicitly when describing semantics or instances of the forms.
That is, for any structure, if there is a malformed structure due to a missing piece, 
we assume it is replaced by a well-formed structure, 
where $\epsilon$ is inserted wherever necessary to make it well-formed.

\section{Dynamic System}
\label{sec:dynamic_system}

The programming language is pure and applicative. 


\begin{definition}
  \label{def:progression}
  Progression
  \hfill 
  \boxed{e \rightsquigarrow e}
  \\
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      r\J{<}l\J{>}e \rightsquigarrow r\J{<}l\J{>}e'
    }

    \inferrule {
      r \rightsquigarrow r'
    } {
      r \J{<}l \J{>} v \rightsquigarrow r' \J{<} l \J{>} v
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      e\J{.}l \rightsquigarrow e'\J{.}l
    }

    \inferrule {
      \J{?}l\J{=>}v \in g
      \\
      \forall\ e .\ \J{?}l\J{=>}e \in g \implies e = v
    } {
      g\J{.}l \rightsquigarrow v
    }

    \inferrule {
      e_f \rightsquigarrow e_f'
    } {
      e_f\J{(}e\J{)} \rightsquigarrow e_f'\J{(}e\J{)}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      f\J{(}e\J{)} \rightsquigarrow f\J{(}e'\J{)}
    }

    \inferrule {
      f\J{(}v\J{)} \rightsquigarrow e'
      \\
      \text{FV}(e) \subseteq \text{FV}(p)
    } {
      (f\J{?}p\J{=>}e)\J{(}v\J{)} \rightsquigarrow e' 
    }

    \inferrule {
      \exists e' .\ f\J{(}v\J{)} \rightsquigarrow e'
      \\
      p \equiv v \given \sigma 
    } {
      (f\J{?}p\J{=>}e)\J{(}v\J{)} \rightsquigarrow e[\sigma]
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \J{loop(}e\J{)} \rightsquigarrow \J{loop(}e'\J{)}
    }

    \inferrule {
    } {
      \J{loop(?}x\J{=>}e\J{)} \rightsquigarrow e[x \slash \J{loop(?}x\J{=>}e\J{)}]
    }
  \end{mathpar}
\end{definition}

Progression of an expression is a small-step operational semantics. 
It adheres to typical definitions of applicative languages for the most part. One 
slight departure is that pattern matching is merely a special case of function application. 
Likewise, a switch is merely a function abstraction.
Records are similar to functions, except that their entries are guarded by literal identifiers. 
Additionally, records may act as patterns, but functions may not.
The semantics enables recursion via the fixed point combinator \J{loop}.

\begin{definition}
  \label{def:stability}
  Stability 
  \hfill
  \boxed{\VDash e}
  \\
  \begin{mathpar}
    \inferrule {
      e = v
    } {
      \VDash e
    } 

    \inferrule { 
      e \rightsquigarrow e' 
      \\
      \VDash e'
    } {
      \VDash e
    } 
  \end{mathpar}
\end{definition}

\noindent
A expression is stable if and only if it is a value or it can take a step to a stable expression.
In other words, if an expression is not a value then its behavior is defined by progression.

\begin{property}
  \label{def:model_typing_soundness}
  Model Typing Soundness 
  \\
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies e \hastype \tau
    } {
      \VDash e 
    } 
  \end{mathpar}
\end{property}

\noindent
Model typing $\delta \satisfies e \hastype \tau$ attempts to imbue types
with meaning.  At the very least, types should inform us that an expression is stable.  

\begin{definition}
  \label{def:model_typing}
  Model Typing
  \hfill
  \boxed{\delta \satisfies e \hastype \tau}
  \\
  \begin{mathpar}
    \inferrule { 
    } {
      \delta \satisfies \J{@} \hastype \J{@}
    } 

    \inferrule { 
    } {
      \delta \satisfies \epsilon \hastype \J{TOP}
    } 

    \inferrule { 
      \J{<}l \J{>} v \in g
      \\
      \delta \satisfies v \hastype \tau 
      \\
      \forall v' .\ \J{<} l \J{>} v' \in g \implies v' = v
    } {
      \delta \satisfies g \hastype \J{<} l \J{>} \tau
    } 

    \inferrule { 
      \delta \satisfies f \hastype \tau_l \J{->} \tau_r
    } {
      \delta \satisfies f \J{?}p \J{=>} e \hastype \tau_l \J{->} \tau_r
    } 

    \inferrule { 
      \forall \sigma.\ 
      \delta \satisfies p[\sigma] \hastype \tau_l
      \implies
      \delta  \satisfies e[\sigma] \hastype \tau_r
      \\\\
      \forall \tau_l'\ \tau_r'.\ 
      \delta \satisfies f \hastype \tau_l' \J{->} \tau_r'
      \implies
      \delta \satisfies \tau_l \subtypes \tau_l'
      \implies
      \delta \satisfies \tau_r' \subtypes \tau_r
    } {
      \delta \satisfies f \J{?}p \J{=>} e \hastype \tau_l \J{->} \tau_r
    }

    \inferrule { 
      \delta \satisfies e \hastype \tau_l
      \\
      \neg\ (\delta \satisfies e \hastype \tau_r)
    } {
      \delta \satisfies e \hastype \tau_l \typdiff \tau_r
    } 

    \inferrule { 
      \delta \satisfies e \hastype \tau_l
      \\
      \delta \satisfies e \hastype \tau_r
    } {
      \delta \satisfies e \hastype \tau_l \J{\&} \tau_r
    } 

    \inferrule { 
      \delta \satisfies e \hastype \tau_l
    } {
      \delta \satisfies e \hastype \tau_l \J{|} \tau_r
    } 

    \inferrule { 
      \delta \satisfies e \hastype \tau_r
    } {
      \delta \satisfies e \hastype \tau_l \J{|} \tau_r
    } 

    \inferrule { 
      \delta \cup \delta' \satisfies \Delta 
      \\
      \delta \cup \delta' \satisfies e \hastype \tau
      \\
      \textbf{dom}(\delta') \cong \Theta
    } {
      \delta \satisfies e \hastype \J{EXI[}\Theta\J{]}\Delta\ \tau
    } 

    \inferrule { 
      \forall \delta' .\ 
      \textbf{dom}(\delta') \cong \Theta \implies
      \delta \cup \delta' \satisfies \Delta \implies 
      \delta \cup \delta' \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \J{ALL[}\Theta\J{]}\Delta\ \tau
    } 

    \inferrule { 
      \delta \ \alpha \slash \J{LFP[}\alpha \J{]} \tau \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \J{LFP[} \alpha \J{]} \tau
    } 

    \inferrule { 
      e \rightsquigarrow e'
      \\
      \delta \satisfies e' \hastype \tau 
    } {
      \delta \satisfies e \hastype \tau 
    } 

    \inferrule { 
      \alpha \slash \tau \in \delta
      \\
      \delta \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \alpha 
    } 
  \end{mathpar}
\end{definition}

\noindent
Model typing describes how the various forms of 
types are introduced based on the various forms of values. 
There are no rules for elimination 
of type forms. Rather, the progression of expressions is leveraged to eliminate
expression forms, from which further type forms may be introduced.
The indirection into progression is not practical, but it guides the design 
of a sound type system that can directly prove the validity of typings and subtypings 
by eliminating type forms.

\TODO{describe the various rules of model typing}

% \hfill
% \begin{definition}
%   \label{def:model_type_inhabitation}
%   Model Type Inhabitation 
%   \hfill
%   \boxed{\delta \satisfies \tau}
%   \\
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies e \hastype \tau 
%     } {
%       \delta \satisfies \tau 
%     } 
%   \end{mathpar}
% \end{definition}
% \hfill

% As a matter of convenience, a type is inhabited if and only if there is 
% an expression for which model typing holds. 


\begin{definition}
  \label{def:model_subtyping}
  Model Subtyping
  \hfill
  \boxed{\delta \satisfies \tau <: \tau}
  \\
  \begin{mathpar}
    \inferrule { 
      \forall e .\ 
      \delta \satisfies e \hastype \tau_l \implies 
      \delta \satisfies e \hastype \tau_r 
    } {
      \delta \satisfies \tau_l <: \tau_r
    } 
  \end{mathpar}
\end{definition}


\begin{definition}
  \label{def:model_sequence_subtyping}
  Model Sequence Subtyping
  \hfill
  \boxed{\delta \satisfies \Delta}
  \\
  \begin{mathpar}
    \inferrule { 
    } {
      \delta \satisfies \epsilon 
    } 

    \inferrule { 
      \delta \satisfies \Delta 
      \\
      \delta \satisfies \tau_l \subtypes \tau_r
    } {
      \delta \satisfies \Delta \  \tau_l \J{<:} \tau_r
    } 
  \end{mathpar}
\end{definition}



\section{Static System}
\label{sec:static_system}
The static system is a strengthening of the dynamic system, designed to
ensure that expressions can make progress and satisfy approximate specifications
represented by types. 
The entry point into the static system is proof typing, which
aims to prove the validity of typing directly by including elimination rules.  


\begin{property}
  \label{def:proof_typing_soundness}
  Proof Typing Soundness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \exists \delta .\ \textbf{dom}(\delta) \cong \Theta' \backslash \Theta \up 
      (
      \forall \delta' .\ 
      \delta' \cup \delta \satisfies \Delta' \implies
      \delta' \cup \delta, \sigma \satisfies \Gamma \implies
      \delta' \cup \delta \satisfies e[\sigma] \hastype \tau
      )
    }
  \end{mathpar}

\end{property}

\TODO{note that the input variables are for checking compositionality against outer expressions}

\TODO{therefore, they cannot contradict the typing of the current expression}

\noindent
The system for proving typing $\Gamma \entails e \hastype \tau \given \Theta, \Delta$ 
must be sound with respect to model typing assuming 
interpretations of typing and subtyping environments.
The typing environment $\Gamma$ and the subtyping environment $\Delta$
represent assumptions that enable the typing $e \hastype \tau$ to be proved. 
the type variables $\Theta$ are closed, meaning that proof typing
holds only if the typing holds under some interpretation of type variables in $\Theta$.
Type variables not in $\Theta$ are considered open, meaning that proof typing
holds only if the typing holds for every interpretation of variables not in $\Theta$,
assuming each interpretation satisfies the subtyping environment $\Delta$ and the typing environment $\Gamma$.  

The proof typing predicate $\Gamma \entails e \hastype \tau \given \Omega'$
implies an algorithmic interpretation, 
which takes a typing environment $\Gamma$, an expression $e$,
and a world $\Omega$ as inputs and returns a type and a world $\Omega'$ as outputs,
such that the output world is an extension of the input world $(\Omega \preceq \Omega')$.
The input world is not explicitly represented in the predicate, so the algorithm
interprets the input world as the smallest world that can satisfy the predicate. 
Additionally, the outputs of the predicate are not deterministic. Therefore, the algorithm
enumerates all possible outputs.

\begin{definition} 
  \label{def:proof_typing}
  Proof Typing
  \hfill 
  \boxed{\Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta, \Gamma \entails \J{@} \hastype \J{@} \given \Theta, \Delta
    }

    \inferrule {
      x:\tau \in \Gamma
    } {
      \Theta, \Delta, \Gamma \entails x \hastype \tau \given \Theta, \Delta 
    }

    \inferrule {
    } {
      \Theta, \Delta, \Gamma \entails \epsilon \hastype \J{TOP} \given \Theta, \Delta
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails r \hastype \tau \given \Theta', \Delta'  
      \\\\
      \Theta', \Delta', \Gamma \entails e \hastype \tau' \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta, \Gamma \entails r, \J{<}l \J{>} e \hastype (\tau, \J{\&}, \J{<} l \J{>} \tau') 
      \given \Theta'', \Delta'' 
    }

    \inferrule {
      \exists \Xi \qua \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
      \\\\
      \textbf{pack}^+(\textbf{ftv}(\Gamma), \Theta \entails \Pi) = \tau 
    } {
      \Theta, \Delta, \Gamma \entails f \hastype \tau \given \Theta, \Delta
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta' 
      \\\\
      \Theta', \Delta' \entails 
      \tau \subtypes  \J{<} l \J{>} \alpha 
      \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta, \Gamma \entails e\J{.}l \hastype \alpha \given \Theta'', \Delta''
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e_f \hastype \tau_f \given \Omega 
      \\
      \Theta', \Delta', \Gamma \entails e_a \hastype \tau_a \given \Theta'', \Delta''
      \\\\
      \Theta'', \Delta'', \tau_f \subtypes \tau_a\J{->}\alpha \given \Theta''', \Delta'''
    } {
      \Theta, \Delta, \Gamma \entails e_f\J{(}e_a \J{)} \hastype \alpha \given \Theta''', \Delta'''
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta' 
      \\
      \Theta', \Delta' \entails \tau \subtypes \tau_a \given \Theta'', \Delta''
      \\\\
      \Theta'', \Delta'', \Gamma, x:\tau_a \entails e' \hastype \tau' \given \Theta''', \Delta'''
    } {
      \Theta, \Delta, \Gamma \entails \J{let } x \J{:} \tau_a \J{ = } e \J{ in } e' \hastype \tau' \given \Theta''', \Delta'''
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \alpha_\nu\J{->}\tau \given  \Theta', \Delta'
      \\
      \Theta \cup \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) = \Theta_\invar
      \\\\
      \forall \Theta'', \Delta''  \qua 
        \Theta', \llbracket \Theta_\invar \cup \Theta' \entails \Delta'' \backslash \Delta', \alpha_l \J{->} \alpha_r \rrbracket^+ 
        \in \Pi_\nu
      \implies
      \Theta', \Delta' \entails \tau \subtypes \alpha_l\J{->}\alpha_r \given \Theta'', \Delta'' 
      \\\\
      \exists \Theta, \Delta, \tau \qua (\Theta, \Delta, \tau) \in \Pi_\nu
      \\
      \alpha_\nu \downarrow \Pi_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \Pi_\mu
      \\
      \textbf{pack}^-(\Theta_\invar, \alpha_\mu \entails \Pi_\mu) = \tau_\mu
      \\\\
      \exists \alpha  \qua \alpha \J{*} \J{BOT} \subtypes \J{LFP[} \alpha_\mu \J{]}\tau_\mu \factorsinto \alpha \subtypes \tau_l 
      \\
      \exists \alpha  \qua \J{BOT} \J{*} \alpha  \subtypes \J{LFP[} \alpha_\mu \J{]}\tau_\mu \factorsinto \alpha \subtypes \tau_r 
    } {
      \Theta, \Delta, \Gamma \entails \J{loop(}e\J{)} 
      \hastype 
      \tau_l \J{->} \tau_r
      \given \Theta, \Delta
    }
  \end{mathpar}
\end{definition}

\noindent
For the unit expression \J{@}, proof typing simply returns the unit type \J{@}. 
For a variable expression, $x$, proof typing looks for a corresponding typing in the environment, 
and it returns the type it found.
For an empty expression $\epsilon$, proof typing returns the top type \J{TOP},
thereby providing a basis for constructing types for record expressions. 
For a non-empty record expression $r\J{?}l\J{=>}e$, proof typing 
recursively constructs the type for each entry, and
refines their types against each other via compounded intersection.

For a function expression $f$, proof typing 
delegates the work to two helpers. 
The predicate for path sequence typing 
$\Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi$
constructs a sequence of path types, 
with each path type associated with a world, represented by $\Pi$.
Then, the metalanguage function for positive packaging 
$\textbf{pack}^+(\textbf{ftv}(\Gamma)\ \Theta \entails \Pi)$
takes the path colonies and for each path colony,
it rewrites the colony into a type by wrapping the path type in indexed unions
and indexed intersections qualified by the constraints in the colony's subtyping environment. 
The positive $+$ annotation on pack indicates that the resulting type 
is should approximate an expression used in a positive position,
which determines whether closed and open variables are mapped to
bindings in indexed unions or indexed intersections.

For projection $e\J{.}l$, proof typing
leverages proof subtyping $\tau \subtypes \J{<}l\J{>}\alpha \given \Omega$ 
to check that there is an entry with the label $l$ 
in the supposed record $e$ with type $\tau'$, 
and it learns a lower bound 
on the type of the body $\alpha$, which is associated with that label.
For application $e_f\J{(}e_a\J{)}$, proof typing
leverages proof subtyping $\tau_f \subtypes \tau_a \J{->} \alpha \given \Omega$
to check that that the function $e_f$ can actually
map the argument $e_a$ to a result. It learns a lower bound 
on the type of the result $\alpha$, which is associated with that argument.
For an annotated binding, $\J{let}\ x \J{:} \tau_a\ \J{=}\ e\ \J{in}\ e'$, 
proof typing checks the definition's source $e$ against the annotation $\tau_a$,
and adds the annotation to the typing environment when checking the continuation $e'$.

For a recursive expression, $\J{loop(}e{)}$, proof typing
eagerly factors the paths of the recursive function 
to construct a single path type with an inductive type as its input and an inductive type as its output. 
First, it ensures that argument of the fixed point combinator $e$ is indeed a 
single path function $\Gamma \entails e \hastype \alpha_\nu \J{->} \tau \given \Theta, \Delta$. 
Then, by leveraging subtyping $\tau \subtypes \alpha_l \J{->} \alpha_r \given ...$, 
it gathers all the path types that approximate the body of $e$ (via its type $\tau$)
into a sequence $\Pi$, which pairs each parametric path type with a world to qualify its meaning.
As it collects the path colonies, it leverages positive type interpretation 
$\llbracket ... \entails \Delta', \alpha_l \J{->} \alpha_r \rrbracket^+$ 
to instantiate the parametric path type with interpretations consistent with its corresponding world. 
This interpretation makes the path type more readable and the subtyping environment more compact.

Using the whole collection path colonies $\Pi$, 
proof typing delegates to duality correspondence $
      \alpha_\nu \downarrow \Pi_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \Pi_\mu
$, which rewrites the implicitly co-inductive pairs of path types and worlds into
implicitly inductive pairs of pair types and worlds. 
Rewriting the co-inductive paths into inductive pairs is the first
step towards factoring the infinite paths of the recursive function into a weaker single path.
By leveraging the negative packaging $\textbf{pack}^-(... \entails \Pi_\mu) = \tau_\mu$,
the qualification by the worlds becomes embedded in a single type $\tau_\mu$. 
Finally, it makes inductive nature of the relational type explicit,
by wrapping the type in a least fixed point $\J{LFP[} \alpha_\mu \J{]}$, 
and it leverages the factorization predicate $... \subtypes \J{LFP[} \alpha_\mu \J{]} \tau_\mu \Vvdash \alpha \subtypes ...$
to factor the inductive relational type into an inductive antecedent and an inductive consequent
of a single path type.

\begin{definition} 
  \label{def:path_sequence_typing}
  Path Sequence Typing 
  \hfill
  \boxed{\Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta, \Gamma \entails \epsilon \liftfun \epsilon \sim \epsilon 
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
      \\
      p \hastype \rho \given \Gamma'
      \\
      \text{diff}(\rho, \Xi) = \tau_l
      \\
      \Theta \cup \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) = \Theta_\invar
      \\\\
      \forall \Theta', \Delta', \tau_r  \qua 
      \Theta', \llbracket \Theta_\invar \cup \Theta' \entails \Delta' \backslash \Delta, \tau_l \J{->} \tau_r \rrbracket^+ \in \Pi'
      \implies
      \Theta, \Delta, \Gamma \cup \Gamma' \entails e \hastype \tau_r \given \Theta', \Delta' 
      \\\\
      \exists \Theta, \Delta, \tau  \qua (\Theta, \Delta, \tau) \in \Pi' 
      \\
      \text{capture}(\rho) = \eta
    } {
      \Theta, \Delta, \Gamma \entails f\ \J{?}p\J{=>}e \liftfun 
      \Pi \cup \Pi' \sim \Xi\ \eta
    }
  \end{mathpar}
\end{definition}

\noindent
Path sequence typing $\Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi$
handles the details of constructing types for each path of a function.
Progression of application tries each path of the applied function is in order.
That is, the application will progress along the first path whose pattern
matches the argument.
To account for this ordering and short-circuiting of pattern matching,
the types for each path of the function must subtract the types of patterns
from earlier paths $\Xi$ when constructing antecedents of path types.  
Each path of the function could branch out,
represented by the typing $\Gamma \cup \Gamma' \entails e \hastype \tau_r \given ...$, 
so each function path can produce multiple path types $\tau_l \J{->} \tau_r$, 
which are collected in $\pi'$.
The metalanguage function for positive type interpretation 
$\llbracket ... \entails \Delta', \tau_l \J{->} \tau_r \rrbracket^+$ 
keeps things tidy by compacting the subtyping environments and making the path
types more readable.

\begin{property} 
  \label{prop:duality_correspondence_soundness}
  Duality Correspondence Soudness
  \\
  \begin{mathpar}
    \inferrule {
      \alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu
    } {
      \forall \tau_\nu\ \Theta_\nu\ \Delta_\nu\ \tau_\nu'\ \delta_\nu.\ 
      \\\\
      (\Theta_\nu,\Delta_\nu, \tau_\nu') \in \Pi_\nu \implies
      \textbf{dom}(\delta_\nu) \cong \Theta_\nu \implies
      \delta\ \alpha_\nu \slash \tau_\nu \cup \delta_\nu \satisfies \Delta_\nu \implies
      \delta\ \alpha_\nu \slash \tau_\nu \cup \delta_\nu \satisfies e_f \hastype \tau_\nu'
      \\\\
      \iff
      \\\\
      \exists e_a\ \tau_\mu\ \Theta_\mu\ \Delta_\mu\ \tau_\mu'\ \delta_\mu.\ 
      \\\\
      (\Theta_\mu,\Delta_\mu, \tau_\mu') \in \Pi_\mu \land
      \textbf{dom}(\delta_\mu) \cong \Theta_\mu \land
      \delta\ \alpha_\mu \slash \tau_\mu \cup \delta_\mu \satisfies \Delta_\mu \land
      \delta\ \alpha_\mu \slash \tau_\mu \cup \delta_\mu \satisfies (e_a \J{,} e_f\J{(} e_a \J{)}) \hastype \tau_\mu'
    }
  \end{mathpar} 
\end{property} 

\noindent
Duality correspondence $\alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu$
rewrites colonies with path types $\Pi_\nu$ into colonies with pair types $\Pi_\nu$
such that for any interpretation $\delta$, a given function $e_f$ 
inhabits all interpretations of every path type colony
if and only if 
there's an argument $e_a$ paired with the function applied to it that inhabits 
at least one of the pair type colonies.

\begin{definition} 
  \label{def:duality_correspondence}
  Duality Correspondence 
  \hfill
  \boxed{\alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_{\nu} \downarrow \epsilon
      \fallingdotseq 
      \alpha_{\mu} \uparrow \epsilon 
    }

    \inferrule {
      \alpha_{\nu} \downarrow \Pi_\nu
      \fallingdotseq 
      \alpha_{\mu} \uparrow \Pi_\mu
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_{\nu} \downarrow \Pi_\nu\ (\Theta_c,\Delta_\nu, \tau_l \J{->} \tau_r)
      \fallingdotseq 
      \alpha_{\mu} \uparrow \Pi_\mu\ (\Theta_c,\Delta_\mu, \tau_l \J{*} \tau_r)
    }
  \end{mathpar}
\end{definition}

\noindent
The duality correspondence predicate unrolls the two sequences of colonies simultaneously.  
In the case where both sequence are empty
$
\alpha_{\nu} \downarrow \epsilon
\fallingdotseq 
\alpha_{\mu} \uparrow \epsilon 
$, duality correspondence simply holds.
Otherwise, duality correspondence requires that the left sequence's last colony 
has a path type  $(\Theta_c,\Delta_\nu, \tau_l \J{->} \tau_r)$
and the right sequence's last colony has a pair type 
$(\Theta_c,\Delta_\nu, \tau_l \J{*} \tau_r)$;
the subtyping environments correspond 
$\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu$;
and the earlier sequences of colonies correspond
$
\alpha_{\nu} \downarrow \Pi_\nu
\fallingdotseq 
\alpha_{\mu} \uparrow \Pi_\mu
$
.

\begin{property} 
  \label{prop:subtyping_duality_correspondence_soundness}
  Subtyping Duality Correspondence Soudness
  \\
  \begin{mathpar}
    \inferrule {
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \forall \tau_\nu\ \Delta_\nu\ .\ 
      \delta\ \alpha_\nu \slash \tau_\nu \satisfies \Delta_\nu \implies
      \delta\ \alpha_\nu \slash \tau_\nu 
      \satisfies e_f \hastype \tau_\nu
      \\\\
      \iff
      \\\\
      \exists e_a\ \tau_\mu\ \Delta_\mu.\ 
      \delta\ \alpha_\mu \slash \tau_\mu \satisfies \Delta_\mu \land
      \delta\ \alpha_\mu \slash \tau_\mu 
      \satisfies (e_a \J{,} e_f\J{(} e_a \J{)}) \hastype \tau_\mu
    }
  \end{mathpar} 
\end{property} 

\noindent
Subtyping duality correspondence $
  \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
$ rewrites a subtyping environment $\Delta_\nu$ containing path type upper bounds
on variable $\alpha_\nu$ 
into a subtyping environment $\Delta_\mu$ containing pair type lower bounds 
on variable $\alpha_\mu$,
such that 
for any interpretation $\delta$, a given function $e_f$
inhabits all types $\tau_\nu$ constrained by the environment's path type upper bounds
if and only if 
there's an argument $e_a$ paired with the function applied to it that inhabits 
at least one type $\tau_\mu$ constrained by the environment's pair type lower bounds.

\begin{definition}
  \label{def:subtyping_duality_correspondence}
  Subtyping Duality Correspondence 
  \hfill
  \boxed{\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon 
    }

    \inferrule {
      \alpha_\nu \notin \textbf{ftv}(\tau_l)
      \\
      \alpha_\nu \notin \textbf{ftv}(\tau_r)
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_\nu \downarrow \Delta_\nu \  \tau_l \J{<:} \tau_r 
      \fallingdotseq 
      \alpha_\mu \uparrow \Delta_\mu \  \tau_l \J{<:} \tau_r
    }

    \inferrule {
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_\nu \downarrow \Delta_\nu \  \alpha_\nu \J{<:} \alpha_l \J{->} \alpha_r
      \fallingdotseq 
      \alpha_\mu \uparrow \Delta_\mu \  \alpha_l \J{*} \alpha_r \J{<:} \alpha_\mu 
    }
  \end{mathpar}
\end{definition}

\noindent
The subtyping duality correspondence predicate unrolls the two subtyping environments simultaneously.
In the case where both environments are empty 
$
  \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon 
$, subtyping duality correspondence simply holds.
In the case where the subtyping constraints are the same,
the upper bounded variable $\alpha_\nu$ must not appear in the subtype $\tau_l$;
the lower bounded variable $\alpha_\mu$ must not appear in the supertype $\tau_r$;
and the correspondence must hold for the previous constraints in the environment
$\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu$
.
Lastly, subtyping duality correspondence holds if
the last subtyping constraint of each subtyping environment contains
the path type upper bounds $\alpha_\nu \J{<:} \alpha_l \J{->} \alpha_r$
and pair type lower bounds $\alpha_l \J{*} \alpha_r \J{<:} \alpha_\mu$ on the specified variables,
and the the correspondence holds for the previous constraints in the environment

\begin{property}
  \label{prop:type_interpretation_soundness}
  Type Interpretation Soundness 
  \\
  \begin{mathpar}
    \inferrule { 
      \llbracket \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
      \\
      \Theta \subseteq \textbf{dom}(\delta')
    } {
      \exists \delta .\ 
      (
      \delta \cup \delta' \satisfies \Delta
      \land
      \delta \cup \delta' \satisfies e \hastype \tau
      )
      \iff
      (
      \delta' \satisfies \Delta'
      \land
      \delta' \satisfies e \hastype \tau'
      )
    } 
  \end{mathpar}
\end{property}

\noindent
Type interpretation $\llbracket \Theta_\ignore, \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')$
constructs a type $\tau'$, such that $\tau'$ is behaves like the input type $\tau$ for some interpretation $\delta$. 
The positive form $\llbracket ... \rrbracket^+$ constructs the strongest type or tries to get close to the strongest type possible.  
The negative form $\llbracket ... \rrbracket^-$ constructs the weakest type or tries to get close to the weakest type possible. 
The type variables $\Theta_\ignore$ and $\Theta$ must be irrelevant, meaning
the constructed type $\tau'$ must behave like $\tau$ 
for all interpretations over those variables $\delta'$.
Additionally, any interpretation $\delta'$ for the resulting subtyping environment $\Delta$' must
be part of some interpretation for the original subtyping environment $\Delta$.

The details of finding the type interpretation involves numerous tedious details, so we leave the definition
in the appendix (Section \ref{sect:appendix}).

\begin{property}
  \label{prop:packaging_soundness}
  Packaging Soundness 
  \\
  \begin{mathpar}
    \inferrule { 
      \textbf{pack}^+(\Theta_\ignore \entails \Pi) = \tau'
      \\
      \textbf{dom}(\delta_\ignore) \cong \Theta_\ignore
    } {
      \exists \delta .\ 
      \forall \Theta\ \Delta\ \tau\ \delta' .\ 
      (\Theta, \Delta, \tau) \in \Pi
      \implies
      \textbf{dom}(\delta') = \Theta
      \implies
      \\\\
      \delta \cup \delta' \cup \delta_\ignore \satisfies \Delta
      \implies
      \delta \cup \delta' \cup \delta_\ignore \satisfies e \hastype \tau
      \implies
      \delta_\ignore \satisfies e \hastype \tau'
    } 

    \inferrule { 
      \textbf{pack}^-(\Theta_\ignore \entails \Pi) = \tau'
      \\
      \textbf{dom}(\delta_\ignore) \cong \Theta_\ignore
    } {
      \exists \delta .\ 
      \forall \Theta\ \Delta\ \tau\ \delta' .\ 
      (\Theta, \Delta, \tau) \in \Pi
      \implies
      \textbf{dom}(\delta') = \Theta
      \implies
      \\\\
      \delta \cup \delta' \cup \delta_\ignore \satisfies \Delta
      \implies
      \delta_\ignore \satisfies e \hastype \tau'
      \implies
      \delta \cup \delta' \cup \delta_\ignore \satisfies e \hastype \tau
    } 
  \end{mathpar}
\end{property}

\noindent
Packaging ($\textbf{pack}^\pm(\Theta_\ignore \entails \Pi) = \tau'$)
constructs a type $\tau'$ from the colonies $\Pi$
such that for each colony $(\Theta, \Delta, \tau)$,
it binds the variables of the type $\tau$ within
some combination of 
indexed unions and/or indexed intersections,
where indexes are qualified by the constraints 
of the subtyping environment $\Delta$.
The choice of binding in an indexed union or indexed intersection is 
determined by whether the variable is open ($\alpha \not\in \Theta$)
or closed ($\alpha \in \Theta$)
and whether the interpretation is 
positive ($\textbf{pack}^+(...)$) or negative ($\textbf{pack}^-(...)$).
For the positive form, the construction (including how the closed variables are bound)
must result in a type $\tau'$ that is weaker than the type of every colony in every interpretation
of the closed variables $\delta'$, for some interpretation of the open variables $\delta$  
.
For the negative form, the construction must result in a type $\tau'$
that is stronger than the type of every colony in every interpretation
of the closed variables $\delta'$, for some interpretation of the open variables $\delta$  
.

The interested reader can find the actual the definition of packaging in the appendix (Section \ref{sect:appendix}).

\begin{property} 
  \label{def:proof_subtyping_soundness}
  Proof Subtyping Soundness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
    } {
      \exists \delta .\ 
      \textbf{dom}(\delta) \cong \Theta' \backslash \Theta
      \up
      (
      \forall \delta' .\ 
      \delta' \cup \delta \satisfies \Delta' \implies
      \delta' \cup \delta \satisfies \tau_l \subtypes \tau_r
      )
    }
  \end{mathpar}
\end{property}

\noindent
The system for proving subtyping $\tau_l \subtypes \tau_r \given \Theta, \Delta$ 
must be sound with respect to model typing under
interpretation of the subtyping environment.
The subtyping environment $\Delta$
represent assumptions that enable the subtyping $\tau_l \subtypes \tau_r$ to be proved. 
The type variables $\Theta$ are closed, meaning that the proof subtyping
holds only if the model subtyping holds under some interpretation of type variables in $\Theta$.
Type variables not in $\Theta$ are considered open, meaning the proof subtyping
holds only if the model subtyping holds for every interpretation of variables not in $\Theta$,
assuming each interpretation satisfies the subtyping environment.

The proof subtyping predicate $\tau_l \subtypes \tau_r \given \Omega'$
implies an algorithmic interpretation, 
which takes a subtype $\tau_l$, a supertype $\tau_r$,
and a world $\Omega$ as inputs and returns a world $\Omega'$ as output,
such that the output world is an extension of the input world $(\Omega \preceq \Omega')$.
The input world is not explicitly represented in the predicate, so the algorithm
interprets the input world as the smallest world that can satisfy the predicate. 
Additionally, the outputs of the predicate are not deterministic. Therefore, the algorithm
enumerates all possible outputs.

The subtyping relation must consider the forms of both types in the subtyping relation.
There are elimination rules, which make decisions based on the form of the subtype,
and there are introduction rules, which make decisions based on the form of the supertype.
Some rules handle both elimination and introduction of type forms.
Due to the complexity of types and there being two input types,
proof subtyping relies on many rules. 
For clarity, we subdivide the proof subtyping rules 
according to some themes.
The order of the rules is critical to ensure that easier sub-problems are generated 
when possible. 
The best algorithmic interpretation we have found tries the rules in the order
presented in the paper.


\begin{definition} 
  \label{def:proof_subtyping_reflection}
  Proof Subtyping (Reflection)
  \hfill
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta \entails \tau \subtypes \tau \given \Theta, \Delta 
    }
  \end{mathpar}
\end{definition}

\noindent
Proof subtyping is reflexive. In other words, a type
is considered both weaker than and stronger than itself. 
We implicitly assume alpha conversion for variables
bound in indexed unions and indexed intersections.
An algorithmic interpretation could convert to a nameless representation,
such as de Bruijin indexes \cite{} before comparing type forms.

\begin{definition} 
  \label{def:proof_subtyping_implication_preservation}
  Proof Subtyping (Implication Preservation)
  \hfill
  \boxed{\Theta, \Delta \entails \kappa_l \subtypes \kappa_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \tau_l \subtypes \tau_r
      \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails 
      \J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r
      \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails \tau_{x} \subtypes \tau_{p} \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \tau_{q} \subtypes \tau_{y} \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails 
      \tau_{p} \J{->} \tau_{q} 
      \subtypes 
      \tau_{x} \J{->} \tau_{y}
      \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
Both entry types and path types may be viewed as analogs of propositional implication. 
However, unlike the typical separate rules for introduction and elimination in propositional implication,
The proof subtyping for each implication types combines the semantics for introduction
and elimination into a single preservation rule.
For entries and paths, proof subtyping preserves the form if the type's constituent parts meet certain criteria. 
For entries, $ \J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r \given \Omega$
proof subtyping simply checks that the entries' labels match and that 
subtyping holds for their contents.
For paths, $\tau_{p} \J{->} \tau_{q} \subtypes \tau_{x} \J{->} \tau_{y}$
proof subtyping simply checks that the antecedent of the subtype
is weaker than the antecedent of the supertype, and the consequent
of the subtype is stronger than the consequent of the supertype. 

\begin{definition} 
  \label{def:proof_subtyping_implication_rewriting}
  Proof Subtyping (Implication Rewriting)
  \hfill
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \tau_l \subtypes
      (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r)
      \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \tau_l \subtypes 
      (\tau_a\J{|}\tau_b)\J{->}\tau_r
      \given \Theta', \Delta' 
    }


    \inferrule {
      \Theta, \Delta \entails 
      \tau_l
      \subtypes
      (\tau_r\J{->}\tau_a)
      \J{\&}
      (\tau_r\J{->}\tau_b)
      \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails 
      \tau_l \subtypes 
      \tau_r\J{->}(\tau_{a}\J{\&}\tau_{b})
      \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails 
      \tau
      \subtypes
      (\J{<} l \J{>} \tau_a)
      \J{\&}
      (\J{<} l \J{>} \tau_b)
      \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails 
      \tau \subtypes 
      \J{<} l \J{>} (\tau_{a}\J{\&}\tau_{b})
      \given \Theta', \Delta'
    }

  \end{mathpar}
\end{definition}

\noindent
Just as entries and paths are analogous to propositional implication,
the analogy extends to union and intersection.
Union is analogous to propositional disjunction,
and intersection is analogous to propositional conjunction. 
However, since the proof subtyping rules simply preserve implication types,
rather than introducing and eliminating them,
The subtyping logic needs an union antecedent rule, corresponding
to disjunction elimination, and intersection consequent rules,
corresponding to conjunction introduction. 

For elimination of a path with a union antecedent 
$
  \tau_l \subtypes 
  (\tau_a\J{|}\tau_b)\J{->}\tau_r
$, proof subtyping breaks apart the union and checks
that the subtype holds against two paths 
whose antecedents are the union's constituent parts. 
For elimination of a path with an intersection consequent 
$
  \tau_l \subtypes 
  \tau_r \J{->}(\tau_a\J{\&}\tau_b)
$, proof subtyping breaks apart the intersection and checks
that the subtype holds against two paths 
whose consequents are the intersection's constituent parts. 
For elimination of an entry with an intersection consequent
$
  \tau \subtypes 
  \J{<}l\J{>} (\tau_a\J{\&}\tau_b)
$, proof subtyping breaks apart the intersection and checks
that the subtype holds against two entries 
whose consequents are the intersection's constituent parts. 

\begin{definition} 
  \label{def:proof_subtyping_abstraction_elimination}
  Proof Subtyping (Expansion Elimination)
  \hfill
  \boxed{\Theta, \Delta \entails \phi \subtypes \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails
      \tau_a \subtypes \tau
      \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails
      \tau_b \subtypes \tau
      \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails
      \tau_a\J{|}\tau_b \subtypes \tau
      \given \Theta'', \Delta'' 
    }
    \\
    \inferrule {
      \Theta_l \notfree \Delta
      \\
      \Theta_l \notfree \tau_r
      \\\\
      \Theta, \Delta \entails \Delta_l \given \Theta', \Delta' \unique
      \\
      \Theta' \cup \Theta_l, \Delta' \entails
      \tau_l \subtypes \tau_r \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails
      \J{EXI[}\Theta_l\J{]}\Delta_l\ \tau_l \subtypes \tau_r
      \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
For elimination of a union $\tau_a\J{|}\tau_b$,
proof subtyping solves the easier sub-problems
on the union's constituents.
For elimination of an indexed union $\J{EXI[}\Theta_l\ \Delta_l \J{]}\tau_l$, 
proof subtyping ensures that the indexed union's bound variables
are not free in the super type $\tau_r$. 
Then it finds a solution for the qualifiers $\Delta_l$.
Finally it finds a solution for eliminating the indexed union's body $\tau_l$,
assuming the solution to the qualifiers $\Delta$.

When eliminating the indexed union's body,
the the bound variables $\Theta_l$ must be treated as closed variables.
Since the indexed union is in the elimination position, 
the qualifiers $\Delta_l$ and its solution $\Delta$ indicate 
the strongest information that can safely be assumed when eliminating the body $\tau_l$.
Marking $\Theta_l$ as closed ensures that proof subtyping
does not erroneously learn stronger information on those variables 
in order to prove the elimination of $\tau_l$.
Another requirement for safety is that 
eliminating of $\tau_l$ must hold under all solutions of the qualifiers $\Delta_l$.
Proof subtyping ensures this with the even stronger restriction that the solution
to $\Delta_l$ is unique. That is, instead of letting the proof split into
different worlds and then recombining when necessary, proof subtyping simply prevents
splitting the worlds too eagerly. 

\begin{definition} 
  \label{def:proof_subtyping_refinement_introduction}
  Proof Subtyping (Refinement Introduction)
  \hfill
  \boxed{\Theta, \Delta \entails \tau \subtypes \psi \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails
      \tau \subtypes \tau_{a} \given \Theta', \Delta' 
      \\
      \Theta', \Delta' \entails
      \tau \subtypes \tau_{b} \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails
      \tau \subtypes \tau_{a}\J{\&}\tau_{b} \given \Theta'', \Delta''
    }
    \\
    \inferrule {
      \Theta_r \notfree \Delta
      \\
      \Theta_r \notfree \tau_l
      \\\\
      \Theta, \Delta \given \Delta_r  \given \Theta', \Delta' \unique
      \\
      \Theta' \cup \Theta_r, \Delta' \entails \tau_l \subtypes \tau_r \given \Theta'', \Delta'' 
    } {
      \tau_l \subtypes \J{ALL[}\Theta_r\J{]}\Delta_r\ \tau_r \given \Theta'', \Delta''
    }
  \end{mathpar}
\end{definition}

\noindent
Refinement introduction is the dual of expansion elimination, so its rules
rely on analogous techniques.

\begin{definition} 
  \label{def:proof_subtyping_variable_elimination}
  Proof Subtyping (Variable Elimination)
  \hfill
  \boxed{\Theta, \Delta \entails \alpha \subtypes \tau \given \Theta', \Delta'} 
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \notin \Theta
      \\
      \Theta \entails \Delta[\alpha\slash\tau]^{+} \backslash \Delta \twoheadrightarrow \Delta_\closed \wr \Delta_\open
      \\\\
      \Theta, \Delta \entails \Delta_\closed \safe
      \\
      \Theta, \Delta \cup \Delta_\closed \entails \Delta_\open \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails \alpha \subtypes \tau \given \Theta', \Delta'\ \alpha\J{<:}\tau
    }

    \inferrule {
      \alpha \in \Theta 
      \\
      \Theta, \Delta \entails \alpha \subtypes \tau_r \safe
      \\
      \nexists \alpha'  \qua \tau_r = \alpha'
    } {
      \Theta, \Delta \entails 
      \alpha \subtypes \tau_r
      \given \Theta, \Delta
    }
  \end{mathpar}
\end{definition}

\noindent
Variable elimination has two cases, 
one for open variables $\alpha \not\in \Theta$,
and one for closed variables $\alpha \in \Theta$.
For open variable elimination, proof subtyping simply learns
the subtyping constraint that it's proving.
However, it must check that the constraint is consistent
with the other assumptions of the world,
to ensure that there is an interpretation under which the subtyping holds. 
To check consistency of assumptions,  
proof subtyping constructs constraints $\Delta[\alpha/\tau]^+$ that must hold by 
substituting the supertype $\tau$ into all positive occurrences
of $\alpha$ in the subtyping environment $\Delta$.
It takes just the new constraints with successful substitutions
and splits them into two subtyping environments $(\Delta_\closed, \Delta_\open)$. 
The first environment $\Delta_\closed$ contains only the constraints with a single
closed variable in either the subtype or supertype position. The second
environment $\Delta_\open$ contains all the remaining constraints.

Proof subtyping leverages the environment safety predicate 
$(\Theta, \Delta) \entails \Delta_\closed \safe$, 
to ensure that the updated constraints on closed variables are consistent and safe.
If so, then proof subtyping takes the updated constraints on closed variables, influenced by their relation
to open variables, and adds them to the input assumptions 
$(\Theta, \Delta \cup \Delta_\closed) \preceq (\Theta', \Delta')$ 
and then solves the remaining constraints $\Delta_\open \given \Theta', \Delta'$. 

To eliminate a closed variable $\alpha \in \Theta$,
proof subtyping leverages the predicate for variable elimination safety
$(\Theta, \Delta) \entails \alpha \subtypes \tau_r \safe$,
which guarantees that all possible interpretations for $\alpha$
are stronger than $\tau_r$.

\begin{definition} 
  \label{def:proof_subtyping_variable_introduction}
  Proof Subtyping (Variable Introduction)
  \hfill
  \boxed{\Theta, \Delta \entails \tau \subtypes \alpha \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \notin \Theta
      \\
      \Theta \entails \Delta[\alpha\slash\tau]^{-} \backslash \Delta \twoheadrightarrow \Delta_\closed \wr \Delta_\open
      \\\\
      \Theta, \Delta \entails \Delta_\closed \safe
      \\
      \Theta, \Delta \cup \Delta_\closed \entails 
      \Delta_\open \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \tau \subtypes \alpha \given \Theta', \Delta'\ \tau\J{<:}\alpha
    }

    \inferrule {
      \alpha \in \Theta 
      \\
      \Theta, \Delta \entails \tau_l \subtypes \alpha \safe
      \\
      \nexists \alpha' \qua \tau_l = \alpha'
    } {
      \Theta, \Delta \entails 
      \tau_l \subtypes \alpha \given \Theta, \Delta
    }
  \end{mathpar}
\end{definition}

\noindent
Variable introduction is the dual of variable elimination, so its rules
rely on analogous techniques.


\begin{definition} 
  \label{def:proof_subtyping_lfp_elimination}
  Proof Subtyping (Least Fixed Point Elimination)
  \hfill
  \boxed{\Theta, \Delta \entails \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \not\in \textbf{ftv}(\tau_r)
      \\
      \Theta, \Delta \entails 
      \tau_l[\alpha\slash\tau_r]^+ \subtypes \tau_r \given 
      \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r 
      \given \Theta', \Delta' 
    }
  \end{mathpar}
\end{definition}

\noindent
For least fixed point elimination, $\J{LFP[} \alpha \J{]} \tau_l \subtypes \tau_r$, 
proof subtyping reasons by mathematical induction. 
In practice, proof subtyping substitutes the super type $\tau_r$
into all positive occurrences of the self reference $\alpha$ in the least fixed point body $\tau_l$.
It then solves the elimination of this substitution against the super type 
$\tau_l[\alpha\slash\tau_r]^+ \subtypes \tau_r \given \Omega$.
Using this substitution is stronger than the direct requirement of mathematical induction,
which is that the body is stronger than the supertype $\tau_l \subtypes \tau_r$ 
assuming the induction hypothesis that the self reference is stronger than the super type
$\alpha \subtypes \tau_r$ 

\begin{definition} 
  \label{def:proof_subtyping_difference_intro}
  Proof Subtyping (Difference Introduction)
  \hfill
  \boxed{\Theta, \Delta \entails\tau \subtypes \rho \typdiff \eta \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \tau \subtypes \rho \given \Theta', \Delta' 
      \\
      \textbf{ftv}(\eta) \subseteq \epsilon
      \\
      \nexists \Theta', \Delta' \qua  
      \Theta, \Delta \entails 
      \tau \subtypes \eta \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \tau \subtypes \rho \typdiff \eta
      \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}

\noindent
For difference introduction, $\tau \subtypes \tau_r \typdiff \eta$, 
proof subtyping checks that subtyping holds for the positive part 
$\tau \subtypes \rho \given \Omega$.
Then it requires that there are no free variables
in the subtracted part $\textbf{ftv}(\eta) \subseteq \epsilon$,
and also that introduction of the subtracted part fails $
  \nexists \Omega' .\  
  \Omega \preceq \Omega'
  \land
  \tau \subtypes \eta \given \Omega'
$.
The restricted form of a subtracted type $\eta$ and its lack of free variables
ensures that its introduction is complete,
which in turn guarantees that is failure is sound.

\begin{definition} 
  \label{def:proof_subtyping_lfp_intro}
  Proof Subtyping (Least Fixed Point Introduction)
  \hfill
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \circlearrowleft \J{LFP[} \alpha \J{]} \tau_r
      \\
      \Theta, \Delta \entails
      \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
      \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails
      \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}

\noindent
For least fixed point introduction $\tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r$,
proof subtyping employs a heuristic $\Omega \entails \tau_l \circlearrowleft \J{LFP[} \alpha \J{]} \tau_r$ 
to approximately judge whether or not the subtyping constraint is decidable. 
Once the syntactic forms of the types indicate that a decision can be made,
then proof subtyping simply unrolls the least fixed point type 
and solves the new subproblem $\tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]$.

\begin{definition} 
  \label{def:proof_subtyping_diff_elimination}
  Proof Subtyping (Difference Elimination)
  \hfill
  \boxed{\Theta, \Delta \entails \rho \typdiff \eta \subtypes \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \rho \subtypes \tau \J{|} \eta \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \rho \typdiff \eta \subtypes \tau \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}

\noindent
For difference elimination $\rho \typdiff \eta \subtypes \tau$,
proof subtyping simply rewrites the problem in terms of union
$\rho \subtypes \tau \J{|} \eta$.

\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Proof Subtyping (Expansion Introduction)
  \hfill
  \boxed{\Theta, \Delta \entails \tau \subtypes \phi \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \tau_{l} \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Theta', \Delta' 
    }

    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \tau_{r} \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Theta', \Delta' 
    }

    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \Delta_r \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails 
      \tau_l
      \subtypes 
      \J{EXI[}\Theta_r\J{]}\Delta_r\ \tau_r \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
Expansion introduction provides a means for introducing
generalized types from one of their instances.
For union introduction $\tau \subtypes \tau_{l}\J{|}\tau_{r}$, 
proof subtyping can choose from two possible worlds:
one where the left part is introduced $\tau \subtypes \tau_l$,
or one where the right part is introduced $\tau \subtypes \tau_r$. 
For index union introduce $\J{EXI[}\Theta_r\ \Delta_r \J{]}\tau_r$,
proof subtyping constructs potential witnesses by solving the introduction
of the indexed union's body $\tau_l \subtypes \tau_r \given \Omega$, 
where the witnesses can be inferred from the subtyping environment of the world $\Omega$.
It then confirms these are the potential witnesses are valid
by proving the qualifiers hold under such witnesses $\Delta_r \given \Omega'$.


\begin{definition} 
  \label{def:proof_subtyping_refinement_elimination}
  Proof Subtyping (Refinement Elimination)
  \hfill
  \boxed{\Theta, \Delta \entails \psi \subtypes \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_{l} \subtypes \tau \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Theta', \Delta' 
    }

    \inferrule {
      \Theta, \Delta \entails \tau_{l} \subtypes \tau \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \Delta_l \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails 
      \J{ALL[}\Theta_l\J{]} \Delta_l\ \tau_l
      \subtypes 
      \tau_r
      \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
Refinement elimination is the dual of expansion introduction, so its rules
rely on analogous techniques.

\begin{definition} 
  \label{def:variable_elimination_safety}
  Variable Elimination Safety 
  \hfill
  \boxed{\Theta, \Delta \entails \alpha \subtypes \tau \safe}
  \\
  \begin{mathpar}
    \inferrule {
      \exists \tau' \qua  \alpha \J{<:} \tau' \in \Delta
      \up 
      (
      (\exists \alpha' \qua \tau' = \alpha' \up \alpha' \notin \Theta) 
      \down 
      (\exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau' \subtypes \tau \given \Theta', \Delta') 
      )
      \\\\
      \forall \tau' \qua  \tau' \J{<:} \alpha \in \Delta
      \implies 
      \exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau' \subtypes \tau \given \Theta', \Delta'  
      \\
    } {
      \Theta, \Delta \entails \alpha \subtypes \tau \safe
    }
  \end{mathpar}
\end{definition}

\noindent
A variable may be eliminated if it meets two conditions.
The first condition is that the variable has an upper bound that is either an open variable or can be eliminated.
An upper bound of an open variable indicates that the variable being eliminated
can be as strong as its lower bounds.
The second condition is that all lower bounds of that variable can be eliminated. 

\begin{definition} 
  \label{def:variable_introduction_safety}
  Variable Introduction Safety
  \hfill
  \boxed{\Theta, \Delta \entails \tau \subtypes \alpha \safe}
  \\
  \begin{mathpar}
    \inferrule {
      \exists \tau' \qua  \tau' \J{<:} \alpha \in \Delta
      \up 
      (
      (\exists \alpha' \qua \tau' = \alpha' \up \alpha' \notin \Theta) 
      \down 
      (\exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau \subtypes \tau' \given \Theta', \Delta') 
      )
      \\\\
      \forall \tau' \qua  \alpha \J{<:} \tau' \in \Delta
      \implies 
      \exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau' \subtypes \tau \given \Theta', \Delta' 
      \\
    } {
      \Theta, \Delta \entails \tau \subtypes \alpha \safe
    }
  \end{mathpar}
\end{definition}

\noindent
Variable introduction safety is the dual of variable elimination safety, so its rules
rely on analogous techniques.

\begin{definition} 
  \label{def:proof_sequence_subtyping}
  Proof Sequence Subtyping
  \hfill
  \boxed{\Theta, \Delta \entails \Delta_q \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta \entails \epsilon \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails \tau_l \J{<:} \tau_r \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \tau_l \J{<:} \tau_r \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails \Delta_q\ \tau_l \J{<:} \tau_r \given \Theta'', \Delta''
    }
  \end{mathpar}
\end{definition}

\begin{definition} 
  \label{def:unique_proof_sequence_subtyping}
  Unique Proof Sequence Subtyping
  \hfill
  \boxed{\Theta, \Delta \entails \Delta_q \given \Theta', \Delta' \unique}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \Delta_q \given \Theta', \Delta'
      \\\\
      \forall \Theta'', \Delta'' \qua 
      \Theta, \Delta \entails
      \Delta_q \given \Theta', \Delta' \implies (\Theta'', \Delta'') = (\Theta', \Delta')
    } {
      \Theta\ \Delta \entails \Delta_q \given \Theta', \Delta' \unique
    }
  \end{mathpar}
\end{definition}


% \section{Experiments}

% \TODO{develop 12 tree/list experiments}

% \section{Related work}

% \TODO{...}


% \paragraph{Tree interpolation}
% Exemplified by CHC duality solver.

% \paragraph{Hindley-Milner type inference}
% Exemplified by ML.

% \paragraph{Logic programming.}
% Exemplified by Prolog. 


% Similar: both have backchaining. 

% Different: RLT is fully declarative, lacks negations, but has implication. 

% Different: RLT allows comparing inductive relations via subtyping. 

% \paragraph{Semantic subtyping.} 
% Exemplified by XDuce and CDuce. complete subtyping.

% Similar: set-like combinators: union and intersection.

% Different: RLT uses rigid syntactic rules; incomplete subtyping.

% % set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% % semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
% The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
% "semantics subtyping" means the semantics of types is determined indirectly by the semantics of another structure.
% "syntactic subtyping" means the semantics of types is determined directly by the type structure

% \paragraph{Extrinsic typing.}
% Exemplified by Typescript, which is unsound. Maybe not as lenient?  
% The static behavior of a program is not necessarily specified/prescribed; 
% it may be over-approximated from the program composition. 
% Intrinsic vs extrinsic is orthogonal to static vs dynamic, although static and dynamic are often used to mean the former.
% All modern languages use a combination of static and dynamic type checking.
% The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
% even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.

% \paragraph{Refinement Types.}
% Exemplified by Refinement ML. Base types with intersections and subtyping.

% \paragraph{Predicate Subtyping.}
% Exemplified by Liquid Types. An extension of refinement types.

% Similar: both use type inference to infer expressive relational properties. 

% Different: RLT starts with an invalid post-condition, then weakens return type to a valid post-condition from outside in by expanding unions.

% Different: RLT starts with an invalid pre-condition, then strengthens parameter type to a valid pre-condition from inside out by adding intersections.

% Different: Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.


% \paragraph{Abstraction Refinement.} 
% Similar: type unification over subtyping resembles abstraction refinement  
% where solving for variables and failing on different sides of the subtyping relation corresponds to
% solving with the abstractor vs solving with the refiner.

% \paragraph{Craig interpolation.} 
% Similar: extracting an inductive type with unions and intersections 
% from a recursive program without needing to specify a predicate universe might be similar to
% craig interpolation.

% \paragraph{PDR.}
% exemplified by IC3. 

% Similar: RLT infers abstract type for return type, 
% then safely constrains the variables in previous step (fix's antecedent) 
% to subtype the least fixed point.
% This lazily propagates the type for the last step to the previous steps.
% This is safe as antecedent is stronger than consequent at any step.
% Seems similar to the notion in PDR of propagating negation of loss points to previous steps. 

% Different: RLT isn't cartesian


\section{Appendix}
\label{sect:appendix}

\begin{definition} 
  \label{def:type_interpretation}
  Type Interpretation 
  \hfill
  \boxed{
    \llbracket \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \llbracket \Theta \entails \Delta, \alpha \rrbracket^\pm 
      &\ =\ & 
      \llbracket \Theta \star \Delta, \alpha \rrbracket^\pm
      &\text{if}& 
      \alpha \notin \Theta

      \\

      &&
      (\Delta, \alpha)
      &\text{if}&
      \alpha \in \Theta

      \\

      \llbracket \Theta \entails \Delta, \J{@} \rrbracket^\pm 
      &\ =\ & 
      (\Delta, \J{@})
      &&

      \\

      \llbracket \Theta \entails \Delta, \J{<}l\J{>}\tau \rrbracket^\pm
      &\ =\ & 
      (\Delta', \J{<}l\J{>}\tau')
      &\text{if}& 
      \llbracket \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')

      \\

      \llbracket \Theta \entails \Delta, \tau_l\J{->}\tau_r \rrbracket^\pm 
      &\ =\ & 
      (\Delta_l \cap \Delta_r, \tau_l'\J{->}\tau_r')
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \llbracket \Theta \entails \Delta, \tau_r \rrbracket^\pm = (\Delta_r, \tau_r')
        \\
        \llbracket \Theta \entails \Delta, \tau_l \rrbracket^{\text{flip}(\pm)} = (\Delta_l, \tau_l')
      \end{array}

      \\

      \llbracket \Theta \entails \Delta, \tau_l\J{|}\tau_r \rrbracket^\pm
      &\ =\ & 
      (\Delta_l \cap \Delta_r, \tau_l'\J{|}\tau_r')
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \llbracket \Theta \entails \Delta, \tau_l \rrbracket^\pm = (\Delta_l, \tau_l')
        \\
        \llbracket \Theta \entails \Delta, \tau_r \rrbracket^{\pm} = (\Delta_r, \tau_r')
      \end{array}

      \\

      \llbracket \Theta \entails \Delta, \tau_l\J{\&}\tau_r \rrbracket^\pm 
      &\ =\ & 
      (\Delta_l \cap \Delta_r, \tau_l'\J{\&}\tau_r')
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \llbracket \Theta \entails \Delta, \tau_l \rrbracket^\pm = (\Delta_l, \tau_l')
        \\
        \llbracket \Theta \entails \Delta, \tau_r \rrbracket^{\pm} = (\Delta_r, \tau_r')
      \end{array}

      \\

      \llbracket \Theta \entails \Delta, \J{EXI[}\Theta_q\ \Delta_q \J{]} \tau \rrbracket^\pm 
      &\ =\ & 
      (\Delta' \cap \Delta'', \J{EXI[}\Theta_q\ \Delta_q' \J{]}\tau')
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \llbracket \Theta \cup \Theta_q \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
        \\
        \llbracket \Theta \cup \Theta_q \entails \Delta, \tau \rrbracket^{\pm} = (\Delta'', \tau')
      \end{array}

      \\

      \llbracket \Theta \entails \Delta, \J{ALL[}\Theta_q\ \Delta_q \J{]} \tau \rrbracket^\pm 
      &\ =\ & 
      (\Delta' \cap \Delta'', \J{ALL[}\Theta_q\ \Delta_q' \J{]}\tau')
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \llbracket \Theta \cup \Theta_q \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
        \\
        \llbracket \Theta \cup \Theta_q \entails \Delta, \tau \rrbracket^{\pm} = (\Delta'', \tau')
      \end{array}

      \\

      \llbracket \Theta \entails \Delta, \tau \typdiff \eta \rrbracket^\pm 
      &\ =\ & 
      (\Delta', \tau' \typdiff \eta)
      &\text{if}& 
      \llbracket \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')

      \\

      \llbracket \Theta \entails \Delta, \J{LFP[}\alpha \J{]} \tau \rrbracket^\pm 
      &\ =\ & 
      (\Delta', \J{LFP[}\alpha \J{]}\tau')
      &\text{if}& 
      \llbracket \Theta\ \alpha \entails \Delta, \tau \rrbracket^{\pm} = (\Delta', \tau')
      \\
  \end{array}
  \]
\end{definition}

\begin{definition} 
  \label{def:qualification_interpretation}
  Qualification Interpretation 
  \hfill
  \boxed{
    \llbracket \Theta \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \llbracket \Theta \entails \Delta, \epsilon \rrbracket^\pm
      &\ =\ & 
      (\Delta', \epsilon')
      && 

      \\

      \llbracket \Theta \entails \Delta, \Delta_q \  \tau_l \J{<:} \tau_r \rrbracket^\pm
      &\ =\ & 
      (\Delta' \cap \Delta_l \cap \Delta_r, \Delta_q' \  \tau_l' \J{<:} \tau_r')
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \llbracket \Theta \entails \Delta, \Delta_q\rrbracket^\pm = (\Delta', \Delta_q')
        \\
        \llbracket \Theta \entails \Delta, \tau_r \rrbracket^\pm = (\Delta_r, \tau_r')
        \\
        \llbracket \Theta \entails \Delta, \tau_l \rrbracket^{\text{flip}(\pm)} = (\Delta_l, \tau_l')
      \end{array}
  \end{array}
  \]
\end{definition} 

\TODO{...}


\begin{definition} 
  \label{def:pruning_interpretation}
  Pruning Interpretation 
  \hfill
  \boxed{
    \llbracket \Theta \star \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \llbracket \Theta \star \Delta, \alpha \rrbracket^\pm
      &\ =\ & 
      (\Delta', \tau)
      &\text{if}& 
      \begin{array}[t]{@{}l}
        (\forall \tau_l\ \tau_r .\  \tau_l \J{<:} \tau_r \in \Delta' \iff \Theta, \Theta_\bullet, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r)
        \\
        \llbracket \Delta\backslash\Delta', \alpha \rrbracket^\pm = (\Delta', \tau)
      \end{array}

      \\
  \end{array}
  \]
\end{definition}

\TODO{...}

\begin{definition} 
  \label{def:indirection}
  Indirection  
  \hfill
  \boxed{
    \Theta, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r 
  }
  \\
  \begin{mathpar}
    \inferrule {
      \ \alpha\J{<:}\tau \in \Delta 
      \\\\
      \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
      \\
      \ \alpha'\J{<:}\tau' \in \Delta 
    } {
      \Theta, \Delta, \alpha \looparrowright^- \alpha \subtypes \tau
    }

    \inferrule {
      \ \alpha\J{<:}\tau \in \Delta 
      \\\\
      \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
      \\
      \ \alpha'\J{<:}\tau' \in \Delta 
    } {
      \Theta, \Delta, \alpha \looparrowright^- \alpha' \subtypes \tau'
    }
    \\
    \inferrule {
      \ \tau \J{<:} \alpha\in \Delta 
      \\\\
      \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
      \\
      \ \tau'\J{<:} \alpha' \in \Delta 
    } {
      \Theta, \Delta, \alpha \looparrowright^+ \tau \subtypes \alpha
    }

    \inferrule {
      \ \tau \J{<:} \alpha\in \Delta 
      \\\\
      \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
      \\
      \ \tau'\J{<:} \alpha' \in \Delta 
    } {
      \Theta, \Delta, \alpha \looparrowright^+ \tau' \subtypes \alpha'
    }
  \end{mathpar}
\end{definition}

\TODO{...}

\begin{definition} 
  \label{def:interpretation}
  Interpretation
  \hfill
  \boxed{
    \llbracket\Delta, \alpha \rrbracket^\pm = (\Delta, \tau)
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}

      \llbracket \epsilon, \alpha \rrbracket^-
      &\ =\ & 
      (\epsilon, \J{TOP})

      \\

      \llbracket \Delta \ \alpha  \J{<:} \tau, \alpha \rrbracket^- 
      &\ =\ & 
      (\Delta', \tau' \J{\&} \tau)
      &\text{if}& 
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau')

      \\

      \llbracket \Delta \ \tau_l \J{<:} \tau_r, \alpha \rrbracket^- 
      &\ =\ & 
      (\Delta' \ \tau_l \J{<:} \tau_r, \tau)
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \alpha \neq \tau_l
        \\
        \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau)
      \end{array}

      \\

      \llbracket \epsilon, \alpha \rrbracket^+ 
      &\ =\ & 
      (\epsilon, \J{BOT})

      \\

      \llbracket \Delta \  \tau \J{<:} \alpha  , \alpha \rrbracket^+ 
      &\ =\ & 
      (\Delta', \tau' \J{|} \tau)
      &\text{if}& 
      \llbracket \Delta, \alpha \rrbracket^+ = (\Delta', \tau')

      \\

      \llbracket \Delta \ \tau_l \J{<:} \tau_r, \alpha \rrbracket^+ 
      &\ =\ & 
      (\Delta' \ \tau_l \J{<:} \tau_r, \tau)
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \alpha \neq \tau_r
        \\
        \llbracket \Delta, \alpha \rrbracket^+ = (\Delta', \tau)
      \end{array}
  \end{array}
  \]
\end{definition}

\TODO{...}

\begin{definition}
  \label{def:type_packaging}
  Type Packaging 
  \hfill
  \boxed{\textbf{pack}^\pm(\Theta_\ignore \entails \Theta, \Delta, \tau) = \tau'} 
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \textbf{pack}^\pm(\Theta_\ignore \entails \Theta, \Delta, \tau) 
      &\ =\ & 
      \text{wrap}^{\pm}(\Theta_o, \Delta_o, \Theta_i, \Delta_i, \tau)
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \textbf{ftv}(\tau) = \Theta_p
        \\
        \Theta_\ignore \cup \Theta \cup \Theta_p \entails \Delta \dashrightarrow \Delta' 
        \\
        \Theta_\ignore, \Theta \entails \Delta' \rightrightarrows \Delta_o, \Delta_i 
        \\
        (\textbf{ftv}(\Delta) \cup \Theta_p) \cap \Theta = \Theta_o 
        \\
        \textbf{ftv}(\Delta_i) \cup \Theta_p \backslash \Theta \backslash \Theta_\ignore = \Theta_i 
      \end{array}
  \end{array}
  \]
\end{definition}


\begin{definition}
  \label{def:multiple_type_packaging}
  Multiple Type Packaging 
  \hfill
  \boxed{\textbf{pack}^\pm(\Theta \entails \Pi) = \tau}\ 
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \textbf{pack}^+(\Theta_\ignore \entails \epsilon) 
      &\ =\ & 
      \J{TOP} 

      \\

      \textbf{pack}^+(\Theta_\ignore \entails \Pi\ (\Theta, \Delta, \tau)) 
      &\ =\ & 
      \tau \J{\&} \tau' 
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \textbf{pack}^+(\Theta_\ignore \entails \Pi) = \tau 
        \\
        \textbf{pack}^+(\Theta_\ignore \entails \Theta, \Delta, \tau) = \tau'
      \end{array}

      \\

      \textbf{pack}^-(\Theta_\ignore \entails \epsilon) 
      &\ =\ & 
      \J{BOT} 

      \\

      \textbf{pack}^-(\Theta_\ignore \entails \Pi\ (\Theta, \Delta, \tau))
      &\ =\ & 
      \tau \J{|} \tau' 
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \textbf{pack}^-(\Theta_\ignore \entails \Pi) = \tau 
        \\
        \textbf{pack}^-(\Theta_\ignore \entails \Theta, \Delta, \tau) = \tau'
      \end{array}
  \end{array}
  \]
\end{definition}


\begin{definition}
  \label{def:polar_subtyping_environment_substitution}
  Polar Subtyping Environment Substitution 
  \hfill
  \boxed{\Delta[\alpha\slash\tau]^\pm = \Delta}\ 
  \\
  \begin{mathpar}
    \TODO{...}
  \end{mathpar}
\end{definition}


\begin{definition}
  \label{def:varirable_sequence_non_freedom}
  Variable Sequence Non-freedom 
  \hfill
  \boxed{\Theta \notfree \tau}
  \\
  \begin{mathpar}
    \inferrule {
      \forall \alpha .\ \alpha \in \Theta \implies \alpha \notin \textbf{ftv}(\tau)
    } {
      \Theta \notfree \tau
    }
  \end{mathpar}
\end{definition}


\begin{definition}
  Collection
  \[\begin{array}[t]{r@{}l}
    \nonterm{C} & \is \epsilon \sep C\ c
  \end{array}\]
\end{definition}

\begin{definition}
  Concatenation
  \hfill
  \boxed{C \cup C = C}
  \\
  \[\begin{array}{rclr}
    C \cup \epsilon 
    &=& 
    C
    \\

    C \cup (C'\ c) 
    &=& 
    C \cup C'\ c
  \end{array}\]
\end{definition}

\begin{definition}
  Filter
  \hfill
  \boxed{C \cap  C = C}
  \\
  \[\begin{array}{rclr}
    C \cap \epsilon 
    &=& 
    \epsilon 
    % & \C{empty} 
    \\

    C \cap (C'\ c) 
    &=& 
    \begin{cases}
      (C \cap C')\ c & \text{if } c \in C\\
      (C \cap C') & \text{otherwise}
    \end{cases}
    % & \D{Step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}
  Collection Membership 
  \hfill
  \boxed{c \in C}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      c \in C\ c 
    }

    \inferrule {
      c \neq c'
      \\
      c \in C
    } {
      c \in C\ c' 
    }
  \end{mathpar}
\end{definition}

\begin{definition}
  Collection Congruence 
  \hfill
  \boxed{C_l \cong C_r}
  \\
  \begin{mathpar}
    \inferrule {
      \forall c .\ c \in C_l \iff c \in C_r
    } {
      C_l \cong C_r 
    }
  \end{mathpar}
\end{definition}


\begin{definition} 
  Collection Containment
  \hfill
  \boxed{C \subseteq C'}
  \\
  \begin{mathpar}
    \inferrule {
      \forall c .\ c \in C \implies c \in C'
    } {
      C \subseteq C'
    }
  \end{mathpar}
\end{definition}

\begin{definition}
  Subtyping Environment Filter 
  \hfill
  \boxed{\Theta \entails \Delta \dashrightarrow \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta \entails \epsilon \dashrightarrow \epsilon 
    }

    \inferrule {
      \exists \alpha .\ \alpha \in (\textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)) \cap \Theta
      \\
      \Theta \entails \Delta \dashrightarrow \Delta'
    } {
      \Theta \entails  \Delta \  \tau_l \J{<:} \tau_r\dashrightarrow \Delta' \  \tau_l \J{<:} \tau_r
    }

    \inferrule {
      \forall \alpha .\ \alpha \in \Theta \implies \alpha \notin \textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)
      \\
      \Theta \entails \Delta \dashrightarrow \Delta'
    } {
      \Theta \entails  \Delta \  \tau_l \J{<:} \tau_r\dashrightarrow \Delta'
    }
  \end{mathpar}
\end{definition}

\begin{definition}
  Outer
  \hfill
  \boxed{\text{outer}(\pm) = \J{ALL}|\J{EXI}}
  \\
  \[\begin{array}[t]{r@{}c@{}lcl}
    \\
    \text{outer}(+) 
    &\ =\ & 
    \J{EXI} 
    % & \C{positive} 
    \\
    \text{outer}(-) 
    &\ =\ & 
    \J{ALL} 
    % & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}
  Inner
  \hfill
  \boxed{\text{inner}(\pm) = \J{ALL}|\J{EXI}}
  \\
  \[\begin{array}[t]{r@{}c@{}lcl}
    \\
    \text{inner}(+) 
    &\ =\ & 
    \J{ALL} 
    % & \C{positive} 
    \\
    \text{inner}(-) 
    &\ =\ & 
    \J{EXI} 
    % & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}
  Wrap
  \hfill
  \boxed{\text{wrap}^{\pm}(\Theta, \Delta, \Theta, \Delta, \tau) = \tau}
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
    \text{wrap}^{\pm}(\epsilon, \epsilon, \epsilon, \epsilon, \tau) 
    &\ =\ & 
    \tau
    \\
    \text{wrap}^{\pm}(\epsilon, \epsilon, \Theta_i, \Delta_i, \tau) 
    &\ =\ & 
    \text{inner}(\pm)\J{[}\Theta_i\J{ }\Delta_i\J{]}\tau
    \\
    \text{wrap}^{\pm}(\Theta_o, \Delta_o, \epsilon, \epsilon, \tau) 
    &\ =\ & 
    \text{outer}(\pm)\J{[}\Theta_o\J{ }\Delta_o\J{]}\tau
    \\
    \text{wrap}^{\pm}(\Theta_o, \Delta_o, \Theta_i, \Delta_i, \tau) 
    &\ =\ & 
    \text{outer}(\pm)\J{[}\Theta_o\J{ }\Delta_o\J{]}
    \text{inner}(\pm)\J{[}\Theta_i\J{ }\Delta_i\J{]}
    \tau
  \end{array}\]
\end{definition}


\begin{definition}
  Partition
  \hfill
  \boxed{\Theta_\ignore , \Theta \entails \Delta \rightrightarrows \Delta_o , \Delta_i}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta_\ignore , \Theta \entails \epsilon \rightrightarrows \epsilon , \epsilon 
    }

    \inferrule {
      \Theta_\ignore , \Theta \entails \Delta \rightrightarrows \Delta_o , \Delta_i 
      \\\\
      \exists \alpha .\ \alpha \in (\textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)) \backslash \Theta_\ignore \backslash \Theta
    } {
      \Theta_\ignore , \Theta \entails \Delta \  \tau_l \J{<:}\tau_r \rightrightarrows \Delta_o , \Delta_i \  \tau_l \J{<:} \tau_r
    }

    \inferrule {
      \Theta_\ignore , \Theta \entails \Delta \rightrightarrows \Delta_o , \Delta_i 
      \\\\
      \exists \alpha .\ \alpha \in (\textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)) \cap \Theta 
      \\
      \textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r) \subseteq \Theta_\ignore \cup \Theta
    } {
      \Theta_\ignore , \Theta \entails \Delta \  \tau_l \J{<:}\tau_r \rightrightarrows \Delta_o  \  \tau_l \J{<:} \tau_r , \Delta_i
    }
  \end{mathpar}

\end{definition}

\begin{theorem}
  \label{theorem:typing_environment_soundness}
  Typing Environment Soundness 
  \\
  \begin{mathpar}
    \inferrule {
      \delta, \sigma \satisfies \Gamma
    } {
      x:\tau \in \Gamma
      \implies
      \delta \satisfies x[\sigma] \hastype \tau
    }
  \end{mathpar}
\end{theorem}


\begin{theorem}
  \label{theorem:subtyping_environment_prefix_preservation}
  Subtyping Environment Prefix Preservation 
  \\
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \Delta \cup \Delta'
    } {
      \delta \satisfies \Delta
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{theorem:containment_prefix_perservation}
  Containment Prefix Preservation 
  \\
  \begin{mathpar}
    \inferrule {
      C \cup C' \subseteq C''
    } {
      C \subseteq C''
    }
  \end{mathpar}
\end{theorem}
\hfill

% \begin{theorem}
%   \label{theorem:entry_type_introdcution}
%   Entry Type Introduction 
%   \\
%   \begin{mathpar}
%     \inferrule {
%       \delta \satisfies e \hastype \tau
%     } {
%       \delta \satisfies \J{<}l\J{>}e \hastype \J{<}l\J{>}\tau
%     }
%   \end{mathpar}
% \end{theorem}
% \hfill

\begin{theorem}
  \label{theorem:record_extension_preservation}
  Record Extension Preservation 
  \\
  \begin{mathpar}
    \inferrule {
      \delta \satisfies r \hastype \tau
      \\
      \nexists e' .\ \J{<} l \J{>} e' \in r
    } {
      \delta \satisfies r\ \J{<}l\J{>}e \hastype \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{theorem:entry_type_introduction}
  Entry Type Introduction 
  \\
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \tau
      \\
      \nexists e' .\ \J{<} l \J{>} e' \in r
    } {
      \delta \satisfies r\ \J{<}l\J{>}e \hastype \J{<}l\J{>} \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{theorem:subtyping_environment_interpretation_contraction}
  Subtyping Environment Interpretation Contraction 
  \\
  \begin{mathpar}
    \inferrule {
      \delta \cup \delta' \satisfies \Delta
      \\
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \epsilon
    } {
      \delta \satisfies \Delta
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{theorem:typing_environment_interpretation_contraction}
  Typing Environment Interpretation Contraction 
  \\
  \begin{mathpar}
    \inferrule {
      \delta \cup \delta', \sigma \satisfies \Gamma 
      \\
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Gamma) = \epsilon
    } {
      \delta, \sigma \satisfies \Gamma
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{theorem:typing_interpretation_extension}
  Typing Interpretation Extension 
  \\
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \tau 
      \\
      \textbf{dom}(\delta') \cap \textbf{ftv}(\tau) = \epsilon
    } {
      \delta \cup \delta' \satisfies e \hastype \tau 
    }
  \end{mathpar}
\end{theorem}
\hfill



\begin{theorem}
  \label{theorem:skolem_variable_freshness}
  Skolem Variable Freshness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \Theta' \backslash \Theta \cap \textbf{ftv}(\Delta) = \epsilon
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{theorem:domain_extension}
  Domain Extension 
  \\
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta_l) = \Theta_l  
      \\
      \textbf{dom}(\delta_r) = \Theta_r  
    } {
      \textbf{dom}(\delta_l \cup \delta_r) = \Theta_l \cup \Theta_r 
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{theorem:proof_typing_soundness}
  Proof Typing Soundness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \exists \delta \qua \textbf{dom}(\delta) \cong \Theta' \backslash \Theta \up 
      (
      \forall \delta' \qua 
      \delta' \cup \delta \satisfies \Delta' \implies
      \delta' \cup \delta, \sigma \satisfies \Gamma \implies
      \delta' \cup \delta \satisfies e[\sigma] \hastype \tau
      )
    }
  \end{mathpar}
\end{theorem}
\hfill

  
\noindent
We prove Proof Typing Soundness by induction over Definition \ref{def:proof_typing} (Proof Typing).

\pc
For $\J{@} \hastype \J{@}$,
we derive the conclusion by applying Definition \ref{def:model_typing} (Model Typing).

\pc
For $ x \hastype \tau$, 
we derive the conclusion by applying Theorem \ref{theorem:typing_environment_soundness}
(Typing Environment Soundness).

\pc
For $\epsilon \hastype \J{TOP}$,
we derive the conclusion using Definition \ref{def:model_typing} (Model Typing).

\pc
For $r \J{<}l \J{>} e \hastype (\tau\ \J{\&}\ \J{<} l \J{>} \tau')$,
we introduce an arbitrary value interpretation $\sigma$,
and we apply the induction hypothesis to the two typings 
$r \hastype \tau$ and $e \hastype \tau'$, 
resulting in two statements, which we name $P_r$ and $P_e$, respectively. 

\noindent
First, we address the left part of the conclusion's conjunction. 
For the former, we derive
an interpretation $\delta_r$, such that $\textbf{dom}(\delta_r) \cong \Theta' \backslash \Theta$.
For the latter, we derive an interpretation $\delta_e$, 
such that $\textbf{dom}(\delta_e) \cong \Theta'' \backslash \Theta'$.
We combine these two interpretations into $\delta$,
such that $\delta = \delta_r \cup \delta_e$.
We derive $\textbf{dom}(\delta) = (\Theta' \backslash \Theta) \cup (\Theta'' \backslash \Theta')$
by applying Theorem \ref{theorem:domain_extension} (Domain Extension),
which simplifies to  $\textbf{dom}(\delta) = \Theta'' \backslash \Theta$.

\noindent
Next, we address the right part of the conclusion's conjunction. 
We introduce an arbitrary interpretation $\delta'$, and we assume
$\delta' \cup \delta \satisfies \Delta'$ and $\delta' \cup \delta, \sigma \satisfies \Gamma$.
With a little rewriting, we have $\delta' \cup \delta_r \cup \delta_e \satisfies \Delta'$
and $\delta' \cup \delta_r \cup \delta_e, \sigma \satisfies \Gamma$. 
We derive $\delta' \cup \delta_r \satisfies \Delta'$ by 
applying Theorem \ref{theorem:skolem_variable_freshness} 
and Theorem \ref{theorem:subtyping_environment_interpretation_contraction}. 
Likewise, we derive $\delta' \cup \delta_r, \sigma \satisfies \Gamma$ by 
applying Theorem \ref{theorem:skolem_variable_freshness} 
and Theorem \ref{theorem:typing_environment_interpretation_contraction}. 
From here, we apply the result of the induction hypothesis $P_r$ to get 
$\delta' \cup \delta_r \satisfies r[\sigma] \hastype \tau$,
and then lift to $\delta' \cup \delta \satisfies r[\sigma] \hastype \tau$ 
by applying Theorem \ref{theorem:typing_interpretation_extension} and Theorem \ref{theorem:skolem_variable_freshness}.
Additionally, we apply the other result of the induction hypothesis $P_e$ to get
$\delta' \cup \delta \satisfies e[\sigma] \hastype \tau'$.
We combine these terms for both types, resulting
in $\delta' \cup \delta \satisfies r[\sigma]\ \J{<}l\J{>} e[\sigma] \hastype \tau$
by applying Theorem \ref{theorem:record_extension_preservation}
and $\delta' \cup \delta \satisfies r[\sigma]\ \J{<}l\J{>} e[\sigma] \hastype \tau'$
by applying Theorem \ref{theorem:entry_type_introduction}.
We simplify to 
$\delta' \cup \delta \satisfies (r\ \J{<}l\J{>} e)[\sigma] \hastype \tau$
and $\delta' \cup \delta \satisfies (r\ \J{<}l\J{>} e)[\sigma] \hastype \tau'$
by applying Definition \ref{...} (Substitution).
Thus, we derive 
$\delta' \cup \delta \satisfies (r\ \J{<}l\J{>} e)[\sigma] \hastype \tau \J{\&} \tau'$
by applying Definition \ref{def:model_typing} (Model Typing).

$\square$


  \begin{mathpar}
    % \inferrule {
    % } {
    %   \Gamma \entails \J{@} \hastype \J{@} \given \Omega 
    % }

    % \inferrule {
    %   x:\tau \in \Gamma
    % } {
    %   \Gamma \entails x \hastype \tau \given \Omega 
    % }

    % \inferrule {
    % } {
    %   \Gamma \entails \epsilon \hastype \J{TOP} \given \Omega
    % }

    \inferrule {
      \Gamma \entails r \hastype \tau \given \Omega 
      \\\\
      \Omega \preceq \Omega'
      \\
      \Gamma \entails e \hastype \tau' \given \Omega' 
    } {
      \Gamma \entails r \J{<}l \J{>} e \hastype (\tau\ \J{\&}\ \J{<} l \J{>} \tau') \given \Omega' 
    }

    \inferrule {
      \exists \Xi.\ \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
      \\\\
      \textbf{pack}^+(\textbf{ftv}(\Gamma)\ \Theta \entails \Pi) = \tau 
    } {
      \Gamma \entails f \hastype \tau \given \Theta, \Delta
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given \Omega 
      \\\\
      \Omega \preceq \Omega'
      \\
      \tau \subtypes  \J{<} l \J{>} \alpha \given \Omega' 
    } {
      \Gamma \entails e\J{.}l \hastype \alpha \given \Omega'
    }

    \inferrule {
      \Gamma \entails e_f \hastype \tau_f \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \Gamma \entails e_a \hastype \tau_a \given \Omega' 
      \\\\
      \Omega' \preceq \Omega''
      \\
      \tau_f \subtypes \tau_a\J{->}\alpha \given \Omega'' 
    } {
      \Gamma \entails e_f\J{(}e_a \J{)} \hastype \alpha \given \Omega''
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau \subtypes \tau_a \given \Omega' 
      \\\\
      \Omega' \preceq \Omega''
      \\
      \Gamma\ x:\tau_a \entails e' \hastype \tau' \given \Omega''
    } {
      \Gamma \entails \J{let}\ x \J{:} \tau_a\ \J{=}\ e\ \J{in}\ e' \hastype \tau' \given \Omega'' 
    }

    \inferrule {
      \Gamma \entails e \hastype \alpha_\nu\J{->}\tau \given  \Theta, \Delta 
      \\
      \textbf{ftv}(\Gamma) \cup \textbf{ftv}(\Delta) = \Theta_\ignore
      \\\\
      \forall \Theta'\ \Delta' .\ 
        \Theta', \llbracket \alpha_\ignore \cup \Theta' \entails \Delta', \alpha_l \J{->} \alpha_r \rrbracket^+ \in \Pi_\nu
      \implies
      \tau \subtypes \alpha_l\J{->}\alpha_r \given  \Theta \cup \Theta', \Delta \cup \Delta' 
      \\\\
      \exists \pi.\ \pi \in \Pi_\nu
      \\
      \alpha_\nu \downarrow \Pi_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \Pi_\mu
      \\
      \textbf{pack}^-(\textbf{ftv}(\Gamma) \cup \Theta\ \alpha_\mu \entails \Pi_\mu) = \tau_\mu
      \\\\
      \exists \alpha .\ \alpha \J{*} \J{BOT} \subtypes \J{LFP[} \alpha_\mu \J{]}\tau_\mu \factorsinto \alpha \subtypes \tau_l 
      \\
      \exists \alpha .\ \J{BOT} \J{*} \alpha  \subtypes \J{LFP[} \alpha_\mu \J{]}\tau_\mu \factorsinto \alpha \subtypes \tau_r 
    } {
      \Gamma \entails \J{loop(}e\J{)} 
      \hastype 
      \tau_l \J{->} \tau_r
      \given \Theta, \Delta 
    }
  \end{mathpar}

*********************************************************************


\begin{definition}\boxed{\VDash e}
  \label{def:expression_good_formation}
  \begin{mathpar}
    \inferrule {
      e = v
    } {
      \VDash e
    } 

    \inferrule { 
      e \rightsquigarrow e' 
      \\
      \VDash e'
    } {
      \VDash e
    } 
  \end{mathpar}
\end{definition}

\begin{theorem}(Typing Soundness)
  \label{theorem:typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \entails e \hastype \tau \given Z
    } {
      \VDash e
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } \entails e \hastype \tau \given Z$
    \item \Z $\B{let } \delta\ \Gamma' \ \tau' \B{ s.t. } \delta, \Gamma' \satisfies e \hastype \tau'$ by \D{Lemma \ref{theorem:proof_typing_soundness}}
    \item \Z $\delta, \sigma \satisfies \Gamma'$ by ...
    \item \Z $\VDash e[\sigma]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $e[\sigma] = e$ by ...
    \item \Z $\VDash e$ by substitution 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof typing consistency)
  \label{theorem:proof_typing_consistency}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \delta .\ \delta \satisfies Z
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\begin{theorem}(Proof typing soundness)
  \label{theorem:proof_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}


\begin{theorem}(Proof typing weak soundness)
  \label{theorem:proof_typing_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \forall \delta .\ \delta \satisfies Z \implies \delta, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}

  \TODO{rewrite inductive hypotheses with just the conclusion implied by the case conditions}

  \TODO{rewrite cases with universal/implication in conclusion/hypotheses}

  Proof: 
  \item $
    \B{assume } 
    \Gamma \entails e \hastype \tau \given Z 
  $ 
    \item \Z $\B{induct on } \Gamma \entails e \hastype \tau \given Z$ 

    \item \Z $\B{case } e = \J{@} \I \tau = \J{@}$ 
      \item \Z\Z $\B{let } \delta$ by definition
      \item \Z\Z $\delta, \Gamma \satisfies \J{@} \hastype \J{@}$ by definition
      \item \Z\Z $\delta, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau$ by witness 

    \item \Z $\B{case } e = x \I \J{$x$:$\tau$} \in \Gamma$ 
    \item \Z $\B{wrt } x$ 
      \item \Z\Z $\B{let } \delta$ by definition
      \item \Z\Z $\delta, \Gamma \satisfies x \hastype \tau$  by definition
      \item \Z\Z $\delta, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau$ by witness 

  \item \Z $\B{case } 
    \Gamma \entails e' \hastype \tau' \given Z
    \I
    \tau = \J{<$l$>$\tau'$}
    \I
    e = \J{<$l$>$e'$} 
  $ 
  \item \Z $\B{hypo } 
      \Gamma \entails e' \hastype \tau' \given Z  
      \implies
      \delta, \Gamma \satisfies e' \hastype \tau'
  $ 
  \item \Z $\B{wrt } e' \ \tau'$ 
    \item \Z\Z $\B{let } \delta $ by definition
    \item \Z\Z $
      \delta, \Gamma \satisfies e' \hastype \tau'
    $ by application
    \item \Z\Z $
      \delta, \Gamma \satisfies \J{<$l$>$e'$} \hastype \J{<$l$>$\tau'$}
    $ by definition
    \item \Z\Z $
      \delta, \Gamma \satisfies e \hastype \tau 
    $ by substitution
    \item \Z\Z $
      \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau 
    $ by witness 

  \item \Z \TODO{remaining trivial introduction cases} 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item \Z $\B{case } $ 
  \item \Z $\B{hypo } $ 
  \item \Z $\B{wrt } $ 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %   \inferrule {
  %     \Gamma \entails R \hastype \tau_0 \given Z_0
  %     \\
  %     Z_0 \looparrowright Z_1
  %     \\
  %     \Gamma \entails e \hastype \tau_1 \given Z_1
  %   } {
  %     \Gamma \entails R\ \J{*$l$=$e$} \hastype \tau_0\ \J{\&}\ \J{$l$:$\tau_1$} \given Z_1
  %   }

  %   \inferrule {
  %     Z, \Gamma \entails F \liftfun \Pi, \Tau_n 
  %     \\
  %     \Gamma \entails \Pi \equiv \Tau 
  %   } {
  %     \Gamma \entails F \hastype \J{\&}(\Tau) \given Z
  %   }
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau_0 \subtypes \J{$l$->$\alpha$} \given Z_1
    \I
    e = \J{$e_0$.$l$} \I \tau = \alpha \I Z = Z_1
  $
   
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0 
    \implies 
    \delta, \Gamma \satisfies e_0 \hastype \tau_0
  $ 
  \item \Z $\B{wrt } \delta\ e' \ l \ \alpha \ \tau_0 \ Z_0 \ Z_1$ 

    \item \Z\Z $
      \delta, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application

    \item \Z\Z $
      \B{let }
      M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \J{$l$->$\alpha$} \given M, \Delta
    $ by theorem \ref{theorem:proof_subtyping_choice}


    \item \Z\Z $
      \delta \satisfies \tau_0  \subtypes \J{$l$->$\alpha$}
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness}
    \item \Z\Z $
      \delta, \Gamma \satisfies e_0 \hastype \J{$l$->$\alpha$}
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \delta, \Gamma \satisfies \J{$e_0$.$l$} \hastype \alpha 
    $ by theorem \ref{theorem:model_subtyping_record_elimination} 
    \item \Z\Z $
      \delta, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau
    $ by witness 


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \I
    e = \J{$e_0$($e_1$)} 
    \I 
    \tau = \alpha 
    \I
    Z = Z_2
  $ 
  \item \Z $ 
    Z_1 \looparrowright Z_2
    \I
    \tau_0 \subtypes \J{$\tau_1$->$\alpha$} \given Z_2
  $ 
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \implies 
    \delta, \Gamma \satisfies e_0 \hastype \tau_0
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \implies 
    \delta, \Gamma \satisfies e_1 \hastype \tau_1
  $ 
  \item \Z $\B{wrt } e_0\ e_1\ \alpha\ \tau_0\ \tau_1\ Z_0\ Z_1\ Z_2 $ 
    \item \Z\Z $
      \delta, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application
    \item \Z\Z $
      \delta, \Gamma \satisfies e_1 \hastype \tau_1
    $ by application

    \item \Z\Z $
      \B{let } M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \J{$\tau_1$->$\alpha$} \given \left<M, \Delta \right>
    $ by theorem \ref{theorem:proof_subtyping_choice} 
    \item \Z\Z $
      \delta, \Gamma \satisfies \tau_0 \subtypes \J{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness} 
    \item \Z\Z $
      \delta \satisfies e_0 \hastype \J{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \delta, \Gamma \satisfies \J{$e_0$($e_1$)} \hastype \alpha
    $ by theorem \ref{theorem:model_typing_implication_elimination} 
    \item \Z\Z $
      \delta, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau
    $ by substitution 

  \item \Z $\B{case } 
    e = \J{loop($e'$)} 
  $ 
  \item \Z $\contin  
    \tau = \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFLFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$} 
  $
  \item \Z $\contin 
    Z = Z_0 
  $
  \item \Z $\contin  
    \Gamma \entails e' \hastype \J{$\alpha_{h^+}$->$\tau'$} \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau' \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
  $ 
  \item \Z $\contin  
    \textbf{ftv}(\Gamma) \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{hypo } 
    \forall \delta .\ \delta \satisfies Z_0 \implies
    \delta, \Gamma \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau'$}
  $ 
  \item \Z $\B{wrt } e'\ \tau'\ \alpha_{h^+}\ \alpha_l\ \alpha_r\ \alpha_{h^-}\ \alpha_l'\ \alpha_r'\ \Tau\ Z_0\ Z_1 $ 
    \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies Z$
      \item \Z\Z\Z $\delta \satisfies Z_0$ by substitution
      \item \Z\Z\Z $
        \delta, \Gamma \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau'$}
      $ by instantiation and application
      \item \Z\Z\Z $
        \delta \satisfies \tau' \subtypes 
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$}
      $ by theorem \ref{theorem:fixpoint_duality_soundness}

      \item \Z\Z\Z $
        \delta \satisfies \tau' \subtypes \tau
      $ by substitution  

      \item \Z\Z\Z $
        \delta \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau$}
      $ by theorem \ref{theorem:model_subtyping_elimination} 

      \item \Z\Z\Z $
        \delta \satisfies \J{loop($e'$)} \hastype \tau 
      $ by theorem \ref{theorem:model_typing_implication_independence}

      \item \Z\Z\Z $
        \delta \satisfies e \hastype \tau 
      $ by substitution 

    \item \Z\Z $
      \forall \delta .\ \delta \satisfies Z \implies \delta \satisfies e \hastype \tau 
    $ by implication and generalization 

  \item \Z $\delta, \Gamma \satisfies e \hastype \tau$
    by induction
  \item $\square$
\end{theorem}

\begin{theorem}(Fixpoint duality soundness (new))
  \label{theorem:fixpoint_duality_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \\
      \textbf{ftv}(\tau) \subseteq N
      \\
      \alpha_l \notin N
      \\
      \alpha_r \notin N
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \delta \satisfies 
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\TODO{Cretin's corresponding theorem is Theorem 101 on p. 134}

\TODO{See how Cretin proves this without using subject reduction}

\begin{theorem}(Fixpoint duality soundness old)
  \label{theorem:fixpoint_duality_soundness_old}
  \begin{mathpar}
    \inferrule { 
      Z_0 \looparrowright Z_1
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \forall \tau .\ 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume }
    Z_0 \looparrowright Z_1
    \I
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $ 
  \item \Z $\B{induct on }
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{case }
    Z_1 = \epsilon \I \Tau = \epsilon
  $
    \item \Z\Z $\B{for } \tau$
      \item \Z\Z\Z $\B{assume }
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      $
        \item \Z\Z\Z\Z $
          \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given \epsilon 
        $ by substitution

        \item \Z\Z\Z\Z $
          \B{let } M\ \Delta\ \B{ s.t. } \left<M, \Delta\right> \in \epsilon 
        $ by theorem \ref{theorem:universe_proof_typing_worldly}  

        \item \Z\Z\Z\Z $\bot$ by theorem \ref{theorem:empty_containment_absurd}
      \item \Z\Z\Z $
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
        \implies
        \tau
        \subtypes
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
        \given Z_0
      $ by implication
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by generalization 
  \item \Z $\B{case }
    Z_1 = Z\ \left<M, \Delta \right> \I \Tau = \Tau_i\ \tau_i
  $
  \item \Z $\contin
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \J{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
  $
  \item \Z $\contin
    M, \Delta, \Delta \entails \alpha_{h^+} \subtypes \Tau_h
    \I
    M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
    \I
    M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
  $
  \item \Z $\contin
    \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\ \tau_r .\ \tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
  $
  \item \Z $\contin
    N \cup M \cup \textbf{ftv}(\Tau_l) \cup \textbf{ftv}(\Tau_r)\ \alpha_{h^-} = \Alpha 
    \I
    \Delta \entails \Alpha \pitchfork \Delta_i  
  $
  \item \Z $\contin
    N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
  $
  \item \Z $\B{hypo }
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \J{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
    \implies
    \\
    \forall \tau .\ 
    \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z
    \implies
    \tau
    \subtypes
    \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
    \given Z_0
  $
  \item \Z $\B{wrt }
    Z\ M\ \Delta\ \Tau_i\ \tau_i
  $

    \item \Z\Z $\B{for } \tau \B{ assume }
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
    $
      \item \Z\Z\Z $
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z\ \left<M, \Delta\right>
      $ by substitution

      \item \Z\Z\Z $
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      $ by theorem \ref{theorem:proof_subtyping_decomposition}

      \item \Z\Z\Z $
        \tau
        \subtypes
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by instantiation and application 
      \item \Z\Z\Z $
        \tau
        \subtypes
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by theorem \ref{theorem:universe_proof_typing_fixpoint_extension}
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by implication and generalization 


  \item \Z $
    \forall \tau .\ 
    \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
    \implies
    \tau
    \subtypes
    \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    \given Z_0
  $ by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint extension)
  \label{theorem:universe_proof_typing_fixpoint_extension}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r$} 
      \\\\
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \cup M \cup \textbf{ftv}(\Tau_l) \cup \textbf{ftv}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
    } {
      \delta \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing case soundness)
  \label{theorem:universe_proof_typing_case_soundnes}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \cup M \cup \textbf{ftv}(\Tau_l) \cup \textbf{ftv}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
    } {
      \delta \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau_i$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint union)
  \label{theorem:universe_proof_typing_fixpoint_union}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau$)]$\alpha_r$} 
      \\
      \delta \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau$]$\alpha_r$} 
    } {
      \delta \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau\ \tau$)]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}\ Influential soundness 
  \label{theorem:influential_soundness}

  \TODO{Prove that any constraints on non-influential variables with have been transitively applied to the influential variables}

  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given M, \Delta
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      \textbf{ftv}(\tau) \subseteq \Alpha
      \\\\
      N, M, \Delta \cup \Delta' \given \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau
      \\
      N, M, \Delta_i \cup \Delta' \given \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau_i
    } {
      \delta \satisfies \tau \subtypes \tau_i 
      \land
      \delta \satisfies \tau_i \subtypes \tau
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

% \begin{theorem}(Universe proof typing implication expansion)
%   \label{theorem:universe_proof_typing_implication}
%   \begin{mathpar}
%     \inferrule { 
%       M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
%       \\
%     } {
%       \J{\&$(\Tau_l)$->|$(\Tau_r)$}
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:(\&$(\Tau_l)$,|$(\Tau_r)$)]$\alpha_r$} 
%       \given M, \Delta
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Universe proof typing implication expansion)
  \label{theorem:universe_proof_typing_implication_expansion}
  \begin{mathpar}
    \inferrule { 
    } {
      \J{$\tau_l$->$\tau_r$}
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:($\tau_l$,$\tau_r$)]$\alpha_r$} 
      \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\forall x \in X .\ \exists y .\ (x,y) \in (X \times Y)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\neg (\exists x \in X \land \nexists y \in Y)$} 
  \item $\square$
\end{theorem}

\begin{theorem}(Upper bound interpretation sound)
  \label{theorem:upper_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \alpha \subtypes \Tau 
    } {
     \alpha \subtypes \J{\&$(\Tau)$} \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Lower bound interpretation sound)
  \label{theorem:lower_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \Tau \subtypes \alpha
      \\
    } {
     \J{|$(\Tau)$} \subtypes \alpha \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Universe proof typing worldly)
  \label{theorem:universe_proof_typing_worldly}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta\ .\ \left<M, \Delta\right> \in Z
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Empty containment absurd)
  \label{theorem:empty_containment_absurd}
  \begin{mathpar}
    \inferrule { 
      \left<M, \Delta\right> \in \epsilon 
    } {
      \bot
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing implication independence)
  \label{theorem:model_typing_implication_independence}
  \begin{mathpar}
    \inferrule { 
      \delta, \Gamma \satisfies e \hastype \J{$\tau_l$->$\tau_r$} 
      \\
      \delta \satisfies \tau_r
    } {
      \delta, \Gamma \satisfies \J{loop($e$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


% \begin{theorem}(Proof typing fix interpolation weakest pre-condition)
%   \label{theorem:fix_duality}
%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \J{$\alpha_0$->$\alpha_1$->$\alpha_2$} \given Z_1
%       \\\\
%       \textbf{ftv}(\Gamma) \entails \alpha_0 \cdot Z_1 \cdot \J{$\alpha_1$->$\alpha_2$} \fallingdotseq \alpha_3 \circlearrowright \Tau_{rel}
%     } {
%       \J{ALL[$\alpha_4$]$\alpha_4$->EXI[$\alpha_5$.($\alpha_4$,$\alpha_5$)<:LFP[$\alpha_3$.|$(\Tau_{rel})$]]$\alpha_5$} 
%       \subtypes
%       \J{$\alpha_1$->$\alpha_2$}
%       \given Z_1
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Proof subtyping decomposition)
  \label{theorem:proof_subtyping_decomposition}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z\ \left<M, \Delta\right>
    } {
      \tau_l \subtypes \tau_r \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Proof subtyping choice)
  \label{theorem:proof_subtyping_choice}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta .\ \tau_l \subtypes \tau_r \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Model subtyping elimination)
  \label{theorem:model_subtyping_elimination}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \delta, \Gamma \satisfies e \hastype  \tau_l  
    } {
      \delta, \Gamma \satisfies e \hastype \tau_r 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \delta \satisfies \tau_l \subtypes \tau_r
    \I
    \delta, \Gamma \satisfies e \hastype  \tau_l  
  $
  \item \Z $\B{invert on } \delta \satisfies \tau_l \subtypes \tau_r$
  \item \Z $\B{case } \forall e'\ \Gamma' .\ \delta, \Gamma' \satisfies e' \hastype  \tau_l  \implies \delta, \Gamma' \satisfies e' \hastype \tau_r$
  \item \Z\Z $\delta, \Gamma \satisfies e \hastype  \tau_l  \implies \delta, \Gamma \satisfies e \hastype \tau_r$ by instantiation
  \item \Z\Z $\delta, \Gamma \satisfies e \hastype \tau_r$ by application 
  \item \Z $\delta, \Gamma \satisfies e \hastype \tau_r$ by inversion
  \item $\square$ by implication
\end{theorem}


\begin{theorem}(Model typing record elimination)
  \label{theorem:model_subtyping_record_elimination}
  \begin{mathpar}
    \inferrule { 
      \delta, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
    } {
      \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \delta, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
  $ 
    \item \Z $\B{induct on } 
      \delta, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
    $ 
    \item \Z $\B{case }
      e = G
      \I
      \J{?$l$=>$v$} \in G
      \I
      \delta, \Gamma \satisfies v \hastype \tau
      \I
      \forall v' .\ \J{?$l$=>$v'$} \in G \implies v' = v 
    $ 
    \item \Z $\B{wrt }
      G\ v 
    $
  
      \item \Z\Z $
        \delta, \Gamma \satisfies G \hastype \J{$l$->$\tau$}
      $ by substitution

      \item \Z\Z $
        \J{$G$.$l$} \rightsquigarrow v
      $ by definition 

      \item \Z\Z $
        \B{let } \sigma \B{ s.t. } \delta, \Gamma \satisfies \sigma 
      $ by theorem \ref{...} 
      \item \Z\Z $
        \J{$G$.$l$}[\sigma] \rightsquigarrow v
      $ by definition 
      \item \Z\Z $
        v = v[\sigma \cup \epsilon] 
      $ by definition 
      \item \Z\Z $
        \J{$G$.$l$}[\sigma] \rightsquigarrow v[\sigma \cup \epsilon] 
      $ by substitution 
      \item \Z\Z $
        \delta, \epsilon \satisfies \epsilon 
      $ by definition 

      \item \Z\Z $
        \delta, \Gamma \cup \epsilon \satisfies v \hastype \tau
      $ by definition 
      \item \Z\Z $
        \delta, \Gamma \satisfies \J{$G$.$l$} \hastype \tau 
      $ by definition 
      \item \Z\Z $
        \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
      $ by substitution


    \item \Z $\B{case }
      \delta, \sigma \satisfies \Gamma
      \I
      e[\sigma] \rightsquigarrow e'[\sigma \cup \sigma']
      \I
      \delta, \sigma' \satisfies \Gamma'
      \I
      \delta, \Gamma \cup \Gamma' \satisfies e' \hastype \J{$l$->$\tau$}
    $
    \item \Z $\B{hypo }
      \delta, \Gamma \cup \Gamma' \satisfies e' \hastype \J{$l$->$\tau$}
      \implies
      \delta, \Gamma \cup \Gamma' \satisfies \J{$e'$.$l$} \hastype \tau
    $
    \item \Z $\B{wrt }
      \sigma\ e'\ \sigma'\ \Gamma'
    $
      \item \Z\Z $
        \delta, \Gamma \cup \Gamma' \satisfies \J{$e'$.$l$} \hastype \tau
      $ by application
      \item \Z\Z $
        \J{$e[\sigma]$.$l$} \rightsquigarrow \J{$e'[\sigma \cup \sigma']$.$l$}
      $ by definition 
      \item \Z\Z $
        \J{$e[\sigma]$.$l$} = \J{$e$.$l$}[\sigma]
      $ by definition 
      \item \Z\Z $
        \J{$e'[\sigma \cup \sigma']$.$l$} = \J{$e'$.$l$}[\sigma \cup \sigma']
      $ by definition 
      \item \Z\Z $
        \J{$e$.$l$}[\sigma] \rightsquigarrow \J{$e'$.$l$}[\sigma \cup \sigma']
      $ by substitution 
      \item \Z\Z $
        \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
      $ by definition 

    \item \Z $
      \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
    $ by induction 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof subtyping consistency)
  \label{theorem:proof_subtyping_consistency}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \delta .\ 
      \delta \satisfies \Delta
    } 
  \end{mathpar}
\end{theorem}

\begin{theorem}(Proof subtyping soundness)
  \label{theorem:proof_subtyping_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \delta .\ 
      \delta \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}
\end{theorem}


\begin{theorem}(Proof subtyping weak soundness)
  \label{theorem:proof_subtyping_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \forall \delta .\ 
      \delta \satisfies \Delta
      \implies
      \delta \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}

\TODO{closed variabless simply remove variables from soundness consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (EXI[X . 1 <: X, X <: 3] X) <: 2  -| 1 <: X, X <: 3, ..., X <: 2  
% FAILS, not considered for soundness
% (EXI[X . 1 <: X, X <: 2] X) <: 2  -| 1 <: X, X <: 2, ..., X <: 2  
% PASSES, is considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2 <: (EXI[X . 1 <: X, X <: 3] X)  -| 2 <: X, ..., 1 <: X, X <: 3 
% PASSES, is considered for soundness
% 2 <: (EXI[X . X <: 1 ] X)  -| 2 <: X, ..., X <: 1
% FAILS, not considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Proof: 
  \item \TODO{think about how to handle the mutually recursive definition} 
  \item $\B{assume } 
    \tau_l \subtypes \tau_r \given M, \Delta 
  $
    \item \Z $\B{induct on } \tau_l \subtypes \tau_r \given M, \Delta$

    \item \Z $\B{case } \tau_l = \tau \I \tau_r = \tau$
    \item \Z $\B{wrt } \tau $
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \tau \subtypes \tau$
        by theorem \ref{theorem:model_typing_reflexivity}
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_l = \J{BOT}$
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \J{BOT} \subtypes \tau_r$ by definition
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_r = \J{TOP}$
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \J{TOP}$ by definition
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } 
      \tau_r = \J{$l$->($\tau_{rl}$\&$\tau_{rr}$)}
      \I
      \tau_l
      \subtypes
      \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
      \given M, \Delta
    $
    \item \Z $\B{hypo }
      \forall \delta .\ 
      \delta \satisfies \Delta
      \implies
      \delta \satisfies \tau_l \subtypes \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
    $ 
    \item \Z $\B{wrt } l\ \tau_{rl}\ \tau_{rr}$ 
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
        by application
        \item \Z\Z\Z $\B{for } e\ \Gamma \B{ assume } \delta, \Gamma \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
          by theorem \ref{theorem:model_typing_subsumption} 
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{$l$->$\tau_{rl}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{$l$->$\tau_{rr}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau_{rl}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau_{rr}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies \J{$e$.$l$} \hastype \J{$\tau_{rl}$\&$\tau_{rr}$}$ by definition
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{$l$->($\tau_{rl}$\&$\tau_{rr}$)}$ by theorem \ref{theorem:model_typing_record_introduction} 
          \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e\ \Gamma .\ \delta, \Gamma \satisfies e \hastype \tau_l \implies 
          \delta, \Gamma \satisfies e \hastype \tau_r
        $ by implication and generalization
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$
        by definition 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 


    \item \Z $\B{case } 
      \tau_l = \J{$\tau_{ll}$|$\tau_{lr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      \tau_{ll} \subtypes \tau_r
      \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_{lr} \subtypes \tau_r
      \given M_1, \Delta_1
    $

    \item \Z $\B{hypo } 
      \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies \tau_{ll} \subtypes \tau_r
      \I
      \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies \tau_{lr} \subtypes \tau_r
    $
    \item \Z $\B{wrt } \tau_{ll}\ \tau_{lr}$

      \item \Z\Z $\B{for } \delta \B{ assume } M, \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\delta \satisfies \tau_{lr} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\delta \satisfies \Delta_0$ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\delta \satisfies \tau_{ll} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\delta \satisfies \J{$\tau_{ll}$|$\tau_{lr}$} \subtypes \tau_r$ 
        by definition
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ 
        by substitution 

      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \J{$\tau_{rl}$\&$\tau_{rr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin 
      \tau_l \subtypes \tau_{rl} \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_{rr} \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies \tau_l \subtypes \tau_{rl} 
      \I
      \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies \tau_l \subtypes \tau_{rr} 
    $
    \item \Z $\B{wrt } $
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_{rr}$ by instantiation and application 
        \item \Z\Z\Z $\delta \satisfies \Delta_0 $ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_{rl}$ by instantiation and application 
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \J{$\tau_{rl}$\&$\tau_{rr}$}$ by definition 
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization


    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \J{($\tau_{ra}$->$\tau_{rc}$)\&($\tau_{rb}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes 
    %   \J{$\tau_{ra}$|$\tau_{rb}$->$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \J{($\tau_{ra}$->$\tau_{rb}$)\&($\tau_{ra}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \J{$\tau_{ra}$->$\tau_{rb}$\&$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } 
      \tau_l = \J{EXI[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A \notfree \tau_r
      \I
      M_0 \cup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_b \subtypes \tau_r
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies M_1, \tau_b \subtypes \tau_r 
    $
    \item \Z $\B{mutu } 
      \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\delta \satisfies \tau_b \subtypes \tau_r$ by application
        \item \Z\Z\Z $\delta \satisfies \Delta_0 $ by theorem \ref{theorem:model_subtyping_sequence_prefix}
        \item \Z\Z\Z $\delta \satisfies Q$ by application
        \item \Z\Z\Z $\B{for } e \B{ assume } \delta \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\delta \satisfies e \hastype \J{EXI[$\Alpha$ $Q$]$\tau_b$}$ by substitution
          \item \Z\Z\Z\Z $\delta \satisfies e \hastype \tau_r$ by theorem \ref{theorem:model_typing_existential_elimination} 
        \item \Z\Z\Z $\forall e .\ \delta \satisfies e \hastype \tau_l 
          \implies \delta \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \J{ALL[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A \notfree \tau_l
      \I
      M_0 \cup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_b
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies \tau_l \subtypes \tau_b 
    $
    \item \Z $\B{mutu } 
      \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_b$ by application 
        \item \Z\Z\Z $\delta \satisfies \Delta_0$ by theorem \ref{theorem:model_subtyping_sequence_prefix} 
        \item \Z\Z\Z $\delta \satisfies Q$ by application 
        \item \Z\Z\Z $\B{for } e \B{ assume } \delta \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\delta \satisfies e \hastype \J{ALL[$\Alpha$ $Q$]$\tau_b$}$ by theorem \ref{theorem:model_typing_universal_introduction} 
          \item \Z\Z\Z\Z $\delta \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e .\ \delta \satisfies e \hastype \tau_l 
          \implies \delta \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization
      \item \Z\Z \TODO{...} 

% e :  ALL[a b . 3 <: a ] (a,b) \implies e : (a,b)
    \item \Z $\B{case } 
      \tau_l = \alpha
      \I
      M = M_1
      \I
      \Delta = \Delta_1\ \alpha <: \tau_r
    $
    \item \Z $\contin
      \alpha \notin M_0
      \I
      M_0, \Delta_0 \entails \Delta_m <:^\sharp \alpha \slash \tau_r
      \I
      M_0, \Delta_0 \entails \Tau <:^\dagger \alpha
      \I
      M_0 \preceq M_1
    $
    \item \Z $\contin
      \Delta_0 \cup \Delta_m \preceq \Delta_1
      \I
      \J{|$(\Tau)$} <: \tau_r \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } \forall \delta .\ \delta \satisfies \Delta_1 \implies
      \delta \satisfies \J{|$(\Tau)$} <: \tau_r
    $
    \item \Z $\B{wrt } \alpha\ M_1\ \Delta_1\ M_0\ \Delta_0\ \Delta_m\ \Tau$
      \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
        \item \Z\Z\Z $\delta \satisfies \Delta_1 \J{($\alpha$<:$\tau_r$)}$ by substitution
        \item \Z\Z\Z $\delta \satisfies \alpha <: \tau_r$ by theorem \ref{theorem:model_subtyping_sequence_last} 
        \item \Z\Z\Z $\delta \satisfies \tau_l <: \tau_r$ by substitution 
      \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \notin M_0
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot M
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot \Delta_{skol}
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Tau 
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Delta_{rel}
    %   \\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \widebar{\J{.$\tau_0[\alpha\slash\tau_l]$<:$\tau_1$}}^{\tau_0<:\tau_1 \in \Delta_{rel}} \cup \widebar{\J{.$\tau_l$<:$\tau$}}^{\tau \in \Tau}
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    %   \cup \widebar{\tau_l<:z}^{z \in M}
    %   \cup \widebar{\tau[\alpha\slash\tau_l]<:z}^{\tau<:z \in \Delta_{skol}} \ \tau_l<:\alpha 
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \alpha <: \tau \in (\Delta_0 \cup \text{factor}(\Delta_0, \alpha))
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau \subtypes \tau_r
    %   \given M_1, \Delta_1
    % } {
    %   \alpha \subtypes \tau_r
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \tau <: \alpha \in \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau_l \subtypes \tau
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q
    %   \given M_1, \Delta_1
    % } {
    %   \J{ALL[$\Alpha$ $Q$]$\tau_l$}
    %   \subtypes 
    %   \tau_r
    %   \given M_1, \Delta_1 
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r
    %   \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q \given M_1, \Delta_1
    % } {
    %   \tau_l
    %   \subtypes 
    %   \J{EXI[$\Alpha$ $Q$]$\tau_r$}
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{ll} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \J{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{lr} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \J{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rl}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \J{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rr}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \J{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
    by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem} Model typing existential elimination 
  \label{theorem:model_typing_existential_elimination}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies e \hastype \J{EXI[$\Alpha$ $Q$]$\tau_l$}
      \\
      \delta \satisfies Q
      \\
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha \notfree \tau_r
    } {
      \delta \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: 
% depends on proof subtyping 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ... |= 2 : (EXI[X . 1 <: X, X <: 3] X)
% X/1 |= 1 <: X, X <: 3
% -------------------------
% X/1 |= 2 : 1 (FAIL) 
% -------------------------
% X/1 |= 2 : 4  (PASS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% X <: 4  -| X, 1 <: X, X <: 3

\end{theorem}

\begin{theorem} Model typing universal introduction 
  \label{theorem:model_typing_universal_introduction}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies e \hastype \tau_l
      \\
      \delta \satisfies Q
      \\
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha \notfree \tau_l
    } {
      \delta \satisfies e \hastype \J{ALL[$\Alpha$ $Q$]$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}
\end{theorem}





\begin{theorem} Model subtyping sequence last 
  \label{theorem:model_subtyping_sequence_last}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \Delta\ \J{($\tau_l$<:$\tau_r$)}
    } {
      \delta \satisfies \tau_l \subtypes \tau_r 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence reduction 
  \label{theorem:model_subtyping_sequence_reduction}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \Delta\ \delta
    } {
      \delta \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence prefix  
  \label{theorem:model_subtyping_sequence_prefix}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \Delta'
      \\
      \Delta \preceq \Delta'
    } {
      \delta \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence uncat 
  \label{theorem:model_subtyping_sequence_uncat}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \Delta \cup \Delta'
    } {
      \delta \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} concatenation prefix 
  \label{theorem:concatenation prefix}
  \begin{mathpar}
    \inferrule { 
    } {
      \Delta \preceq \Delta \cup \Delta'
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model subtyping unsub left 
  \label{theorem:Modle_subtyping_unsub_left}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_l \in \delta
    } {
      \delta \satisfies \alpha \subtypes \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping unsub right 
  \label{theorem:Modle_subtyping_unsub_right}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_r \in \delta
    } {
      \delta \satisfies \tau_l \subtypes \alpha
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping something 
  \label{theorem:Modle_subtyping_something}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \Delta 
      \\
      M, \Delta \entails \Tau \subtypes^\sharp \alpha  
    } {
      \alpha\slash\J{|$(\Tau)$} \in \delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem} Model typing record introduction 
  \label{theorem:model_typing_record_introduction}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \J{$e$.$l$} \hastype \tau
    } {
      \delta \satisfies e \hastype \J{$l$->$\tau$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing implication introduction 
  \label{theorem:model_typing_implication_introduction}
  \TODO{this is really messed up}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies \J{$e_0$($e_1$)} \hastype \tau_r
      \\
      \delta \satisfies e_1 \hastype \tau_l
      \\
      \forall \tau .\ \delta \satisfies e_1 \hastype \tau \implies \tau_l \subtypes \tau
    } {
      \delta \satisfies e_0 \hastype \J{$\tau_l$->$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing intersection elimination 
  \label{theorem:model_typing_intersection_elimination}
  \begin{mathpar}
    \inferrule { 
      \delta \satisfies e \hastype \tau_l \& \tau_r
    } {
      \delta \satisfies e \hastype \tau_l 
      \land
      \delta \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model typing reflexivity
  \label{theorem:model_typing_reflexivity}
  \begin{mathpar}
    \inferrule { 
    } {
      \delta \satisfies \tau \subtypes \tau
    } 
  \end{mathpar}
  Proof:
  \item $\B{for } e\ \Gamma \B{ assume } \delta, \Gamma \satisfies e \hastype \tau$
    \item \Z $\delta, \Gamma \satisfies e \hastype \tau$ by identity
  \item $\forall e\ \Gamma .\ \delta, \Gamma \satisfies e \hastype \tau \implies \delta, \Gamma \satisfies e \hastype \tau$
  by implication and generalization
  \item $\square$ by definition
\end{theorem}


\begin{theorem}(Model typing subsumption)
  \label{theorem:model_typing_subsumption}
  \begin{mathpar}
    \inferrule { 
      \delta, \Gamma \satisfies e \hastype \tau_l 
      \\
      \delta, \Gamma \satisfies \tau_l <: \tau_r
    } {
      \delta, \Gamma \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } \delta, \Gamma \satisfies e \hastype \tau_l 
  \I \delta, \Gamma \satisfies \tau_l <: \tau_r
  $
    \item \Z $\B{invert on}\ \delta, \Gamma \satisfies \tau_l <: \tau_r$
    \item \Z $\B{case}\ \forall e' .\ \delta, \Gamma \satisfies e' : \tau_l \implies \delta, \Gamma \satisfies e' : \tau_r$
      \item \Z\Z $\forall e' .\ \delta, \Gamma \satisfies e' : \tau_l \implies \delta, \Gamma \satisfies e' : \tau_r$ by identity
    \item \Z $\forall e' .\ \delta, \Gamma \satisfies e' : \tau_l \implies \delta, \Gamma \satisfies e' : \tau_r$ by inversion
    \item \Z $\delta, \Gamma \satisfies e : \tau_l \implies \delta, \Gamma \satisfies e : \tau_r$ by instantiation 
    \item \Z $\delta, \Gamma \satisfies e : \tau_r$ by application
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}(Model typing implication elimination)
  \label{theorem:model_typing_implication_elimination}
  \begin{mathpar}
    \inferrule { 
      \delta, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r
      \\
      \delta, \Gamma \satisfies e_1 \hastype \tau_l
    } {
      \delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume }
    \delta, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r
    \I 
    \delta, \Gamma \satisfies e_1 \hastype \tau_l
  $ 

    \item \Z $\B{let } \sigma \B{ s.t. } \delta, \sigma \satisfies \Gamma$ by theorem \ref{...}
    \item \Z $\B{induct on } \delta, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r$

    \item \Z $\B{case }$ \TODO{...}

    % \inferrule { 
    %   \delta, \Gamma \cup \Gamma' \satisfies p \pattype \tau_p
    %   \\
    %   \delta, \Gamma \cup \Gamma'  \satisfies e \hastype \tau_r
    %   \\\\
    %   \forall e .\ 
    %     \delta, \Gamma \satisfies e \hastype \tau_l 
    %     \implies
    %     \delta, \Gamma \satisfies e \hastype \tau_p 
    %     \land
    %     (\forall \tau_n\ \tau .\ \delta, \Gamma \satisfies F \hastype \J{$\tau_n$->$\tau$} \implies \neg (\delta, \Gamma \satisfies e \hastype \tau_n))
    % } {
    %   \delta, \Gamma \satisfies \J{$F$*$p$=>$e$} \hastype \J{$\tau_l$->$\tau_r$}
    % }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \inferrule { 
    %   \delta, \Gamma \satisfies F \hastype \J{$\tau_l$->$\tau_r$}
    % } {
    %   \delta, \Gamma \satisfies \J{$F$*$p$=>$e$} \hastype \J{$\tau_l$->$\tau_r$}
    % } 
    \item \Z $\B{case }
      e_0 = \J{$F$?$p$=>$e_2$}
      \I
      \delta, \Gamma \satisfies F \hastype \J{$\tau_l$->$\tau_r$}
    $ 
    \item \Z $\B{hypo }
      \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
    $
    \item \Z $\B{wrt }
      F\ p\ e_2 
    $
      \item \Z\Z $\VDash \J{$F$($e_1$)}[\sigma] $
      by theorem \ref{theorem:model_typing_soundness}
      \item \Z\Z $\B{invert on } \VDash \J{$F$($e_1$)}[\sigma]$
      \item \Z\Z $\B{case } \J{$F$($e_1$)}[\sigma] = v$
      \item \Z\Z $\B{wrt } v$
        \item \Z\Z\Z $\J{$F$($e_1$)}[\sigma] \neq v$ by definition 
        \item \Z\Z\Z $\bot$ by application
      \item \Z\Z $\B{case } 
        (\J{$F$($e_1$)})[\sigma] \rightsquigarrow e_3
        \I
        \delta, \Gamma \satisfies e_3 \hastype \tau_r
      $
      \item \Z\Z $\B{wrt } e_3$
        \item \Z\Z\Z $(\J{$F$($e_1$)})[\sigma] = \J{$F[\sigma]$($e_1[\sigma]$)}$ by definition
        \item \Z\Z\Z $\J{$F[\sigma]$($e_1[\sigma]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\B{let } F' \B{ s.t. } F[\sigma] = F'$ by theorem \ref{...} \TODO{...}
        \item \Z\Z\Z $\B{let } e_1' \B{ s.t. } e_1[\sigma] = e_1'$ by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\text{FV}(e_2[\sigma\backslash\text{FV}(p)]) \subseteq \text{FV}(p)$ 
        by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\J{$F'$($e_1'$)} \rightsquigarrow e_3$ by substitution 
        \item \Z\Z\Z $\J{($F'$?$p$=>$e_2[\sigma\backslash\text{FV}(p)]$)($e_1'$)} \rightsquigarrow e_3$ by definition 
        \item \Z\Z\Z $(\J{$F[\sigma]$?$p$=>$e_2[\sigma\backslash\text{FV}(p)]$)($e_1[\sigma]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $(\J{($F$?$p$=>$e_2$)($e_1$)})[\sigma] = \J{($F[\sigma]$?$p$=>$e[\sigma\backslash\text{FV}(p)]$)($e_1[\sigma]$)}
        $ by definition
        \item \Z\Z\Z $(\J{($F$?$p$=>$e_2$)($e_1$)})[\sigma] \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
      \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% OLD 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \item \Z $\B{case }
    %   \delta, \Gamma \cup \Gamma' \satisfies p \hastype \tau_l
    %   \I
    %   \delta, \Gamma \cup \Gamma'  \satisfies e \hastype \tau_r
    % $
    % \item \Z $ 
    %   \contin
    %   F = \epsilon \lor \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r
    %   \I
    %   e_0 = \J{($F$?$p$=>$e$)} 
    % $
    % \item \Z $
    %   \B{hypo} \  \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r \implies \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
    % $
    % \item \Z $
    %   \B{wrt} \ F \ p \ e \ \Gamma' \  
    % $
    %   \item \Z\Z $F = \epsilon \lor \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r$ by application
    %   \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r$ by substitution 
    %   \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_reduced_implication_elimination}
    %   \item \Z\Z $\delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ by substitution 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \item \Z $\B{case }
      \delta, \sigma \satisfies \Gamma
      \I
      e_0[\sigma] \rightsquigarrow e_0'
      \I
      \delta, \Gamma \satisfies e_0' \hastype \tau_l \J{->} \tau_r
    $
    \item \Z $\B{hypo}\ 
      \delta, \Gamma \satisfies e_0' \hastype \tau_l \J{->} \tau_r
      \implies
      \delta, \Gamma \satisfies \J{$e_0'$($e_1$)} \hastype \tau_r
    $
    \item \Z $ 
    \B{wrt}\ \sigma\ e_0' 
    $
      \item \Z\Z $\delta, \Gamma \satisfies e_0'\J{(}e_1\J{)} \hastype \tau_r$ by application 
      \item \Z\Z $e_0[\sigma]\J{(}e_1\J{)} \rightsquigarrow e_0'\J{(}e_1\J{)}$
      \item \Z\Z ($e_0\J{(}e_1\J{)})[\sigma] \rightsquigarrow e_0'\J{(}e_1\J{)}$
      \item \Z\Z $\delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ 

    \item \Z $\delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ by induction
  \item $\square$
\end{theorem}

\begin{theorem}\ Model typing reduced implication elimination  

  \label{theorem:model_typing_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r
      \\
      \delta, \Gamma \satisfies e_1 \hastype \tau_l
      \\
      F = \epsilon \lor \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
    } {
      \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume } \VDash e_1[\sigma]$


    \item \Z $\B{let } \sigma \B{ s.t. } \delta, \sigma \satisfies \Gamma $ by theorem \ref{theorem:model_typing_assignability} 
    \item \Z $\VDash e_1[\sigma]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $\B{induct on } \VDash e_1[\sigma]$

    \item \Z $\B{case } e_1[\sigma] = v_1 $
    \item \Z $\B{wrt } v_1$  
      \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_fully_reduced_implication_elimination}

    \item \Z $\B{case}\ e_1[\sigma] \rightsquigarrow e_1' \I \VDash e_1'$
    \item \Z $\B{hypo}\ \VDash e_1' \implies \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$
    \item \Z $\B{wrt}\ e_1' $

      \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$ by application
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} \rightsquigarrow \J{($F$?$p$=>$e$)$[\sigma]$($e_1'$)}$ by definition 
      \item \Z\Z $\forall x .\ x \notin \B{FV}(e_1')$ by theorem \ref{theorem:reduction_closed} 
      \item \Z\Z $e_1' = e_1'[\sigma]$ by by theorem \ref{theorem:closed_substitution} 
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} \rightsquigarrow \J{($F$?$p$=>$e$)$[\sigma]$($e_1'[\sigma]$)}$ by substitution 
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow (\J{($F$?$p$=>$e$)($e_1'$)})[\sigma]$ by definition 
      \item \Z\Z $\sigma \cup \epsilon = \sigma$ by definition 
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow (\J{($F$?$p$=>$e$)($e_1'$)})[\sigma \cup \epsilon]$ by substitution 
      \item \Z\Z $\Gamma \cup \epsilon = \Gamma$ by definition
      \item \Z\Z $\delta, \epsilon \satisfies \epsilon$ by definition
      \item \Z\Z $\delta, \Gamma \cup \epsilon \satisfies \J{($F$?$p$=>$e$)($e_1'$)}$ by substitution 
      \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by definition
    \item \Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by induction
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}\ Model typing fully reduced implication elimination 
  \label{theorem:model_typing_fully_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r
      \\
      F = \epsilon \lor \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
      \\
      \delta \satisfies e_1 \hastype \tau_l
      \\
      \delta, \sigma \satisfies \Gamma 
      \\
      e_1[\sigma] = v_1
      \\
    } {
      \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume}\ F = \epsilon \lor \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r$
    \TODO{add more assumptions}
    \item \Z $\delta \satisfies e_1[\sigma] \hastype \tau_l$ by theorem \ref{theorem:model_typing_valuation} 
    \item \Z $\delta \satisfies v_1 \hastype \tau_l$ by substitution 
    \item \Z $\B{invert on}\ F = \epsilon \lor \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r$
    \item \Z $\B{case } F = \epsilon$ 
      \item \Z\Z $\delta, \Gamma \satisfies \J{$F$?$p$=>$e$} \hastype \tau_l \J{->} \tau_r$ by theorem \ref{theorem:model_typing_unwrapping} 
      \item \Z\Z $\delta, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r$ by substitution 

      \item \Z\Z $\B{let}\ \sigma' \B{ s.t. } p \equiv v_1 \given \sigma'$ 
      by theorem \ref{theorem:model_typing_pattern_matching} 

      \item \Z\Z $\B{for } e'$ 
        \item \Z\Z\Z $\neg \epsilon[\sigma]\J{($v_1$)} \rightsquigarrow e'$ by definition
        \item \Z\Z\Z $\neg F[\sigma]\J{($v_1$)} \rightsquigarrow e'$ by substitution 
      \item \Z\Z $\forall e' .\ \neg F[\sigma]\J{($v_1$)} \rightsquigarrow e'$ by generalization 

      \item \Z\Z $\J{($F[\sigma]$?$p$=>$e[\sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\sigma\backslash\B{FV}(p)][\sigma]$ by definition 

      \item \Z\Z $\forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\sigma')$ 
      by theorem \ref{theorem:pattern_matching_consistency}
      \item \Z\Z $\sigma\backslash\B{FV}(p) = \sigma\backslash\B{dom}(\sigma')$ 
      by theorem \ref{theorem:consistency_diffing}
      \item \Z\Z $e[\sigma\backslash\B{dom}(\sigma')][\sigma'] = e[\sigma \cup \sigma']$ 
      by theorem \ref{theorem:concatenation_substitution}

      \item \Z\Z $\J{($F[\sigma]$?$p$=>$e[\sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\sigma\backslash\B{dom}(\sigma')][\sigma]$ 
        by substitution
      \item \Z\Z $\J{($F[\sigma]$?$p$=>$e[\sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\sigma \cup \sigma']$ 
        by substitution 
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($v_1$)} \rightsquigarrow e[\sigma \cup \sigma']$ by definition 
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} \rightsquigarrow e[\sigma \cup \sigma']$ by substitution  

      \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} = (\J{($F$?$p$=>$e$)($e_1$)})[\sigma]$ by definition  
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow e[\sigma \cup \sigma']$ by substitution  

      \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition

    \item \Z $\B{case } \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r$ 
      \item \Z\Z $\B{let } e' \B{ s.t. } (\J{$F$($e_1$}))[\sigma] \rightsquigarrow e' \land \delta, \Gamma \satisfies e' \hastype \tau_r$ by theorem \ref{theorem:model_typing_function_progress}
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow e'$ by definition 
      \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
    \item \Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
  \item $\square$ by implication
\end{theorem}


\begin{theorem}\ (Pattern matching consistency)
  \label{theorem:pattern_matching_consistency}
  \begin{mathpar}
    \inferrule {
      p \equiv v \given \sigma
    } {
      \forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\sigma)
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}\ (Consistency diffing)
  \label{theorem:consistency_diffing}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \in X_l \iff x \in X_r 
    } {
      \sigma\backslash X_l = \sigma\backslash X_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Concatenation Substitution )
  \label{theorem:concatenation_substitution}
  \begin{mathpar}
    \inferrule {
    } {
      e[\sigma\backslash\B{dom}(\sigma')][\sigma'] = e[\sigma \cup \sigma']
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}(Model typing valuation)
  \label{theorem:model_typing_valuation}
  \begin{mathpar}
    \inferrule {
      \delta, \Gamma \satisfies e \hastype \tau 
      \\
      \delta, \sigma \satisfies \Gamma
    } {
      \delta \satisfies e[\sigma] \hastype \tau 
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \delta, \Gamma \satisfies e \hastype \tau 
    \I
    \delta, \sigma \satisfies \Gamma
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing pattern matching)
  \label{theorem:model_typing_pattern_matching}
  \begin{mathpar}
    \inferrule {
      \delta, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r
      \\
      \delta \satisfies v \hastype \tau_l 
    } {
      \exists \sigma .\  p \equiv v \given \sigma
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \delta, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r
    \I
    \delta \satisfies v \hastype \tau_l 
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Well-formed function valuation)
  \label{theorem:wellformed_function_valuation}
  \begin{mathpar}
    \inferrule {
      \VDash F
    } {
      \exists v .\ v = F 
    } 
  \end{mathpar}
\end{theorem}
\begin{proof}
  \item $\B{assume } \VDash F$ 
    \item \Z $\B{invert on } \VDash F$
    \item \Z $\B{case } v = F$
      \item \Z\Z $v = F$ by identity
    \item \Z $\B{case } F \rightsquigarrow e$
    \item \Z $\B{wrt } e$
      \item \Z\Z $\neg F \rightsquigarrow e$ by definition
      \item \Z\Z $\bot$ by application 
    \item \Z $v = F$ by inversion 
  \item $\square$
\end{proof}


\begin{theorem}(Reduction closed)
  \label{theorem:reduction_closed}
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \forall x .\ x \notin \B{FV}(e')
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    e \rightsquigarrow e'
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Closed substitution)
  \label{theorem:closed_substitution}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \notin \B{FV}(e)
    } {
      e = e[\sigma]
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \forall x .\ x \notin \B{FV}(e)
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}



% \begin{theorem}(Progress of pattern matching)
%   \label{theorem:pattern_matching_progress}
%   \begin{mathpar}
%     \inferrule {
%       \J{*$p$=>$e$} \in F 
%       \\
%       p \equiv v \given \sigma 
%       \\
%       \forall e' .\ \J{*$p$=>$e'$} \in F \implies e' = e 
%     } {
%       \exists e' .\ F\J{(}v\J{)} \rightsquigarrow e'
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{for } p\ e\ F\ v\ \sigma\ \B{assume }
%       \J{*$p$=>$e$} \in F 
%       \I
%       p \equiv v \given \sigma 
%       \I
%       \forall e' .\ \J{*$p$=>$e'$} \in F \implies e' = e 
%   $

%   \item \Z $\B{case }
%     F = F'\ \J{*$p$=>$e$} 
%     \I
%     \J{*$p$=>$e$} \notin F'
%   $

%   \item \Z\Z $\B{for } e'$
%   \item \Z\Z\Z $\B{case}\ F'\J{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\J{(}F'\ \J{*}p\J{=>}e\J{)(} v \J{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z\Z\Z $F\J{(}v\J{)} \rightsquigarrow e'$ by substitution 
%   \item \Z\Z\Z $\B{case}\ \neg F'\J{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\J{(}F'\ \J{*}p\J{=>}e\J{)(} v \J{)} \rightsquigarrow e[\sigma]$ by definition
%   \item \Z\Z\Z\Z $F\J{(}v\J{)} \rightsquigarrow e[\sigma]$ by substitution 
%   \item \Z\Z\Z $\exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by decidability of $F'\J{($v$)} \rightsquigarrow e'$
%   \item \Z\Z $\forall e' .\ \exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by summarization
%   \item \Z\Z $\exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by independence 

%   \item \Z $\B{case }
%     F = F'\ f 
%     \I
%     \J{*$p$=>$e$} \in F' 
%   $
%   \item \Z\Z $\B{let } e' \B{ s.t. } F'\J{(}v\J{)} \rightsquigarrow e'$ by induction hypothesis
%   \item \Z\Z $F'\ f\J{(}v\J{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z $F\J{(}v\J{)} \rightsquigarrow e'$ by definition
%   \item \Z $\exists e' .\ F\J{(}v\J{)} \rightsquigarrow e'$ by induction on $\J{*$p$=>$e$} \in F$
%   \item $\square$
% \end{theorem}

\begin{theorem}(Model typing assignability)
  \label{theorem:model_typing_assignability}
  \begin{mathpar}
    \inferrule { 
      \delta, \Gamma \satisfies e \hastype \tau
    } {
      \exists \sigma .\ \delta, \sigma \satisfies \Gamma 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem}(Model typing soundness)
  \label{theorem:model_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \delta, \Gamma \satisfies e \hastype \tau
    } {
      \forall \sigma .\ 
      \delta, \sigma \satisfies \Gamma
      \implies
      \VDash e[\sigma]
    } 
  \end{mathpar}
  Proof:
  \item \TODO{redo using universal/implication}
  \item $\B{assume }
        \delta, \sigma \satisfies \Gamma 
        \I \delta, \Gamma \satisfies e \hastype \tau
  $
    \item \Z $\B{case } e = \J{@}$
      \item \Z\Z $\B{let } v \B{ s.t. } \J{@} = v$
      \item \Z\Z $e[\sigma] = v$
      \item \Z\Z $ \VDash e[\sigma]$


    \item \Z $\B{case } 
      \delta, \Gamma \satisfies e' \hastype \tau'
      \I 
      e = \J{<}l\J{>}e' 
      \I 
      \tau = \J{<}l\J{>}\tau'
    $
      \item \Z\Z $\Vdash e'$ by induction hypothesis
      \item \Z\Z $\B{case } e'[\sigma] = v$
        \item \Z\Z\Z $\B{let } v' \B{ s.t. } \J{<}l\J{>}v = v'$
        \item \Z\Z\Z $\J{<}l\J{>}e'[\sigma] = v'$
        \item \Z\Z\Z $(\J{<}l\J{>}e')[\sigma] = v'$
        \item \Z\Z\Z $e[\sigma] = v'$
        \item \Z\Z\Z $\VDash e[\sigma] $

      \item \Z\Z $\B{case } e'[\sigma] \rightsquigarrow e'' \I \VDash e''$
        \item \Z\Z\Z $\J{<}l\J{>}e'[\sigma] \rightsquigarrow \J{<}l\J{>} e''$
        \item \Z\Z\Z $\VDash \J{<}l\J{>}e'' $
        \item \Z\Z\Z $\VDash \J{<}l\J{>}e'[\sigma] $
        \item \Z\Z\Z $\VDash (\J{<}l\J{>}e')[\sigma] $
        \item \Z\Z\Z $\VDash e[\sigma] $

      \item \Z\Z $\VDash e[\sigma] $ by cases on $\VDash e' $

    \item \Z \TODO{remaining introduction cases}

    \item \Z $\B{case } 
      x \hastype \tau \in \Gamma
      \I 
      x \slash v \in \sigma
      \I 
      e = x
    $
      \item \Z\Z $x[\sigma] = v$
      \item \Z\Z $e[\sigma] = v$
      \item \Z\Z $\VDash e[\sigma] $

    \item \Z $\B{case } 
      e[\sigma] \rightsquigarrow e' 
      \I 
      \delta, \Gamma \satisfies e' \hastype \tau
    $ 
      \item \Z\Z $\VDash e'[\sigma] $ by induction hypothesis
      \item \Z\Z $\VDash e[\sigma] $

    \item \Z $\VDash e[\sigma] $ by induction on $\delta, \Gamma \satisfies e \hastype \tau$
  \item $\square$
  \item \TODO{Cretin's corresponding theorem is by definition of pretypes on p. 125}
\end{theorem}

\noindent
\B{NOTE: } The induction hypothesis includes the generalized assumption, e.g. $\forall e' .\ e' < e \implies Q(e')$ if inducting on $e$ or $\forall e' .\ (P(e') \implies P(e)), P(e') \implies Q(e')$ if inducting on predicate $P$

\noindent
\B{NOTE: } we induct on $\delta, \Gamma \satisfies e \hastype \tau$ instead of $e$, as the predicate acts as a guard/ordering in lieu of a decreasing e.
This allows us to use the induction hypothesis on the reduction step result in the elimination case.

\noindent
\B{NOTE: } Kozen says, "Intuitively, one can appeal to the coinductive hypothesis as long as there
has been progress in observing the elements of the stream (guardedness) and there is no
further analysis of the tails (opacity)".  Kozen demonstrates a legal proof by induction on infinite streams too

% \begin{theorem}(Progress of proof typing)
%   \label{theorem:proof_typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       e \B{ progressive}
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}

% \begin{theorem}(Preservation of proof typing)
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%       \\
%       e \rightsquigarrow e'
%     } {
%       \Gamma \entails e' \hastype \tau \given Z  
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}


\begin{definition}\boxed{\delta, \sigma \satisfies \Gamma}
  \label{def:model_typing_environment}
  \begin{mathpar}
    \inferrule { 
    } {
      \delta, \sigma \satisfies \epsilon  
    } 

    \inferrule { 
      \delta, \sigma \satisfies \Gamma 
      \\
      \delta \satisfies v \hastype \tau 
    } {
      \delta, \sigma \ x \slash v \satisfies \Gamma \ x:\tau 
    } 
  \end{mathpar}
\end{definition}


\end{document}