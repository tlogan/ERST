\documentclass[acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage[dvipsnames]{xcolor}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={let, fix, in}
}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
% \newtheorem{proof}{Proof}[section]


\title{Extrinsic Type Inference}
% \author{}
% \date{}

\begin{document}

\newcommand{\Par}[1]{\paragraph{\textbf{#1}}}
\newcommand*{\code}{\fontfamily{pcr}\selectfont}
\newcommand{\J}[1]{\texttt{\small \code #1}}
\newcommand{\lab}[1]{\small \text{\color{Gray}\ [#1]}}
\newcommand{\entails}{\vdash}
\newcommand{\satisfies}{\vDash}
\newcommand{\given}{\dashv}
\newcommand{\with}{\ \diamond\ }
\newcommand{\notfree}{\ \#\ }
\newcommand{\consis}{\ \star}
\newcommand{\safe}{\ \checkmark}
\newcommand{\relational}{\ \Re}

\newcommand{\factorsinto}{\Vvdash}


\newcommand{\allsafe}{\ \Re\checkmark}



\newcommand{\foreign}{\varnothing}
\newcommand{\closed}{\bullet}
\newcommand{\local}{\blacktriangle}
\newcommand{\open}{\circ}



% \newcommand{\tl}{\textasciitilde{}}

\newcommand{\multi}[1]{\widebar{\ #1\ }}
\newcommand{\hastype}{:}
\newcommand{\pattype}{\ \lozenge\ }
\newcommand{\liftfun}{:}
 
\newcommand{\subtypes}{<:}
\newcommand{\supertypes}{:>}
\newcommand{\I}{\hspace{4mm}}
\newcommand{\Z}{.\hspace{4mm}}
\newcommand{\Alpha}{\mathrm{A}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\F}[1]{\text{#1}}
\newcommand{\bigand}{\bigwedge\nolimits}
\newcommand{\bigor}{\bigvee\nolimits}
\newcommand{\C}[1]{\color{teal} \rhd\ \emph{#1}}
\newcommand{\com}[1]{\color{Gray}\I \emph{#1}}
\newcommand{\D}[1]{\small \textsc{#1}}
% \newcommand{\fig}[1]{Fig. {\color{red} \fig{#1}}}
\newcommand{\FIG}[1]{Fig. {\color{red} \ref{#1}}}
\newcommand{\TODO}[1]{\noindent \B{\color{red} TODO: #1}}

\newcommand{\is}{\ ::=\ }
\newcommand{\sep}{\ \ |\ \ }
\newcommand{\nonterm}[1]{#1\ }
\newcommand{\contin}{|\ \ \ \ \ \ \ }
\newcommand{\case}{\B{case }}
\newcommand{\wrt}{\B{wrt }}
% \newcommand{\let}{\B{let }}
% \newcommand{\for}{\B{for }}
     


\newcommand{\tl}{\textasciitilde{}}
\newcommand{\typdiff}{\J{\textbackslash}}

\maketitle


\section{Introduction}
\label{sec:introduction}

Automatically catching errors in programs is a hard enough problem
that many languages require users to provide simple specifications to limit that space of correctness.

In languages such as as Java or ML, programmers must declare each data constructor along with the weakest space it belongs to. 
That is, the data constructors are intrinsically typed.

The clever design of ML allows annotations to be fairly sparse by 
having types specified at constructor declarations and relying on type inference elsewhere.
However, one of the drawbacks of intrinsically typed languages is that they prevent reusing of
constructors in contexts that are weaker than or incomparable to their declared spaces. 
For instance, if a programmer declares data constructors \emph{cons} and \emph{nil} to belong to type list,
and \emph{node} and \emph{empty} to belong to type tree, then it is impossible to construct function
that accepts either a list or a tree, or returns either a list or a tree. The only option would be to define
a new datatype that contains isomorphs of all of the above the data constructors, which would 
likely add overhead to development, compilation, and execution.


For various reasons, which may include the reusability drawbacks just mentioned, 
intrinsically typed languages have lost favor,
and untyped languages, 
such as Javascript and Python, have increased in popularity. 

Untyped languages remove the burden on the programmer to prescribe the weakest space each data constructor belongs to, 
which in turn allows programmers to mix and match data constructors in
various contexts, with the potential for enhancing the reusability and clarity of code.

However, the automatic detection of errors is still important. Python and Javascript have 
evolved over the years to include extrinsic types, whereby the programmer annotates particular uses of
their data constructors with types, rather than the declarations of data constructors.
 
Because extrinsically typed languages do not require users to specify the weakest space each data constructor belongs to,
extrinsically typed languages lack the type inference capabilities of intrinsically typed languages, such as ML. 
A lack of type inference is a significant drawback, since it results in code cluttered with annotations in order
to achieve any safety assurance.

There have some relaxations of intrinsic type systems, allowing for sightly more code reusability.
Refinement types (Pfenning) \cite{} allow reusing data constructors in stronger spaces than their intrinsic types, by
inferring refinement types for particular uses.
Unfortunately, refinements aren't sufficient to handle the full range of data constructor reusability allowed by untyped languages.

In order to achieve a language with a high degree of both code reusability and type inference, 
we introduce a novel type system with extrinsic type inference. 
To avoid hindering the reusability allowed in untyped programming, 
the type system must allow the type of a given data constructor in one context
to be stronger, weaker, or incomparable to the type of 
the same data constructor in a different context. 
Due to the fact that a data constructor can belong to variety of types of varying precision,
the system leverages subtyping to check, construct, and notate types.

As a byproduct of inferring extrinsic types using subtyping, the system also happens to infer the principal types for 
certain kinds of higher-order functions, which was first solved by SuperF \cite{}. 
However, SuperF's programming language and type system is purposefully 
restricted, and it isn't sufficient for the high-degree of code reusability allowed by untyped languages.

The system relies on intersection, union, and type-indexed universal and existential types, and inductive types, in order 
to construct strong types from the observed programs. 
To keep things simple, we restrict the reasoning of infinite types to scalars. In future work, 
but we will extend the system to include inductive relational reasoning. By adding inductive relational
reasoning to the extrinsic type system, one effectively gets an extrinsic alternative to CHC solving \cite{} 
or liquid types \cite{}.


In section \ref{sec:overview}, we give examples of the expressions and types that the system reasons with,
demonstrate a few of the ways the system can reason. 
In section \ref{sec:structure}, we define the forms of expressions, types, and other key objects. 
In section \ref{sec:dynamic_system}, we define the ground truth.
In section \ref{sec:static_system}, we describe the verification and type inference mechanisms.


\section{Overview}
\label{sec:overview}
We designed the type system around a simple applicative language with pattern matching,
since such a language is syntactically related to predicate logic. Likewise,
we designed the language of types to share many similarities with predicate logic. 
To get a feel for the languages and reasoning capabilities, it's best to start by
looking at a few examples.


\Par{Finite Isomorphism.}
A function can be constructed from multiple paths. 
Consider the function $\J{talky}$, which completes a simple English phrase.

\[
  \begin{array}[t]{@{} l}
    \J{let talky = (}
      \\
      \I \J{? <hello> @ => <world> @}
      \\
      \I \J{? <good> @ => <morning> @} 
      \\
      \I \J{? <thank> @ => <you> @} 
      \\
    \J{)}
  \end{array}
\]

Since there is no recursion, the number of paths is finite.
For these simple finite functions, the type system constructs
an isomorphic type without any weakening in precision. 

\[
  \begin{array}[t]{@{} l}
    \J{TOP}
      \\
      \J{\& <hello> @ -> <world> @}
      \\
      \J{\& <good> @ -> <morning> @} 
      \\
      \J{\& <thank> @ -> <you> @} 
  \end{array}
\]

Each path is represented using the implication type,
and the paths are joined together using the intersection type.

\Par{Selection.}
Although the type of function $\J{talky}$ is no weaker than the actual function,
the type syntax avails it to approximate reasoning at application.
Consider an application of the function to a variable argument. 

\[
  \begin{array}[t]{@{} l}
    \J{let x : <hello> @ | <thank> @ = ... in}
    \\
    \J{...}
    \\
    \J{talky(x)} 
    \\
    \J{...}
  \end{array}
\]

If the type system affirms the type annotation,
then it goes on to infer the type of the application. 
\[
  \J{<world> @ | <you> @}
\]

The type system effectively applies application to all possible arguments
and unions the results derived from only the paths of those a arguments. 

\Par{Factorization.}
A function can represent infinite paths by using recursion.
Consider the function $\J{repeat}$, which takes an item and a natural number
as inputs and returns a list of that item repeated the input number of times.

\[
  \begin{array}[t]{@{} l}
      \J{let repeat = ? x => loop(? self =>}
      \\
      \I \J{? <zero> @ => <nil> @}
      \\
      \I \J{? <succ> n => <cons>(x,self(n))}
      \\
      \J{)}
  \end{array}
\]

One possibility for constructing the type of the recursive function would
be to follow the idea from finite paths and construct a type 
that preserves all the paths. If our type system had a greatest fixed point
type constructor, then we could concisely represent such a type with minimal
rewriting.

\[
  \begin{array}[t]{@{} l}
      \J{ALL[T] T -> GFP[R]( TOP} 
      \\
      \I \J{\& <zero> @ -> <nil> @}
      \\
      \I \J{\& (ALL[N L ; R <: N->L] <succ> N -> <cons> T*L)}
      \\
      \J{)} 
  \end{array}
\]

Although the strength of precision of this type would be very beneficial,
reasoning with such a type would be complicated. To keep the type system as
simple as possible for the purpose of extrinsic type inference with a high-degree
of code reusability, we leave such reasoning of inductive and co-inductive types out of
the type system. 

The type system avoids constructing a relational type, and instead, it
constructs a type that is significantly weaker than the actual behavior of the function,
by factoring the paths into an inductive space of inputs and an inductive space of outputs. 

\[
  \begin{array}[t]{@{} l}
      \J{ALL[T] T ->} 
      \\
      \I \J{(LFP[R] <zero> @ | <succ> R)}
      \\
      \I \J{->}
      \\
      \I \J{(LFP[R] <nil> @ | <cons> T*R)}
  \end{array}
\]

This eager approximation enables the type system
to simply reason with inductive scalars and avoids the need for complicated
relational reasoning. In a follow up paper,
we will show how to rectify this limitation by augmenting the type system with
mechanisms for inductive relational reasoning.

\Par{Scalar Unrolling.} 
Since the inputs to functions may have inductive types, the type 
system must be able to check for error at function application by unrolling
inductive types.
Consider applying the $\J{repeat}$ function to some item and the number two, 
which results in the type system checking that two is in fact an instance of the natural numbers.

\[
  \J{ <succ> <succ> <zero> @} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
\]

The type system confirms that two is a valid input by unrolling the inductive type three times.
Unfortunately, because the type system eagerly factored the type of $\J{repeat}$, it
is unable to infer a stronger type than the original list type. This deficiency will
be rectified in the follow up paper, in which we augment the type system with relational reasoning.


\Par{Scalar Induction.} 
Another scenario that may arise is one in which the input to a function has an inductive type.
Consider the application of the function $\J{repeat}$ to a variable whose type represents the even natural numbers.

\[
  \begin{array}[t]{@{} l}
    \J{let x : (LFP[R] <zero> @ | <succ> <succ> R) = ... in}
    \\
    \J{...}
    \\
    \J{repeat(...)(x)} 
    \\
    \J{...}
  \end{array}
\]

The application results in the type system checking that natural numbers are weaker than even numbers. 

\[
  \begin{array}[t]{@{} l}
    \J{LFP[R] <zero> @ | <succ> <succ> R}
    \\
    \subtypes
    \\
    \J{LFP[R] <zero> @ | <succ> R}
  \end{array}
\]


Since even numbers are represented inductively, the type system performs mathematical induction
by assuming the subtyping relation holds for the self reference of the even numbers. 

\[
  \begin{array}[t]{@{} l}
    \J{E} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
    \\
    \entails
    \\
    \J{(<zero> @ | <succ> <succ> E)} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
  \end{array}
\]

In practice, the type system actually substitutes the supertype into
the self reference of the subtype, if the self reference occurs in a positive position of the subtype.

\[
  \begin{array}[t]{@{} l}
    \J{(<zero> @ | <succ> <succ> (LFP[R] <zero> @ | <succ> R))} 
    \\
    \subtypes 
    \\
    \J{(LFP[R] <zero> @ | <succ> R)}
  \end{array}
\]


In effect, by using mathematical induction, the type system ensures that 
every type contained within the type of even natural numbers is also
contained within the type of natural numbers.
In follow up work, we will extend this inductive reasoning to handle inductive relations. 


\Par{Learning.}
The paths of a function are not always syntactically apparent. 
If a variable is applied to arguments, the variable should implicitly behave 
like a function, or else the program is erroneous. 
Consider the higher order function $\J{foo}$ which takes a function as input
and applies it to the number two and the boolean true.

\[
  \J{let foo = ? f => (f(<succ> <succ> <zero> @), f(<true> @))}
\]

Type systems for System F have traditionally struggled to find the best
type for such programs. If restricted to parametric types alone, there are many choices,
without there being a clear best or principal type. 
That is because it's not possible to find a weakest type for the parameter
$\J{f}$ with parametric types alone.
One possibility is that the type system requires that f is a function that wraps its
input in an option. 

\[
  \J{f : ALL[X] X -> <some> X}
\]

One possibility is that the type system requires that f is a function that wraps its
input in an list. 

\[
  \J{f : ALL[X] X -> (LFP[R] <nil> @ | <cons> X*R)}
\]

Both are valid, but neither is weaker than the other. The problem is that parametric
types are insufficient for describing the weakest safe input type.
It was not until SuperF introduced a technique using for solving subtyping constraints
that a principal type could be automatically constructed for functions like $\J{foo}$
The extrinsic type system relies on similar principles of solving subtyping constraints,
and likewise, can construct the weakest safe type for $\J{f}$, and thus the principal type for $\J{foo}$.

\[
  \J{ALL[X Y] (<succ> <succ> <zero> @ -> X) \& (<true> @ -> Y) -> X*Y}
\]


\section{Structure}
\label{sec:structure}
To demonstrate the capabilities of the extrinsic type system, we rely on an applicative
programming language with pattern matching, but without effects.
The design is attempts to keep the forms of expressions and types to relatively 
similar to each other when their semantics are also similar. 
It should not be difficult to modify the techniques presented towards
languages based on conditional branching instead of pattern matching. However,
extension to include effects would be a significant advancement over the current
system.

\begin{definition} Expressions
  \label{def:expressions}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{e} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      x \sep 
      \J{@} \sep
      \vec{r} \sep
      \vec{f} \sep 
      e\J{.}l \sep
      e\J{(}e\J{)} \sep
      \\
      \J{loop(}e\J{)} \sep
      \J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e \sep
      s
    \end{array}
    & \com{expression}
    \\
    \nonterm{\vec{r}} & \is \epsilon \sep \vec{r}\ r 
    & \com{record}
    \\
    \nonterm{r} & \is \J{<}l\J{>}e
    & \com{entry}
    \\
    \nonterm{\vec{f}} & \is \epsilon \sep \vec{f}\ f
    & \com{function}
    \\
    \nonterm{f} & \is \J{?}p\J{=>}e
    & \com{path}
    \\
    \nonterm{s} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      e \J{,} e \sep
      e\ \J{|>}\ e \sep
      \J{if}\ e\ \J{then}\ e\ \J{else}\ e \sep
      \J{let}\ x\ \J{=}\ e\ \J{in}\ e
    \end{array}
    & \com{sugar}
  \end{array}\]
\end{definition}
A program is an expression, which may be composed of variables $x$, unit $\J{@}$,
records $... \J{<}l\J{>} e ...$, functions $...\J{?}p \J{=>} e ...$, record
projection $e\J{.}l$, function application, $e\J{(}e\J{)}$, recursion $\J{loop(}e\J{)}$,
or bindings with type annotations, $\J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e$.
Tags and record entries are distinguished by labels $l$.

Functions are constructed from one or more paths, where paths are distinguished by patterns. 
That is, construction of branches is decoupled from pattern matching, and pattern matching is
subsumed by function application.


A program is an expression 
of the form in definition \ref{def:expressions}. The forms of expressions
enable function abstraction, function application, tagged constructions, record construction, record projection,
and pattern matching. These forms enable us to express non-trivial programs. They also allow
for compositions that have no reasonable semantics.  
Recursion relies on the fixed point combinator $\J{loop}$.
The binding with type annotation allows the programmer to verify expressions against
a custom specification, instead of relying on merely the specification generated by type inference.
The annotation is used in two ways. First, the type system checks that specification is an approximation
of the expression bound to the variable. Second, the type system checks that the approximation,
although possibly weaker than the inferred type, is sufficient for the continuing expression to be error-free. 

\hfill
\begin{definition} 
  \label{def:expression_desugaring}
  Expression Desugaring
  \hfill 
  \boxed{\llbracket s \rrbracket^\square = e}
  \\
  \begin{align*}
      \llbracket e_l \J{,} e_r \rrbracket^\square &= \J{<left>}\ e_l \ \J{<right>}\ e_r
      \\
      \llbracket e_l\ \J{|>}\ e_r \rrbracket^\square &= e_r\J{(}e_l\J{)}
      \\
      \llbracket \J{if}\ e_c\ \J{then}\ e_t\ \J{else}\ e_f \rrbracket^\square &= 
      \begin{array}[t]{@{} l}
        e_c \J{ |> (}
          \\
          \I \J{? <true> @ => } e_t
          \\
          \I \J{? <false> @ => } e_f
          \\
        \J{)}
      \end{array}
      \\
      \llbracket \J{let}\ x\ \J{=}\ e\ \J{in}\ e' \rrbracket^\square &= (\J{?}x \J{=>} e')\J{(}e\J{)}
  \end{align*}

\end{definition} 
\hfill

For convenience, expressions include syntactic sugar for tuples $e\J{,}e$, 
unannotated bindings \hfill \break
$\J{let}\ x\ \J{=}\ e\ \J{in}\ e$,
flowing $e\ \J{|>}\ e$,
and conditional branching $\J{if}\ e\ \J{then}\ e\ \J{else}\ e$.
For any metalanguage statement or term containing sugar $s$, we assume that $s$ is implicitly replaced with $\llbracket s \rrbracket^\square$.

\hfill
\begin{definition} Patterns 
  \label{def:patterns}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{p} & \is 
      x \sep
      \J{@} \sep
      \vec{k}
    & \com{pattern}
    \\
    \nonterm{\vec{k}} & \is \epsilon \sep \vec{k}\ k
    & \com{record}
    \\
    \nonterm{k} & \is \J{<}l\J{>}p
    & \com{entry}
  \end{array}\]
\end{definition}
\hfill

A pattern may be composed of variables, unit, or records. 

\hfill
\begin{definition} Values 
  \label{def:values}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{v} & \is 
      \J{@} \sep
      \vec{g} \sep
      \vec{f}
    & \com{value}
    \\
    \nonterm{\vec{g}} & \is \epsilon \sep \vec{g}\ g
    & \com{record}
    \\
    \nonterm{g} & \is \J{<}l\J{>}v
    & \com{entry}
  \end{array}\]
\end{definition}
\hfill

A value may be composed of unit, records, or functions. 

\hfill
\begin{definition} Types 
  \label{def:types}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \kappa \sep 
      \phi \sep 
      \psi \sep 
      \J{LFP[}\alpha\J{]}\tau \sep
      \tau \typdiff \eta \sep
      \gamma
    \end{array}
    & \com{type}
    \\
    \nonterm{\kappa} & \is 
    \begin{array}[t]{@{}l}
      \J{@} \sep
      \J{<} l \J{>} \tau \sep 
      \tau\J{->}\tau
    \end{array}
    & \com{base}
    \\
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{|}\tau \sep 
      \J{EXI[}\vec{\alpha}\ \Delta \J{]} \tau
    \end{array}
    & \com{expansion}
    \\
    \nonterm{\psi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{\&}\tau \sep 
      \J{ALL[}\vec{\alpha}\ \Delta \J{]} \tau
    \end{array}
    & \com{refinement}
    \\
    \nonterm{\eta} & \is 
    \begin{array}[t]{@{}l}
      \J{EXI[}\vec{\alpha}\ \Delta \J{]} \rho \sep 
      \rho
    \end{array}
    & \com{subtracted}
    \\
    \nonterm{\rho} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \J{<}l\J{>}\rho \sep 
      \rho\J{\&}\rho
    \end{array}
    & \com{pattern}
    \\
    \nonterm{\gamma} & \is 
    \begin{array}[t]{@{}l}
      \J{TOP} \sep \J{BOT} \sep 
      \tau \J{*} \tau 
    \end{array}
    & \com{sugar}
  \end{array}\]
\end{definition}
\hfill

Types provide the representation for approximate specification.
To accommodate a high degree of data constructor reusability,
it is important that the form of types accommodates a wide range of precision.
To manage the complexity of the various forms, we subdivide the type forms
according to some themes.
A type may composed of variables $\alpha$, 
bases $\kappa$, expansions $\phi$, refinements $\psi$,
least fixed point $\J{LFP[}\alpha \J{]} \tau$,
differences $\tau \typdiff \eta$, and sugar $\gamma$ 
There is a variable type $\alpha$, whose internal structure is not important.
A base type reflects the structure of its inhabitants and may be composed of unit $\J{@}$, 
entries $\J{<}l\J{>}\tau$, and paths $\tau \J{->} \tau$.

\TODO{expansion type}


\hfill
\begin{definition} 
  \label{def:type_desugaring}
  Type Desugaring 
  \hfill 
  \boxed{\llbracket \gamma \rrbracket^\square = \tau}
  \\
  \begin{align*}
    \llbracket \J{TOP} \rrbracket^\square &= \J{EXI[} \alpha \J{]} \alpha
    \\
    \llbracket \J{BOT} \rrbracket^\square &= \J{ALL[} \alpha \J{]} \alpha
    \\
    \llbracket \tau_l \J{*} \tau_r \rrbracket^\square &= (\J{<left>}\ \tau_l)  \J{\&} (\J{<right>}\ \tau_r)
  \end{align*}
\end{definition} 
\hfill

For each statement over a sugar type $\gamma$, we assume that $\gamma$ is implicitly replaced with $\text{desugar}(\gamma)$.


\TODO{mention somwhere that the second order quantification serves two distinct purposes; 1. polymorphism as in System-F. 2. refinement as in first-order quantification of liquid types.
Relational types is able to leverage second-order quantification for refinement, eschewing the first-order quantification used in other systems.
}

The system leverages types of the forms in Definition \ref{def:types}, 
which allow expressing properties of expressions with varying levels of precisions. 

\begin{definition} Ancillaries 
  \label{def:type_ancillaries}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\vec{\alpha}} & \is \epsilon \sep \vec{\alpha}\ \alpha 
    & \com{type var seq}
    \\
    \nonterm{\Delta} & \is \epsilon \sep \Delta \J{;} \tau \J{<:} \tau
    & \com{subtyping environ}
    \\
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ x \hastype \tau
    & \com{typing environ}
    \\
    \nonterm{\Omega} & \is \vec{\alpha},\Delta 
    & \com{world}
  \end{array}\]
\end{definition}


\section{Dynamic System}
\label{sec:dynamic_system}

The programming language is pure and applicative. 


\begin{definition}
  \label{def:progression}
  Progression
  \hfill 
  \boxed{e \rightsquigarrow e}
  \\
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \vec{r}\J{<}l\J{>}e \rightsquigarrow \vec{r}\J{<}l\J{>}e'
    }

    \inferrule {
      \vec{r} \rightsquigarrow \vec{r}'
    } {
      \vec{r} \J{<}l \J{>} v \rightsquigarrow \vec{r}' \J{<} l \J{>} v
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      e\J{.}l \rightsquigarrow e'\J{.}l
    }

    \inferrule {
      \J{?}l\J{=>}v \in \vec{g}
      \\
      \forall\ e .\ \J{?}l\J{=>}e \in \vec{g} \implies e = v
    } {
      \vec{g}\J{.}l \rightsquigarrow v
    }

    \inferrule {
      e_f \rightsquigarrow e_f'
    } {
      e_f\J{(}e\J{)} \rightsquigarrow e_f'\J{(}e\J{)}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \vec{f}\J{(}e\J{)} \rightsquigarrow \vec{f}\J{(}e'\J{)}
    }

    \inferrule {
      \vec{f}\J{(}v\J{)} \rightsquigarrow e'
      \\
      \text{FV}(e) \subseteq \text{FV}(p)
    } {
      (\vec{f}\J{?}p\J{=>}e)\J{(}v\J{)} \rightsquigarrow e' 
    }

    \inferrule {
      \exists e' .\ \vec{f}\J{(}v\J{)} \rightsquigarrow e'
      \\
      p \equiv v \given \vec{\sigma} 
    } {
      (\vec{f}\J{?}p\J{=>}e)\J{(}v\J{)} \rightsquigarrow e[\vec{\sigma}]
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \J{loop(}e\J{)} \rightsquigarrow \J{loop(}e'\J{)}
    }

    \inferrule {
    } {
      \J{loop(?}x\J{=>}e\J{)} \rightsquigarrow e[x \slash \J{loop(?}x\J{=>}e\J{)}]
    }
  \end{mathpar}
\end{definition}

\emph{Progression} of an expression, as in definition \ref{def:progression},
is a small-step operational semantics. 
It adheres to typical definitions of applicative languages for the most part. One 
slight departure is that pattern matching is merely a special case of function application. 
Likewise, a switch is merely a function abstraction.
Records are similar to Functions, except that their entries are guarded by literal identifiers. 
Additionally, records may be abstracted as patterns, but functions may not.
The semantics enables recursion via the fixed point combinator \J{loop}.


\hfill
\begin{definition}
  \label{def:model_typing}
  Model Typing
  \hfill
  \boxed{\vec{\delta} \satisfies e \hastype \tau}
  \\
  \begin{mathpar}
    \inferrule { 
      \alpha \slash \tau \in \vec{\delta}
      \\
      \vec{\delta} \satisfies e \hastype \tau
    } {
      \vec{\delta} \satisfies e \hastype \alpha 
    } 

    \inferrule { 
      \alpha \slash \tau \notin \vec{\delta}
      \\
      \vec{\delta} \satisfies e \hastype \J{TOP} 
    } {
      \vec{\delta} \satisfies e \hastype \alpha 
    } 

    \inferrule { 
    } {
      \vec{\delta} \satisfies \J{@} \hastype \J{@}
    } 

    \inferrule { 
      \J{<}l \J{>} v \in \vec{g}
      \\
      \vec{\delta} \satisfies v \hastype \tau 
      \\
      \forall v' .\ \J{<} l \J{>} v' \in \vec{g} \implies v' = v
    } {
      \vec{\delta} \satisfies \vec{g} \hastype \J{<} l \J{>} \tau
    } 

    \inferrule { 
      \vec{\delta} \satisfies \vec{f} \hastype \tau_l \J{->} \tau_r
    } {
      \vec{\delta} \satisfies \vec{f} \J{?}p \J{=>} e \hastype \tau_l \J{->} \tau_r
    } 

    \inferrule { 
      \forall \vec{\sigma}.\ 
      \vec{\delta} \satisfies p[\vec{\sigma}] \hastype \tau_l
      \implies
      \vec{\delta}  \satisfies e[\vec{\sigma}] \hastype \tau_r
      \\\\
      \forall \tau_l'\ \tau_r'.\ 
      \vec{\delta} \satisfies \vec{f} \hastype \tau_l' \J{->} \tau_r'
      \implies
      \vec{\delta} \satisfies \tau_l \subtypes \tau_l'
      \implies
      \vec{\delta} \satisfies \tau_r' \subtypes \tau_r
    } {
      \vec{\delta} \satisfies \vec{f} \J{?}p \J{=>} e \hastype \tau_l \J{->} \tau_r
    }

    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l
      \\
      \neg\ (\vec{\delta} \satisfies e \hastype \tau_r)
    } {
      \vec{\delta} \satisfies e \hastype \tau_l \typdiff \tau_r
    } 

    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l
      \\
      \vec{\delta} \satisfies e \hastype \tau_r
    } {
      \vec{\delta} \satisfies e \hastype \tau_l \J{\&} \tau_r
    } 

    \inferrule { 
      \forall \vec{\delta}' .\ \vec{\delta} \cup \vec{\delta}' \satisfies \Delta \implies 
      \vec{\delta} \cup \vec{\delta}', \vec{\sigma} \satisfies e \hastype \tau
    } {
      \vec{\delta}, \vec{\sigma} \satisfies e \hastype \J{ALL[}\vec{\alpha}\ \Delta \J{]} \tau
    } 

    \inferrule { 
      \vec{\delta} \ \alpha \slash \J{LFP[}\alpha \J{]} \tau \satisfies e \hastype \tau
    } {
      \vec{\delta} \satisfies e \hastype \J{LFP[} \alpha \J{]} \tau
    } 

    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l
    } {
      \vec{\delta} \satisfies e \hastype \tau_l \J{|} \tau_r
    } 

    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_r
    } {
      \vec{\delta} \satisfies e \hastype \tau_l \J{|} \tau_r
    } 

    \inferrule { 
      \vec{\delta} \cup \vec{\delta}' \satisfies \Delta 
      \\
      \vec{\delta} \cup \vec{\delta}' \satisfies e \hastype \tau
    } {
      \vec{\delta} \satisfies e \hastype \J{EXI[}\vec{\alpha}\ \Delta\J{]}\tau
    } 

    \inferrule { 
      e \rightsquigarrow e'
      \\
      \vec{\delta} \satisfies e' \hastype \tau 
    } {
      \vec{\delta} \satisfies e \hastype \tau 
    } 
  \end{mathpar}
\end{definition}
\hfill

\TODO{introduce model typing and soundness properties}
Model typing describes how the various forms of types are introduced based
on the various forms of expressions. There are no rules for elimination 
of type forms. Rather, the progression of expressions is leveraged to eliminate
expression forms, from which further type forms may be introduced.
The indirection into progression is not practical, but it guides the construction
of a sound type system that can directly prove the validity of typings and subtypings 
by eliminating type forms.


\hfill
\begin{definition}
  \label{def:model_subtyping}
  Model Subtyping
  \hfill
  \boxed{\vec{\delta} \satisfies \tau <: \tau}
  \\
  \begin{mathpar}
    \inferrule { 
      \forall e .\ 
      \vec{\delta} \satisfies e \hastype \tau_l \implies 
      \vec{\delta} \satisfies e \hastype \tau_r 
    } {
      \vec{\delta} \satisfies \tau_l <: \tau_r
    } 
  \end{mathpar}
\end{definition}


\begin{definition}
  \label{def:model_sequence_subtyping}
  Model Sequence Subtyping
  \hfill
  \boxed{\vec{\delta} \satisfies \Delta}
  \\
  \begin{mathpar}
    \inferrule { 
    } {
      \vec{\delta} \satisfies \epsilon 
    } 

    \inferrule { 
      \vec{\delta} \satisfies \Delta 
      \\
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    } {
      \vec{\delta} \satisfies \Delta \J{;} \tau_l \J{<:} \tau_r
    } 
  \end{mathpar}
\end{definition}



\section{Static System}
\label{sec:static_system}
The static semantics is a system for checking if the construction of an expression is viable.   

\hfill
\begin{definition} 
  \label{def:proof_typing}
  Proof Typing
  \hfill 
  \boxed{\Gamma \entails e \hastype \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Gamma \entails \J{@} \hastype \J{@} \given \Omega 
    }

    \inferrule {
      x:\tau \in \Gamma
    } {
      \Gamma \entails x \hastype \tau \given \Omega 
    }

    % \inferrule {
    %   \Gamma \entails e \hastype \tau \given \Omega 
    % } {
    %   \Gamma \entails \J{<}l\J{>}e \hastype \J{<}l\J{>}\tau \given \Omega 
    % }

    \inferrule {
      \vec{r} = \epsilon
    } {
      \Gamma \entails \vec{r} \hastype \J{TOP} \given \Omega
    }

    \inferrule {
      \Gamma \entails \vec{r} \hastype \tau \given \Omega 
      \\\\
      \Omega \preceq \Omega'
      \\
      \Gamma \entails e \hastype \tau' \given \Omega' 
    } {
      \Gamma \entails \vec{r} \J{<}l \J{>} e \hastype (\tau\ \J{\&}\ \J{<} l \J{>} \tau') \given \Omega' 
    }

    \inferrule {
      \exists \vec{\eta}.\ \vec{\alpha}, \Delta, \Gamma \entails \vec{f} \liftfun \vec{\pi} \sim \vec{\eta} 
      \\\\
      \text{pack}^+(\text{FTV}(\Gamma)\ \vec{\alpha} \entails \vec{\pi}) = \tau 
    } {
      \Gamma \entails \vec{f} \hastype \tau \given \vec{\alpha}, \Delta
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given \Omega 
      \\\\
      \Omega \preceq \Omega'
      \\
      \tau \subtypes  \J{<} l \J{>} \alpha \given \Omega' 
    } {
      \Gamma \entails e\J{.}l \hastype \alpha \given \Omega'
    }

    \inferrule {
      \Gamma \entails e_f \hastype \tau_f \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \Gamma \entails e_a \hastype \tau_a \given \Omega' 
      \\\\
      \Omega' \preceq \Omega''
      \\
      \tau_f \subtypes \tau_a\J{->}\alpha \given \Omega'' 
    } {
      \Gamma \entails e_f\J{(}e_a \J{)} \hastype \alpha \given \Omega''
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau \subtypes \tau_a \given \Omega' 
      \\\\
      \Omega' \preceq \Omega''
      \\
      \Gamma\ x:\tau_a \entails e' \hastype \tau' \given \Omega''
    } {
      \Gamma \entails \J{let}\ x \J{:} \tau_a\ \J{=}\ e\ \J{in}\ e' \hastype \tau' \given \Omega'' 
    }

    \inferrule {
      \Gamma \entails e \hastype \alpha_\nu\J{->}\tau \given  \vec{\alpha}, \Delta 
      \\\\
      \forall \vec{\alpha}'\ \Delta' .\ 
        \vec{\alpha}', \llbracket \epsilon, \vec{\alpha}\ \vec{\alpha}' \entails \Delta', \alpha_l \J{->} \alpha_r \rrbracket^+ \in \vec{\pi}_\nu
      \implies
      \tau \subtypes \alpha_l\J{->}\alpha_r \given  \vec{\alpha}\ \vec{\alpha}', \Delta\ \Delta' 
      \\\\
      \exists \pi.\ \pi \in \vec{\pi}_\nu
      \\
      \alpha_\nu \downarrow \vec{\pi}_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \vec{\pi}_\mu
      \\
      \text{pack}^-(\text{FTV}(\Gamma)\ \vec{\alpha}\ \alpha_\mu \entails \vec{\pi}_\mu) = \tau_\mu
      \\\\
      \exists \alpha .\ \alpha \J{*} \J{BOT} \subtypes \J{LFP[} \alpha_\mu \J{]}\tau_\mu \factorsinto \alpha \subtypes \tau_l 
      \\
      \exists \alpha .\ \J{BOT} \J{*} \alpha  \subtypes \J{LFP[} \alpha_\mu \J{]}\tau_\mu \factorsinto \alpha \subtypes \tau_l 
    } {
      \Gamma \entails \J{loop(}e\J{)} 
      \hastype 
      \tau_l \J{->} \tau_r
      \given \vec{\alpha}, \Delta 
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{explain the advantage of using the least fixed point type over the greatest fixed point type.
By rewriting a function type in terms of the least fixed point type,
instead of the greatest fixed point type around the implication type,
the subtyping solver can avoid infinitely unrolling the GFP in an attempt to construct
the least fixed point return type. 
}

\emph{Proof typing}, def. \ref{def:proof_typing}, checks the viability of an expression's
form. Additionally, by extending the forms of expressions with type annotations, 
as in Definition \ref{def:sugared_expressions},
proof typing is also able to check that expressions meet abstract specifications.
In order to check the viability of constructions and specifications, 
proof typing lifts expressions into types and leverages subtyping to 
check compatibility between types. 
The proof typing predicate represents a typing that holds under the assumptions
of a typing environment, and a world, 
which consists of emph{closed} type variables and subtyping constraints. 

Whether a variable is a closed or not represents how a variable is quantified.

If proof typing holds, then its typing holds under every interpretation of its closed type variables
under some interpretation of its open variables.
We formalize ths soundness claim in Section \ref{sect:correctness}. 

The proof typing predicate, $\Gamma \entails e \hastype \tau \given \Omega'$, can 
be interpreted as an algorithm that takes a typing environment $\Gamma$, an expression $e$,
and a world $\Omega$ as inputs and returns a type and a world $\Omega'$ as outputs,
such that the output world is an extension of the input world $(\Omega \preceq \Omega')$.
The input world is not explicitly represented in the predicate, so the algorithm
interprets the input world as the smallest world that can satisfy the predicate. 
Additionally, the outputs of the predicate are not deterministic. Therefore, the algorithm
enumerates all possible outputs.


% The proof typing predicate, $\Omega, \Gamma \entails e \hastype \tau \with \Omega'$, can 
% be interpreted as an algorithm that takes a world $\Omega$, a typing environment $\Gamma$, and an expression $e$,
% as inputs and returns a type $\tau$ and a world $\Omega'$ as outputs,
% such that the output world is an extension of the input world $(\Omega \preceq \Omega')$.
% Additionally, the outputs of the predicate are not deterministic. Therefore, the algorithm
% enumerates all possible outputs.

\paragraph{Rule \ref{def:proof_typing}.1}
For unit, \J{@}, proof typing simply returns the singleton type of the same
form. 

\paragraph{Rule \ref{def:proof_typing}.2}
For a variable, $x$, proof typing looks
for a corresponding typing in the environment, and returns the 
corresponding type if found.

\paragraph{Rule \ref{def:proof_typing}.3}
For a tagged expression, $\J{<}l\J{>}e$, proof typing recursively 
constructs the type of the tag's body,
and returns the corresponding tag type.

\paragraph{Rule \ref{def:proof_typing}.4}
For an empty record, proof typing constructs the top type \J{TOP},
which is merely syntactic sugar for $\J{EXI[}\alpha\J{]}\alpha$.

\paragraph{Rule \ref{def:proof_typing}.5}
For a non empty record, $\vec{r}\J{?}l\J{=>}e$, proof typing 
recursively constructs the type for each entry, and
refines their types against each other via intersection.

\paragraph{Rule \ref{def:proof_typing}.6}
For a function, $\vec{f}$, proof typing 
delegates the work to two helper predicates: \emph{function lifting}, as in definition \ref{def:function_lifting}, and
\emph{constrained implication congruence}, as in definition \ref{def:constrained_implication_congruence}.
Function lifting constructs a sequence of implication types, where each associated with a world, represented by $\vec{\pi}$.
Constrained implication congruence, constructs a sequence of types congruent with each implication,
such that each world is packaged with its corresponding type, resulting in a universally constrained type 
(if there are type variables in the original implication). 
During an application, each path of a function is tried in order, which means values matching subsequent
patterns, will not be matched by earlier patterns. Thus, function lifting generates types from patterns,
and for each pattern, it subtracts the types of previous patterns,
represented by prefixes of $\vec{eta}$

\paragraph{Rule \ref{def:proof_typing}.7}
For a projection, $e\J{.}l$, proof typing
leverages subtyping to check that there is an entry with label $l$ 
in the supposed record $e$, and it learns a lower bound 
on the type of the body $\alpha$ associated with that label.


\paragraph{Rule \ref{def:proof_typing}.8}
For an application, $e_f\J{(}e_a\J{)}$, proof typing
leverages subtyping to check that that the function $e_f$ can actually
map the argument $e_a$ to a result. It learns a lower bound 
on the type of the result $\alpha$ associated with that argument.


\paragraph{Rule \ref{def:proof_typing}.9}
For a recursive expression, $\J{loop(}e{)}$, proof typing
constructionsa complex type containing an implication constrained
by a least fixed point type.  
First, it ensures that argument of the fixpoint combinator $e$ is indeed a 
singe path function. Then, by leveraging subtyping, 
it finds a lower bound for every path in the body of $e$,
represented by a sequence of worlds $\vec{\Omega}$, 
all associated with a variable implication, $\alpha_l\J{->}\alpha_r$.
Using all these worlds, it delegates to \emph{fixpoint duality}, as in definition \ref{def:fixpoint_duality},
it order to construct the cases of a relational least fixpoint type, 
representing the dual of the greatest fixpoint of implication under intersected over its worlds.
Finally, it reconstructs a type for a function, by wrapping the relational type in an existential constraint,
and wrapping a generalized implication around that. 

For an annotated definition, $\J{let}\ x \J{:} \tau_a\ \J{=}\ e\ \J{in}\ e'$, 
proof typing checks the definition's source $e$ against the annotation $\tau_a$,
and adds the annotation to the typing environment when checking the contintuation $e'$.

\hfill
\begin{definition} 
  \label{def:world_containment}
  World Containment 
  \hfill
  \boxed{\Omega \preceq \Omega}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      (\vec{\alpha},\Delta)  \preceq (\vec{\alpha}\ \vec{\alpha}',\Delta\ \Delta') 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:function_lifting}
  Function Lifting
  \hfill
  \boxed{\vec{\alpha}, \Delta, \Gamma \entails \vec{f} \liftfun \vec{\pi} \sim \vec{\eta}}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \vec{\alpha}, \Delta, \Gamma \entails \epsilon \liftfun \epsilon \sim \epsilon 
    }

    \inferrule {
      \vec{\alpha}, \Delta, \Gamma \entails \vec{f} \liftfun \vec{\pi} \sim \vec{\eta} 
      \\
      p \hastype \rho \given \Gamma'
      \\
      \text{diff}(\rho, \vec{\eta}) = \tau_l
      \\\\
      \forall \vec{\alpha}'\ \Delta'\ \tau_r .\ 
      \vec{\alpha}', \llbracket \epsilon, \vec{\alpha}\ \vec{\alpha}' \entails \Delta', \tau_l \J{->} \tau_r \rrbracket^+ \in \vec{\pi}'
      \implies
      \Gamma\ \Gamma' \entails e \hastype \tau_r \given \vec{\alpha}\ \vec{\alpha}', \Delta\ \Delta' 
      \\\\
      \exists \pi .\ \pi \in \vec{\pi}' 
      \\
      \text{close}(\rho) = \eta
    } {
      \vec{\alpha}, \Delta, \Gamma \entails \vec{f}\ \J{?}p\J{=>}e \liftfun 
      \vec{\pi}\ \vec{\pi}' \sim \vec{\eta}\ \eta
    }
  \end{mathpar}
\end{definition}

\begin{definition} 
  \label{def:fixed_point_duality}
  Fixed Point Duality 
  \hfill
  \boxed{\alpha \downarrow \vec{\pi} \fallingdotseq \alpha \uparrow \vec{\pi}}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_{\nu} \downarrow \epsilon
      \fallingdotseq 
      \alpha_{\mu} \uparrow \epsilon 
    }

    \inferrule {
      \alpha_{\nu} \downarrow \vec{\pi}_\nu
      \fallingdotseq 
      \alpha_{\mu} \uparrow \vec{\pi}_\mu
      % \\\\
      % \llbracket \Delta_\nu, \alpha_l \rrbracket^- = (\Delta', \tau_l)
      % \\
      % \llbracket \Delta', \alpha_r \rrbracket^+ = (\Delta'', \tau_r)
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \vec{\alpha}_f \entails 
      \alpha_{\nu} \downarrow \vec{\pi}_\nu\ \left< \vec{\alpha}_c,\Delta_\nu, \tau_l \J{->} \tau_r \right> 
      \fallingdotseq 
      \alpha_{\mu} \uparrow \vec{\pi}_\mu\ \left< \vec{\alpha}_c,\Delta_\mu, \tau_l' \J{*} \tau_r' \right>
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{Note the reason for excluding rigids and closeds from quantification is a way to improve precision, but not necessary for soundness. (Right?). Need to conjure up an example to support this idea.}

\TODO{soundness idea: $ 
\\ \forall f\ e_l\ e_r\ \alpha_l\ \alpha_r\ \vec{\alpha}\ \Delta\ \vec{\alpha}'\ \Delta'\ \vec{\Omega},  
\\ ... \implies
\\ f(e_1) = e_2 \implies \left< \vec{\alpha}', \Delta' \right> \in \vec{\Omega} \implies 
\\ (
\Gamma, ... \satisfies f : \alpha_l \J{->} \alpha_r 
\iff 
\Gamma, ... \satisfies (e_l,e_r) : \alpha_l \J{*} \alpha_r
)$ 
}


\hfill
\begin{definition}
  \label{def:pair_duality}
  Fixed Point Constraint Duality 
  \hfill
  \boxed{\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon 
    }

    \inferrule {
      \alpha_\nu \notin \text{FTV}(\tau_l)
      \\
      \alpha_\nu \notin \text{FTV}(\tau_r)
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_\nu \downarrow \Delta_\nu \J{;} \tau_l \J{<:} \tau_r 
      \fallingdotseq 
      \alpha_\mu \uparrow \Delta_\mu \J{;} \tau_l \J{<:} \tau_r
    }

    \inferrule {
    } {
      \alpha_\nu \downarrow \Delta_\nu \J{;} \alpha_\nu \J{<:} \alpha_l \J{->} \alpha_r
      \fallingdotseq 
      \alpha_\mu \uparrow \Delta_\mu \J{;} \alpha_l \J{*} \alpha_r \J{<:} \alpha_\mu 
    }
  \end{mathpar}
\end{definition}
\hfill

% \hfill
% \begin{definition}\boxed{\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_l, \Delta_r}\ Fixed Point Constraint Extraction 
% \label{def:pair_duality}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon, \epsilon
%     }

%     \inferrule {
%       \alpha_\nu \notin \text{FTV}(\tau_l)
%       \\
%       \alpha_\nu \notin \text{FTV}(\tau_r)
%       \\
%       \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_l, \Delta_r
%     } {
%       \alpha_\nu \downarrow \Delta_\nu\ (\tau_l <: \tau_r) \fallingdotseq \alpha_\mu \uparrow \Delta_l\ (\tau_l <: \tau_r), \Delta_r\ (\tau_l <: \tau_r)
%     }

%     \inferrule {
%     } {
%       \alpha_\nu \downarrow \Delta_\nu\ (\alpha_\nu <: \alpha_l \J{->} \alpha_r) \fallingdotseq \alpha_\mu \uparrow 
%       \Delta_l\ (\alpha_l <: \alpha_\mu)
%       , 
%       \Delta_r\ (\alpha_r <: \alpha_\mu)
%     }
%   \end{mathpar}
% \end{definition}
% \hfill









\emph{Proof subtyping}, as in definition \ref{def:proof_subtyping},
checks the viability of one type subtyping another type, under the assumption
of subtyping constraints.

The predicate, $\tau_l \subtypes \tau_r \given \Omega'$, can be interpreted as an algorithm
that takes the types and an implicit world $\Omega$ as inputs and return
a world $\Omega'$, where the output world extends the input world $(\Omega \preceq \Omega')$
and the input world is the smallest world necessary for the proposition to hold.  

% The predicate, $\Omega \entails \tau_l \subtypes \tau_r \with \Omega'$, can be interpreted as an algorithm
% that takes the world $\Omega$, and two types as inputs, and returns
% a world $\Omega'$, where the output world extends the input world $(\Omega \preceq \Omega')$.

The order of the rules 
is critical to ensure that easier constraints are generated. To that end, cases that
strengthen the assumed type (left of subtyping) or weaken the guaranteed type (right of subtyping) occur before rules that
weaken the assumed type or strengthen the guaranteed type.

Due to the complexity of types along with two positions for types to occur in subtyping,
there are many rules needed to define the proof system of subtyping. For clarity,
we show only a subset of the rules in this section in order to explain the essence of the system.
We leave the remaining rules in the appendix, section \ref{sect:appendix}, definition \ref{def:continued_proof_subtyping}. 
The remaining rules include duals and other forms that adhere to similar proof strategies as the rules shown here,
as well as additional rules for increased precision.  


\hfill
\begin{definition} 
  \label{def:proof_subtyping_reflection}
  Proof Subtyping (Reflection)
  \hfill
  \boxed{\tau_l \subtypes \tau_r \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \tau \subtypes \tau \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

For reflexive subtyping, up to alpha renaming, $\tau \subtypes \tau$, 
proof subtyping simply holds without any updates to the world.


\hfill
\begin{definition} 
  \label{def:proof_subtyping_basic_preservation}
  Proof Subtyping (Base Preservation)
  \hfill
  \boxed{\kappa_l \subtypes \kappa_r \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l \subtypes \tau_r
      \given \Omega 
    } {
      \J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r
      \given \Omega 
    }

    \inferrule {
      \tau_{rl} \subtypes \tau_{ll} \given \Omega
      \\
      \Omega \preceq \Omega'
      \\
      \tau_{lr} \subtypes \tau_{rr} \given \Omega' 
    } {
      \tau_{ll} \J{->} \tau_{lr} 
      \subtypes 
      \tau_{rl} \J{->} \tau_{rr}
      \given \Omega' 
    }
  \end{mathpar}
\end{definition}
\hfill

For subtyping tagged types, $\J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r$, 
proof subtyping simply checks that the labels match and subtyping holds
for their contents.


For subtyping record types, $l \J{->} \tau_l \subtypes l \J{->} \tau_r \given \Omega$
proof subtyping simply checks that the labels match and subtyping holds
for their contents.

For subtyping implication types, $\tau_{ll} \J{->} \tau_{lr} \subtypes \tau_{rl} \J{->} \tau_{rr}$
proof subtyping simply checks that the space between types of the upper bound
contains the space between types of the lower bound.


\hfill
\begin{definition} 
  \label{def:proof_subtyping_implication_rewriting}
  Proof Subtyping (Implication Rewriting)
  \hfill
  \boxed{\tau \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l \subtypes
      (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r)
      \given \Omega
    } {
      \tau_l \subtypes 
      (\tau_a\J{|}\tau_b)\J{->}\tau_r
      \given \Omega 
    }


    \inferrule {
      \tau_l
      \subtypes
      (\tau_r\J{->}\tau_a)
      \J{\&}
      (\tau_r\J{->}\tau_b)
      \given \Omega 
    } {
      \tau_l \subtypes 
      \tau_r\J{->}(\tau_{a}\J{\&}\tau_{b})
      \given \Omega
    }

    \inferrule {
      \tau
      \subtypes
      (\J{<} l \J{>} \tau_a)
      \J{\&}
      (\J{<} l \J{>} \tau_b)
      \given \Omega 
    } {
      \tau \subtypes 
      \J{<} l \J{>} (\tau_{a}\J{\&}\tau_{b})
      \given \Omega
    }

  \end{mathpar}
\end{definition}
\hfill

\TODO{NOTE how this rewriting turns the type inside out; going from implication on the outside to refinement/abstraction on the outside}

\TODO{Note how this is the opposite direction from the loop type consturction, which puts the implication on the outside and the fixed point on the inside,
in order to prevent infinite unrolling in the subtyping solver}

\TODO{Note how these correspond to disjunction elimination and conjunction introduction in traditional proofs}

\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_elimination}
  Proof Subtyping (Expansion Elim)
  \hfill
  \boxed{\phi \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_{ll} \subtypes \tau_r
      \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau_{lr} \subtypes \tau_r
      \given \Omega' 
    } {
      \tau_{ll}\J{|}\tau_{lr} \subtypes \tau_r
      \given \Omega' 
    }
    \\
    \inferrule {
      \vec{\alpha}_l \notfree \tau_r
      \\
      \Delta_l \given \vec{\alpha}, \Delta
      \\
      (\vec{\alpha}\ \vec{\alpha}_l, \Delta) \preceq \Omega 
      \\
      \tau_l \subtypes \tau_r \given \Omega 
      \\\\
      \forall \Omega' .\ (\vec{\alpha}\ \vec{\alpha}_l, \Delta) \preceq \Omega' \implies \tau_l \subtypes \tau_r \given \Omega' \implies \Omega' = \Omega
    } {
      \J{EXI[}\vec{\alpha}_l\ \Delta_l \J{]}\tau_l \subtypes \tau_r
      \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:proof_subtyping_refinement_introduction}
  Proof Subtyping (Refinement Intro)
  \hfill
  \boxed{\tau \subtypes \psi \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_{l} \subtypes \tau_{rl} \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau_{l} \subtypes \tau_{rr} \given \Omega' 
    } {
      \tau_l \subtypes \tau_{rl}\J{\&}\tau_{rr} \given \Omega '
    }
    \\
    \inferrule {
      \vec{\alpha}_r \notfree \tau_l
      \\
      \Delta_r \given \vec{\alpha}, \Delta
      \\
      (\vec{\alpha}\ \vec{\alpha}_r, \Delta) \preceq \Omega 
      \\
      \tau_l \subtypes \tau_r \given \Omega 
      \\\\
      \forall \Omega' .\ (\vec{\alpha}\ \vec{\alpha}_r, \Delta) \preceq \Omega' \implies \tau_l \subtypes \tau_r \given \Omega' \implies \Omega' = \Omega
    } {
      \tau_l \subtypes \J{ALL[}\vec{\alpha}_r\ \Delta_r \J{]}\tau_r \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:proof_subtyping_variable_elimination}
  Proof Subtyping (Variable Elim)
  \hfill
  \boxed{\alpha \subtypes \tau \given \Omega} 
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \psi.\ \tau = \psi
      \\
      (\vec{\alpha}_\closed, \Delta\ \Delta_\closed) \preceq (\vec{\alpha}_\closed', \Delta')
      \\ 
      \alpha_\open \notin \vec{\alpha}_\closed
      \\\\
      \text{split}^-(\Delta[\alpha_\open\slash\tau]^{+} \backslash \Delta) = (\Delta_\closed, \Delta_\open)
      \\
      \Delta_\open \given \vec{\alpha}_\closed', \Delta'
    } {
      \alpha_\open \subtypes \tau \given (\vec{\alpha}_\closed', \Delta' \J{;} \alpha\J{<:}\tau) 
    }

    \inferrule {
      \nexists \psi.\ \tau_r = \psi
      \\
      \alpha_\closed \in \vec{\alpha}_\closed 
      \\
      \nexists \alpha.\ \tau_r = \alpha 
      \\\\
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau_r \safe
    } {
      \alpha_\closed \subtypes \tau_r
      \given (\vec{\alpha}_\closed, \Delta)
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_variable_introduction}
  Proof Subtyping (Variable Intro)
  \hfill
  \boxed{\tau \subtypes \alpha \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \phi.\ \tau = \phi
      \\
      (\vec{\alpha}_\closed, \Delta\ \Delta_\closed) \preceq (\vec{\alpha}_\closed', \Delta')
      \\ 
      \alpha_\open \notin \vec{\alpha}_\closed
      \\\\
      \text{split}^+(\Delta[\alpha_\open\slash\tau]^{-} \backslash \Delta) = (\Delta_\closed, \Delta_\open)
      \\
      \Delta_\open \given \vec{\alpha}_\closed', \Delta'
    } {
      \tau \subtypes \alpha_\open \given (\vec{\alpha}_\closed', \Delta' \J{;} \tau\J{<:}\alpha_\open) 
    }

    \inferrule {
      \nexists \phi.\ \tau_l = \phi
      \\
      \alpha_\closed \in \vec{\alpha}_\closed 
      % \\
      % \forall \alpha.\ \tau_l = \alpha \implies \alpha \in \vec{\alpha} 
      \\
      \nexists \alpha.\ \tau_l = \alpha 
      \\\\
      (\vec{\alpha}_\closed, \Delta) \entails \tau_l \subtypes \alpha_\closed \safe
    } {
      \tau_l \subtypes \alpha_\closed \given (\vec{\alpha}_\closed, \Delta) 
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{Note how free variables in interpreted type are marked as closed, to ensure a strict consistency check}

For an upper bound open variable $\alpha$, proof subtyping
finds a lenient interpretation of the variable and checks it against the lower bound.
If safe, it updates the worlds with the subtyping.
To find a lenient interpretation in simple constraints, it searches the world for 
the first upper bounds that are not closed variables. It also looks for relational
upper bounds of pattern type containing the open variable $\alpha$.
Additionally, it learns constraints on closed variables $\Delta^\dagger$ 
that are transitive upper bounds of the open variable $\alpha$.  

The dual of this rule is the one for a lower bound open variable, 
in the continued definition \ref{def:continued_proof_subtyping}.

For elimination of a union type, $\tau_{ll}\J{|}\tau_{lr}$, proof subtyping
ensures that both parts of the assumed type subtype the guaranteed type.

For elimination of an existential type, $\J{EXI[}\vec{\alpha}\ \Delta\J{]}\tau_l$, proof subtyping 
infers necessary constraints over closed variables from the qualifiers $\Delta$ of the assumed existential type, 
which it leverages to prove the guaranteed type. 

For elimination of a least fixed point, $\J{LFP[} \alpha \J{]} \tau_l$, proof subtyping  
attempts a proof by induction, by unrolling the least fixed point
and replacing its self referencing variable with the upper bound.

For introduction of a difference type, $\tau_r \typdiff \eta$, proof subtyping,
checks that the assumed type subtypes the positive portion of the guaranteed type $\tau_r$
and does not subtype the subtracted portion $\eta$.
When relying on negation, one must be careful to preserve soundness.
We ensure that proof subtyping is complete for an upper bound of limited
form $\eta$ with no free type variables, which
means its negation is sound. We will make the limited notion
of completeness precise in section \ref{sect:correctness}.

For a lower bound closed variable $\alpha$, proof subtyping
finds a strict interpretation of the variable
and checks it against the upper bound. Since the subtyping constraints
may contain relational constraints, it factors the relational constraints
to find constraints over single variables, which it used to construct the strict
interpretation $\text{inter}(\vec{\tau})$.  

The dual of this rule is the one for an upper bound closed variable, 
in the continued definition \ref{def:continued_proof_subtyping}.


\hfill
\begin{definition} 
  \label{def:proof_subtyping_lfp_elimination}
  Proof Subtyping (Least Fixed Point Elim)
  \hfill
  \boxed{\J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l[\alpha\slash\tau_r]^+ = \tau_l'
      \\
      \alpha \not\in \text{FTV}(\tau_l')
      \\
      \tau_l' \subtypes \tau_r \given \Omega 
    } {
      \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_difference_intro}
  Proof Subtyping (Difference Intro)
  \hfill
  \boxed{\tau \subtypes \rho \typdiff \eta \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      % \TODO{prove that subtyping of diff is complete}
      % \\\\
      % \TODO{which implies that its negation is sound}
      % \\\\
      \tau \subtypes \rho \given \Omega 
      \\
      \text{FTV}(\eta) \subseteq \epsilon
      \\
      \nexists \Omega' .\  
      \Omega \preceq \Omega'
      \land
      \tau \subtypes \eta \given \Omega'
    } {
      \tau \subtypes \rho \typdiff \eta
      \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_lfp_intro}
  Proof Subtyping (Least Fixed Point Intro)
  \hfill
  \boxed{\tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \Omega \preceq \Omega'
      \\
      \Omega \entails \tau_l \circlearrowleft \J{LFP[} \alpha \J{]} \tau_r
      \\
      \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
      \given \Omega'
    } {
      \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Omega'
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_diff_elimination}
  Proof Subtyping (Difference Elim)
  \hfill
  \boxed{\rho \typdiff \eta \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \rho \subtypes \tau \J{|} \eta \given \Omega
    } {
      \rho \typdiff \eta \subtypes \tau \given \Omega
    }
  \end{mathpar}
\end{definition}
\hfill



\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Proof Subtyping (Expansion Intro)
  \hfill
  \boxed{\tau \subtypes \phi \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau \subtypes \tau_{l} \given \Omega 
    } {
      \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Omega 
    }

    \inferrule {
      \tau \subtypes \tau_{r} \given \Omega 
    } {
      \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Omega 
    }

    \inferrule {
      \tau_l \subtypes \tau_r \given \Omega
      \\
      \Omega \preceq \Omega' 
      \\
      \Delta_r \given \Omega' 
    } {
      \tau_l
      \subtypes 
      \J{EXI[}\vec{\alpha}_r\ \Delta_r \J{]}\tau_r \given \Omega' 
    }
  \end{mathpar}
\end{definition}
\hfill



\hfill
\begin{definition} 
  \label{def:proof_subtyping_refinement_elimination}
  Proof Subtyping (Refinement Elim)
  \hfill
  \boxed{\psi \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_{l} \subtypes \tau \given \Omega
    } {
      \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Omega 
    }

    \inferrule {
      \tau_{l} \subtypes \tau \given \Omega 
    } {
      \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Omega 
    }

    \inferrule {
      \tau_l \subtypes \tau_r \given \Omega 
      \\
      \Omega \preceq \Omega' 
      \\
      \Delta_l \given \Omega' 
    } {
      \J{ALL[}\vec{\alpha}_l\ \vec{\Delta}_l\J{]}\tau_l
      \subtypes 
      \tau_r
      \given \Omega' 
    }
  \end{mathpar}
\end{definition}
\hfill

For a lower bound difference, $\tau_l \typdiff \eta$, proof subtyping
simply checks that the positive type subtypes
the upper bound union with the subtracted type. 




For introduction of an existential type, $\J{EXI[}\vec{\alpha}\ \Delta\J{]}\tau_r$, proof subtyping
infers constraints to witness the guaranteed existential type. 

The elimination counterpart of this rule is the elimination of a universal type (Rule \ref{def:continued_proof_subtyping}.?), 
in which proof subtyping infers constraints to instantiate assumed the universal type.

For an upper bound union, $\tau_{rl}\J{|}\tau_{rr}$, 
proof subtyping checks that the left part of the union holds against
the lower bound. 

The dual of this rule is one for an upper bound intersection, 
in the continued definition \ref{def:continued_proof_subtyping}.

For an upper bound union type, $\tau_{rl}\J{|}\tau_{rr}$, 
proof subtyping also checks that the right part of the union holds against
the lower bound. 

The dual of this rule is one for an upper bound intersection, 
in the continued definition \ref{def:continued_proof_subtyping}.


For an upper bound least fixed point, $\J{LFP[} \alpha \J{]} \tau_r$, 
where subtyping is decomposable, proof subtyping   
unrolls the least fixed point and checks it against the lower bound. 

For an upper bound least fixed point, $\J{LFP[} \alpha \J{]} \tau$, 
where the lower bound is a pattern type containing at least one closed variable,
proof typing searches the world for a constraint with a matching pattern type,
which provides a strict interpretation of the pattern type,
in the form of found constraint's upper bound.
It then checks that the strict interpretation of the pattern type holds.
For increased coverage, the system rewrites relational constraints
into equivalent normal forms.

This rule is the relational analog of the closed variable rules.

For an upper bound least fixed point, $\J{LFP[} \alpha \J{]} \tau$, 
where the lower bound is a pattern type whose variables are all open,
proof subtyping checks that the subtyping is consistent
and checks that a lenient interpretation of the pattern type's open variables
holds. If the subtyping is safe, then world is updated
with the subtyping constraint. 

This rule is the relational analog of the open variable rules.


\hfill
\begin{definition} 
  \label{def:closed_variable_safety_negative}
  Closed Variable Safety (Negative)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe}
  \\
  \begin{mathpar}

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \tau_l \J{<:} \tau_r) \entails \alpha_\closed \subtypes \tau \safe
    }

    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\\\
      \exists \Omega .\ 
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \alpha_\closed \J{<:} \tau_l) \entails \alpha_\closed \subtypes \tau_r \safe
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:closed_variable_safety_positive}
  Closed Variable Safety (Positive)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \tau \subtypes \alpha_\closed \safe}
  \\
  \begin{mathpar}

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \tau \subtypes \alpha_\closed \safe
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \tau_l \J{<:} \tau_r) \entails \alpha_\closed \subtypes \tau \safe
    }

    \inferrule {
      \nexists \alpha .\ \tau_r = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\\\
      \exists \Omega .\ 
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta \J{;}  \tau_r \J{<:} \alpha_\closed) \entails \tau_l \subtypes \alpha_\closed \safe
    }
  \end{mathpar}
\end{definition}
\hfill














\section{Experiments}

\TODO{develop 12 tree/list experiments}

\section{Related work}

\TODO{...}


% \paragraph{Tree interpolation}
% Exemplified by CHC duality solver.

% \paragraph{Hindley-Milner type inference}
% Exemplified by ML.

% \paragraph{Logic programming.}
% Exemplified by Prolog. 


% Similar: both have backchaining. 

% Different: RLT is fully declarative, lacks negations, but has implication. 

% Different: RLT allows comparing inductive relations via subtyping. 

% \paragraph{Semantic subtyping.} 
% Exemplified by XDuce and CDuce. complete subtyping.

% Similar: set-like combinators: union and intersection.

% Different: RLT uses rigid syntactic rules; incomplete subtyping.

% % set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% % semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
% The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
% "semantics subtyping" means the semantics of types is determined indirectly by the semantics of another structure.
% "syntactic subtyping" means the semantics of types is determined directly by the type structure

% \paragraph{Extrinsic typing.}
% Exemplified by Typescript, which is unsound. Maybe not as lenient?  
% The static behavior of a program is not necessarily specified/prescribed; 
% it may be over-approximated from the program composition. 
% Intrinsic vs extrinsic is orthogonal to static vs dynamic, although static and dynamic are often used to mean the former.
% All modern languages use a combination of static and dynamic type checking.
% The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
% even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.

% \paragraph{Refinement Types.}
% Exemplified by Refinement ML. Base types with intersections and subtyping.

% \paragraph{Predicate Subtyping.}
% Exemplified by Liquid Types. An extension of refinement types.

% Similar: both use type inference to infer expressive relational properties. 

% Different: RLT starts with an invalid post-condition, then weakens return type to a valid post-condition from outside in by expanding unions.

% Different: RLT starts with an invalid pre-condition, then strengthens parameter type to a valid pre-condition from inside out by adding intersections.

% Different: Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.


% \paragraph{Abstraction Refinement.} 
% Similar: type unification over subtyping resembles abstraction refinement  
% where solving for variables and failing on different sides of the subtyping relation corresponds to
% solving with the abstractor vs solving with the refiner.

% \paragraph{Craig interpolation.} 
% Similar: extracting an inductive type with unions and intersections 
% from a recursive program without needing to specify a predicate universe might be similar to
% craig interpolation.

% \paragraph{PDR.}
% exemplified by IC3. 

% Similar: RLT infers abstract type for return type, 
% then safely constrains the variables in previous step (fix's antecedent) 
% to subtype the least fixed point.
% This lazily propagates the type for the last step to the previous steps.
% This is safe as antecedent is stronger than consequent at any step.
% Seems similar to the notion in PDR of propagating negation of loss points to previous steps. 

% Different: RLT isn't cartesian

\section{Future Work}
\label{sect:future_work}

Relational reasoning.

\hfill
\begin{definition} 
  \label{def:relational_proof_typing}
  Rel Proof Typing (Loop)
  \hfill 
  \boxed{\Gamma \entails e \hastype \tau \given \Omega}
  \\
  \begin{mathpar}

    \inferrule {
      \Gamma \entails e \hastype \alpha_\nu\J{->}\tau \given  \vec{\alpha}, \Delta 
      \\\\
      \forall \vec{\alpha}'\ \Delta' .\ 
        \vec{\alpha}', \llbracket \epsilon, \vec{\alpha}\ \vec{\alpha}' \entails \Delta', \alpha_l \J{->} \alpha_r \rrbracket^+ \in \vec{\pi}_\nu
      \implies
      \tau \subtypes \alpha_l\J{->}\alpha_r \given  \vec{\alpha}\ \vec{\alpha}', \Delta\ \Delta' 
      \\\\
      \exists \pi.\ \pi \in \vec{\pi}_\nu
      \\
      \alpha_\nu \downarrow \vec{\pi}_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \vec{\pi}_\mu
      \\
      \text{pack}^-(\text{FTV}(\Gamma)\ \vec{\alpha}\ \alpha_\mu \entails \vec{\pi}_\mu) = \tau_\mu
    } {
      \Gamma \entails \J{loop(}e\J{)} 
      \hastype 
      \J{ALL[}\alpha_x \J{]}
      \alpha_x
      \J{->} 
      \J{EXI[}\alpha_y 
          \J{;} \alpha_x \J{*} \alpha_y 
      \J{<:LFP[} \alpha_\mu \J{]}\tau_\mu
      \J{]}\alpha_y
      \given \vec{\alpha}, \Delta 
    }

  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:proof_subtyping_implication_rewriting}
  Rel Proof Subtyping (Implication Rewriting)
  \hfill
  \boxed{\tau \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l \subtypes
      \J{ALL[}\alpha\J{;} \alpha \J{<:} \tau_\mu \J{]} \alpha \J{->} \tau_r
      \given \Omega
    } {
      \tau_l
      \subtypes 
      \J{LFP[}\alpha_\mu\J{]}\tau_\mu\J{->}\tau_r
      \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Rel Proof Subtyping (Pattern Intro)
  \hfill 
  \boxed{\rho \subtypes \J{LFP[}\alpha\J{]}\tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \rho \subtypes \J{LFP[}\alpha\J{]}\tau \cong \rho' \subtypes \J{LFP[}\alpha \J{]} \tau'
      \\
      \Delta \entails \rho' \subtypes \tau_n \sim 
      \\\\
      (\vec{\alpha}, \Delta) \preceq \Omega
      % \\
      % \exists \alpha .\ \alpha \in \text{FTV}(\rho) \land \alpha \in \vec{\alpha} 
      \\
      \tau_n \subtypes \J{LFP[}\alpha \J{]} \tau' \entails \Omega
    } {
      \rho \subtypes \J{LFP[}\alpha\J{]}\tau
      \given \Omega 
    }

    \inferrule {
      \entails \rho \subtypes \J{LFP[}\alpha\J{]}\tau \consis 
      \\
      \forall \alpha_\closed .\ 
      \alpha_\closed \in \text{FTV}(\rho) \land \alpha_\closed \in \vec{\alpha}_\closed
      \implies
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \wr \rho \subtypes \J{LFP[}\alpha\J{]}\tau \safe
      \\\\
      \exists \Delta_i .\ \llbracket \epsilon, \vec{\alpha} \entails \Delta, \rho\rrbracket^+ = \Delta_i, \rho'
      \\
      (\vec{\alpha}, \Delta) \preceq (\vec{\alpha}', \Delta')
      \\
      \rho' \subtypes \J{LFP[}\alpha\J{]}\tau
      \given \vec{\alpha}', \Delta'
    } {
      \rho \subtypes \J{LFP[}\alpha\J{]}\tau
      \given \vec{\alpha}', \Delta' \J{;} \rho \J{<:} \J{LFP[}\alpha\J{]}\tau
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:rel_closed_variable_safety_negative}
  Rel Closed Variable Safety (Negative)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe}
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\
      \exists \Omega .\ 
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \alpha_\closed \J{<:} \tau_l) \entails \alpha_\closed \subtypes \tau_r \safe
    }

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \tau_l \J{<:} \tau_r) \entails \alpha_\closed \subtypes \tau \safe
    }

    \inferrule {
      \alpha_\closed \in \text{FTV}(\rho)
      \\
      \rho \subtypes \tau \factorsinto \alpha_\closed \subtypes \tau' 
      \\
      (\vec{\alpha}_\closed, \Delta \J{;} \alpha_\closed \J{<:} \tau') \entails \alpha_\closed \subtypes \tau'' \safe
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \rho \J{<:} \tau) \entails \alpha_\closed \subtypes \tau'' \safe
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:relational_key_safety_negative}
  Relational Key Safety (Negative)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \wr \rho \subtypes \tau \safe}
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\
      \forall \tau_r .\
      \rho \subtypes \tau \factorsinto \alpha_\closed \subtypes \tau_r
      \implies
      \exists \Omega .\  
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \alpha_\closed \J{<:} \tau_l) 
      \entails 
      \alpha_\closed  \wr \rho \subtypes \tau \safe
    }

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \wr \rho \subtypes \tau \safe
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \tau_l \J{<:} \tau_r) 
      \entails
      \alpha_\closed  \wr \rho \subtypes \tau \safe
    }

    \inferrule {
      \alpha_\closed \in \text{FTV}(\rho)
      \\
      \rho \subtypes \tau \factorsinto \alpha_\closed \subtypes \tau' 
      \\\\
      (\vec{\alpha}_\closed, \Delta \J{;} \alpha_\closed \J{<:} \tau') \entails \alpha_\closed \wr \rho' \subtypes \tau'' \safe
    } {
      (\vec{\alpha}_\closed, \Delta \J{;} \rho \J{<:} \tau) \entails \alpha_\closed \wr \rho' \subtypes \tau'' \safe
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:relational_constraint_factorization}
  Relational Constraint Factorization 
  \hfill
  \boxed{\rho \subtypes \tau \factorsinto \alpha \subtypes \tau'}
  \\
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \rho \subtypes \tau \factorsinto \alpha \subtypes \tau' 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Rel Proof Subtyping (Abstraction Intro)
  \hfill
  \boxed{\tau \subtypes \phi \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \rho \subtypes \tau_{l} \given \Omega 
    } {
      \rho \subtypes \tau_{l}\J{|}\tau_{r} \given \Omega 
    }

    \inferrule {
      \rho \subtypes \tau_{r} \given \Omega 
    } {
      \rho \subtypes \tau_{l}\J{|}\tau_{r} \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}
  \label{def:rel_interpretation}
  Rel Interpretation  (Negative)
  \hfill
  \boxed{\llbracket \Delta, \alpha \rrbracket^- = (\Delta, \tau)}
  \\
  \begin{mathpar}
    \inferrule {
      \neg(\Delta \entails \alpha \relational)
      \\
    } {
      \llbracket \epsilon, \alpha \rrbracket^- = (\epsilon, \J{TOP})
    }

    \inferrule {
      \neg(\Delta \entails \alpha \relational)
      \\
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau')
    } {
      \llbracket \Delta \J{;}\alpha  \J{<:} \tau, \alpha \rrbracket^- = (\Delta', \tau' \J{\&} \tau)
    }

    \inferrule {
      \alpha \neq \tau_l
      \\
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau)
    } {
      \llbracket \Delta \J{;}\tau_l \J{<:} \tau_r, \alpha \rrbracket^- = (\Delta' \J{;}\tau_l \J{<:} \tau_r, \tau)
    }

    \inferrule {
      \Delta \entails \alpha \relational
    } {
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta, \alpha)
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}
  \label{def:relational_constraint_key}
  Relational Constraint Key
  \hfill
  \boxed{\Delta \entails \alpha \relational}
  \\
  \begin{mathpar}
    \inferrule {
      \J{;} \tau_l \J{<:} \tau_r \in \Delta 
      \\
      \nexists \alpha' .\ \tau_l = \alpha'
      \\
      \alpha \in \text{FTV}(\tau_l)
    } {
      \Delta \entails \alpha \relational
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition}
  \label{def:decomposable}
  Decomposable 
  \\\\
  \boxed{\Omega \entails \tau \circlearrowleft \tau}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      % \text{decomposable}(\Delta_0, \tau_l, \J{LFP[} \alpha \J{]} \tau_r)
      \Omega \entails \tau \circlearrowleft \tau
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}\boxed{\tau \subtypes \tau \cong \tau \subtypes \tau}\ Normal Constraint Congruence 
  \label{def:normal_constraint_congruence}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \tau \subtypes \tau \cong \tau \subtypes \tau
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}\boxed{\Delta \entails \tau' \subtypes \tau \sim}\ Normal Constraint Entailment  
  \label{def:normal_constraint_entailment}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \Delta \entails \tau' \subtypes \tau \sim
    }
  \end{mathpar}
\end{definition}
\hfill


\section{Appendix}
\label{sect:appendix}
\begin{definition} Internals 
  \label{def:internals}
  \[\begin{array}[t]{r@{}l}
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ x : \tau
    \\
    \\
    \nonterm{\vec{\Omega}} & \is \epsilon \sep \vec{\Omega}\ \Omega
    \\
    \nonterm{\Omega} & \is \vec{\alpha}, \Delta
    \\
    \\
    \nonterm{\vec{\tau}} & \is \epsilon \sep \vec{\tau}\ \tau
    \\
    \nonterm{\vec{\phi}} & \is \epsilon \sep \vec{\phi}\ \phi
    \\
    \\
    \nonterm{\vec{\pi}} & \is \epsilon \sep \vec{\pi}\ \pi
    \\
    \nonterm{\pi} & \is \vec{\alpha}, \Delta, \tau \J{->} \tau
    \\
    \\
    \nonterm{\vec{\delta}} & \is \epsilon \sep \vec{\delta}\ \delta
    \\
    \nonterm{\delta} & \alpha \slash \tau
  \end{array}\]
\end{definition}


\begin{definition} Sugared Expressions 
  \label{def:sugared_expressions}
  \[\begin{array}[t]{r@{}l}
    \nonterm{e} & \is 
    \begin{array}[t]{@{}l}
      ... \sep
      e\J{,}e \sep
      e\J{|>}e \sep
      \J{let}\ x\ z\ \J{=}\ e\ \J{in}\ e \sep
      \J{(}e\J{)}
    \end{array}
    \\
    \nonterm{z} & \is \epsilon \sep \J{:}\tau 
    \\
    \nonterm{p} & \is 
      ... \sep
      p\J{,}p \sep
      \J{(}p\J{)} 
  \end{array}\]
\end{definition}

\begin{definition} Values 
  \label{def:others}
  \[\begin{array}[t]{r@{}l}
    \nonterm{v} & \is 
      \J{@} \sep
      \J{<$l$> $v$} \sep
      \vec{g} \sep
      \J{$v$,$v$} \sep
      \J{($v$)} \sep
      \vec{f} 
    \\
    \nonterm{\vec{g}} & \is \epsilon \sep \vec{g}\ g
    \\
    \nonterm{g} & \is \J{?$l$=>$v$}
    \\
    \\
    \nonterm{\vec{\sigma}} & \is \epsilon \sep \vec{\sigma}\ \sigma
    \\
    \nonterm{\sigma} & \is x \slash v
  \end{array}\]
\end{definition}


\begin{definition}\boxed{e \rightsquigarrow e}\ Sugared Progression
  \begin{mathpar}
    \inferrule {
      e_b \J{(} e_a \J{)} \rightsquigarrow e' 
    } {
      e_a \J{|>} e_b \rightsquigarrow e' 
    }

    \inferrule {
      e \rightsquigarrow e' 
    } {
      \J{(} e \J{)} \rightsquigarrow e' 
    }

    \inferrule {
      \J{?left=>} e_l\ \J{?right=>} e_r \rightsquigarrow e' 
    } {
      e_l\J{,}e_r \rightsquigarrow e' 
    }

    \inferrule {
      \J{(? <true> @=>}e_t \J{\ ? <false> @=>}e_f \J{)(}e_c\J{)} \rightsquigarrow e'
    } {
      \J{if}\ e_c\ \J{then}\ e_t\ \J{else}\ e_f \rightsquigarrow e' 
    }


    \inferrule {
      \J{(?} x \J{=>} e_k \J{)(} e \J{)}
      \rightsquigarrow e'
    } {
      \J{let}\ x \J{:} \tau\ \J{=}\ e\ \J{in}\ e_k \rightsquigarrow e'
    }

    % \inferrule {
    %   e \rightsquigarrow e'
    % } {
    %   \J{let $x$:$\tau$ = $e$ in $e_k$} \rightsquigarrow \J{let $x$:$\tau$ = $e'$ in $e_k$}
    % }

    % \inferrule {
    % } {
    %   \J{let $x$:$\tau$ = $v$ in $e$} \rightsquigarrow e[x \slash v]
    % }
  \end{mathpar}
\end{definition}

\begin{definition} Sugared Types 
  \label{def:sugared_types}
  \[\begin{array}[t]{r@{}l}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      ... \sep
      \J{TOP} \sep 
      \J{BOT} \sep
      \J{(}\tau\J{)}

    \end{array}
    \\
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      ... \sep
      \J{(}\phi\J{)}

    \end{array}
  \end{array}\]
\end{definition}

\begin{definition} 
  \label{def:type_interpretation}
  Type Interpretation 
  \\\\
  \boxed{
    \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau)
  }
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \notin \vec{\alpha}_\local
      \\
      \alpha \notin \vec{\alpha}_\closed
      \\
      \llbracket \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
    }

    \inferrule {
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \J{@} \rrbracket^\pm = (\Delta, \J{@})
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \J{<}l\J{>}\tau \rrbracket^\pm = (\Delta', \J{<}l\J{>}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, l\J{->}\tau \rrbracket^\pm = (\Delta', l\J{->}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^\pm = (\Delta_r, \tau_r')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^{\text{flip}(\pm)} = (\Delta_l, \tau_l')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l\J{->}\tau_r \rrbracket^\pm = (\Delta_l \cap \Delta_r, \tau_l'\J{->}\tau_r')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^\pm = (\Delta_l, \tau_l')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^{\pm} = (\Delta_r, \tau_r')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l\J{|}\tau_r \rrbracket^\pm = (\Delta_l \cap \Delta_r, \tau_l'\J{|}\tau_r')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
      \\\\
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^{\pm} = (\Delta'', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \J{EXI[}\vec{\alpha}\ \Delta_q \J{]} \tau \rrbracket^\pm 
      = 
      (\Delta' \cap \Delta'', \J{EXI[}\vec{\alpha}\ \Delta_q' \J{]}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^{\pm} = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \J{LFP[}\alpha \J{]} \tau \rrbracket^\pm 
      = 
      (\Delta', \J{LFP[}\alpha \J{]}\tau')
    }

    \\

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^\pm = (\Delta_l, \tau_l')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^{\pm} = (\Delta_r, \tau_r')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l\J{\&}\tau_r \rrbracket^\pm = (\Delta_l \cap \Delta_r, \tau_l'\J{\&}\tau_r')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
      \\\\
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^{\pm} = (\Delta'', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \J{ALL[}\vec{\alpha}\ \Delta_q \J{]} \tau \rrbracket^\pm 
      = 
      (\Delta' \cap \Delta'', \J{ALL[}\vec{\alpha}\ \Delta_q' \J{]}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \typdiff \eta \rrbracket^\pm 
      = (\Delta', \tau' \typdiff \eta)
    }
  \end{mathpar}
\end{definition}

\begin{definition} 
  \label{def:Qualification_interpretation}
  Qualification Interpretation 
  \\\\
  \boxed{
    \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
  }
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \epsilon \rrbracket^\pm = (\Delta', \epsilon')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \Delta_q\rrbracket^\pm = (\Delta', \Delta_q')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^\pm = (\Delta_l, \tau_r')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^{\text{flip}(\pm)} = (\Delta_r \tau_l')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \Delta_q \J{;} \tau_l \J{<:} \tau_r \rrbracket^\pm = (\Delta' \cap \Delta_l \cap \Delta_r, \Delta_q' \J{;} \tau_l' \J{<:} \tau_r')
    }

  \end{mathpar}
\end{definition} 


\hfill
\begin{definition} 
  \label{def:pruning_interpretation}
  Pruning Interpretation 
  \\\\
  \boxed{
    \llbracket \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
  }
  \\
  \begin{mathpar}
    \inferrule {
      \forall \tau_l\ \tau_r .\ \J{;} \tau_l \J{<:} \tau_r \in \Delta' \iff \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r 
      \\
      \llbracket \Delta\backslash\Delta', \alpha \rrbracket^\pm = (\Delta', \tau)
    } {
      \llbracket \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:indirection}
  Indirection  
  \\\\
  \boxed{
    \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r 
  }
  \\
  \begin{mathpar}
    \inferrule {
      \J{;}\alpha\J{<:}\tau \in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \J{;}\alpha'\J{<:}\tau' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^- \alpha \subtypes \tau
    }

    \inferrule {
      \J{;}\alpha\J{<:}\tau \in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \J{;}\alpha'\J{<:}\tau' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^- \alpha' \subtypes \tau'
    }
    \\
    \inferrule {
      \J{;}\tau \J{<:} \alpha\in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \J{;}\tau'\J{<:} \alpha' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^+ \tau \subtypes \alpha
    }

    \inferrule {
      \J{;}\tau \J{<:} \alpha\in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \J{;}\tau'\J{<:} \alpha' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^+ \tau' \subtypes \alpha'
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:interpretation}
  Interpretation
  \\\\
  \boxed{
    \llbracket\Delta, \alpha \rrbracket^\pm = (\Delta, \tau)
  }
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \llbracket \epsilon, \alpha \rrbracket^- = (\epsilon, \J{TOP})
    }

    \inferrule {
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau')
    } {
      \llbracket \Delta \J{;}\alpha  \J{<:} \tau, \alpha \rrbracket^- = (\Delta', \tau' \J{\&} \tau)
    }

    \inferrule {
      \alpha \neq \tau_l
      \\
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau)
    } {
      \llbracket \Delta \J{;}\tau_l \J{<:} \tau_r, \alpha \rrbracket^- = (\Delta' \J{;}\tau_l \J{<:} \tau_r, \tau)
    }
    \\
    \inferrule {
    } {
      \llbracket \epsilon, \alpha \rrbracket^+ = (\epsilon, \J{BOT})
    }

    \inferrule {
      \llbracket \Delta, \alpha \rrbracket^+ = (\Delta', \tau')
    } {
      \llbracket \Delta \J{;} \tau \J{<:} \alpha  , \alpha \rrbracket^+ = (\Delta', \tau' \J{|} \tau)
    }

    \inferrule {
      \alpha \neq \tau_r
      \\
      \llbracket \Delta, \alpha \rrbracket^+ = (\Delta', \tau)
    } {
      \llbracket \Delta \J{;}\tau_l \J{<:} \tau_r, \alpha \rrbracket^+ = (\Delta' \J{;}\tau_l \J{<:} \tau_r, \tau)
    }
  \end{mathpar}
  \TODO{soundess: $\llbracket \Delta, \alpha \rrbracket^- \subtypes (\Delta', \tau) \implies \Delta' \satisfies \alpha <: \tau$}

  \TODO{soundess: $\llbracket \Delta, \alpha \rrbracket^- \subtypes (\Delta', \tau) \implies \Delta \satisfies \Delta'$}
\end{definition}
\hfill


\begin{definition}\boxed{\text{pack}^\pm(\vec{\alpha}, \vec{\alpha}, \Delta \entails \tau) = \tau} Type Packaging 

  \TODO{update}

  \begin{mathpar}
    \inferrule {
      \text{FTV}(\tau) = \vec{\alpha}_p
      \\
      \Delta \entails \vec{\alpha}_f\ \vec{\alpha}_c\ \vec{\alpha}_p \pitchfork \Delta' 
      \\\\
      \vec{\alpha}_f, \vec{\alpha}_c, \Delta' \entails \Delta_o \wr \Delta_i 
      \\\\
      (\text{FTV}(\Delta)\ \vec{\alpha}_p)\ \diamond\ \vec{\alpha}_c = \vec{\alpha}_o 
      \\
      (\text{FTV}(\Delta_i)\ \vec{\alpha}_p)\ \backslash\ \vec{\alpha}_c \ \backslash\ \vec{\alpha}_f = \vec{\alpha}_i 
      \\\\
      \text{quantify}^{\pm}(\vec{\alpha}_o, \Delta_o, \vec{\alpha}_i, \Delta_i, \tau) = \tau'
    } {
      \vec{\alpha}_f, \vec{\alpha}_c, \Delta \entails \tau \cong^{\pm} \tau'
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\text{pack}^\pm(\vec{\alpha} \entails \vec{\pi}) = \vec{\tau}}\ Multiple Type Packaging 
  \label{def:multiple_type_packaging}

  \TODO{update}

  \begin{mathpar}
    \inferrule {
    } {
      \vec{\alpha}_f \entails \epsilon \cong^\pm \epsilon 
    }

    \inferrule {
      \vec{\alpha}_f \entails \vec{\pi} \cong^\pm \vec{\tau} 
      \\
      \vec{\alpha}_f, \vec{\alpha}_c, \Delta \entails \tau \cong^\pm \tau'
    } {
      \vec{\alpha}_f \entails \vec{\pi}\ \left<\vec{\alpha}_c, \Delta, \tau \right> \cong^\pm \vec{\tau}\ \tau' 
    }
  \end{mathpar}
\end{definition}



\begin{definition}\boxed{\vec{\alpha} \entails \Delta \wr \vec{\alpha} \given \vec{\delta}}\ Modulo Type Solution  
  \label{def:modulo_type_solution}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \vec{\alpha} \entails \Delta \wr \vec{\alpha} \given \vec{\delta}
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\entails \tau_l \subtypes \tau \consis}\ Constraint Consistency  
  \label{def:constraint_consistency}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \entails \tau_l \subtypes \J{LFP[}\alpha\J{]}\tau_r \consis 
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta[\alpha\slash\tau]^\pm = \Delta}\ Polar Subtyping Environment Substitution 
  \label{def:polar_subtyping_environment_substitution}
  \TODO{...}
  \begin{mathpar}
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\tau[\alpha\slash\tau]^\pm = \tau}\ Polar Type Substitution 
  \label{def:polar_type_substitution}
  \TODO{...}
  \begin{mathpar}
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\text{skolem}(\Delta) = (\Delta, \Delta)}\ Skolem Subtyping Separation 
  \label{def:skolem}
  \TODO{...}
  \begin{mathpar}
  \end{mathpar}
\end{definition}




\begin{definition} \boxed{\Alpha \notfree \tau}\ Fresh variables 
  \label{def:fresh_variables}
  \begin{mathpar}
    \inferrule {
      \forall \alpha .\ \alpha \in \Alpha \implies \alpha \notin \text{FV}(\tau)
    } {
      \Alpha \notfree \tau
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\tau \subtypes \tau \given Z}\ (Proof universe subtyping)
  \label{def:proof_universe_subtyping}
  \begin{mathpar}
    \inferrule {
      \left< M, \Delta \right> \in Z 
      \\
      \forall  M\ \Delta .\  
      \tau_l \subtypes \tau_r \given M, \Delta 
      \iff
      \left< M, \Delta \right> \in Z 
    } {
      \tau_l \subtypes \tau_r \given Z 
    }

  \end{mathpar}
\end{definition}

\begin{definition}\boxed{Q \given M, \Delta}
  \begin{mathpar}
    \inferrule {
      Q \given M_0, \Delta_0
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_r \given M_1, \Delta_1
    } {
      Q \J{.$\tau_l$<:$\tau_r$}
      \given
      M_1, \Delta_1
    }

    \inferrule {
    } {
      M, \Delta \entails \epsilon
    }
  \end{mathpar}
\end{definition}

\begin{definition}(Collection)
  \[\begin{array}[t]{r@{}l}
    \nonterm{C} & \is \epsilon \sep C\ c
  \end{array}\]
\end{definition}
\begin{definition}\boxed{C\ C = C}\ Concatenation
  \[\begin{array}{rclr}
    C\ \epsilon 
    &=& 
    C
    & \C{empty} 
    \\

    C\ (C'\ c) 
    &=& 
    (C\ C')\ c
    & \C{step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{C \diamond  C = C}\ Filter
  \[\begin{array}{rclr}
    C \diamond \epsilon 
    &=& 
    \epsilon 
    % & \C{empty} 
    \\

    C \diamond (C'\ c) 
    &=& 
    \begin{cases}
      (C \diamond C')\ c & \text{if } c \in C\\
      (C \diamond C') & \text{otherwise}
    \end{cases}
    % & \D{Step} 
    \\
  \end{array}\]
\end{definition}

% \begin{definition}\boxed{\widebar{\ c\ }^{\vec{t}[P]} \circeq C}\ Comprehension 
%   \begin{mathpar}
%     \inferrule {
%       \forall 
%     } {
%       \widebar{\ c\ }^{A[P]} \circeq C
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{\text{map}(C, t) = C}
%   \[\begin{array}{rclr}
%     \text{map}(\epsilon, t)
%     &=& 
%     \epsilon
%     & \C{empty} 
%     \\

%     \text{map}(C\ c, t)
%     &=& 
%     \text{map}(C, t) \cup t(c)
%     & \C{step} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{\widebar{\ c\ }^{c \in C} \circeq C}\ Map sugar 
%   \[\begin{array}{rclr}
%     \widebar{\ c'\ }^{c \in C} 
%     &\circeq& 
%     \text{map}(C, \lambda c . c')
%     % & \C{comprehension} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{c \in C}\ Collection Containment
%   \begin{mathpar}
%     \inferrule {
%       c \notin C
%     } {
%       c \in C\ c 
%     }

%     \inferrule {
%       c \in C
%     } {
%       c \in C\ c' 
%     }
%   \end{mathpar}
% \end{definition}

\begin{definition}\boxed{c \in C}\ Collection Containment
  \begin{mathpar}
    \inferrule {
    } {
      c \in C\ c 
    }

    \inferrule {
      c \neq c'
      \\
      c \in C
    } {
      c \in C\ c' 
    }
  \end{mathpar}
\end{definition}


\begin{definition} \boxed{C \preceq C}
  \begin{mathpar}
    \inferrule {
    } {
      C \preceq C 
    }

    \inferrule {
      C \preceq C' 
    } {
      C \preceq C'\ c 
    }
  \end{mathpar}
\end{definition}

% \begin{definition}\boxed{\text{union}(\Tau) = \tau}\ Collective Union
%   \[\begin{array}{rclr}
%     \text{union}(\epsilon)
%     &=& 
%     \J{BOT}
%     & \C{empty} 
%     \\

%     \text{union}(\Tau\ \tau)
%     &=& 
%     \text{union}(\Tau) \J{|} \tau
%     & \C{step} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{\text{inter}(\Tau) = \tau}\ Collective Intersection
%   \[\begin{array}{rclr}
%     \text{inter}(\epsilon)
%     &=& 
%     \J{TOP}
%     & \C{empty} 
%     \\

%     \text{inter}(\Tau\ \tau)
%     &=& 
%     \text{inter}(\Tau) \J{\&} \tau
%     & \C{step} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails m <:^\sharp \alpha}\ Lower closed subtyping 
%   \begin{mathpar}
%     \inferrule {
%       m \in M
%       \\
%       m <: \alpha \in \Delta
%     } {
%       M, \Delta \entails  m <:^\sharp \alpha
%     }

%     % \inferrule {
%     %   m' \in M
%     %   \\
%     %   M, \Delta \entails m <:^\sharp m' 
%     %   \\
%     %   m' <: \alpha \in \Delta
%     % } {
%     %   M, \Delta \entails  m <:^\sharp \alpha
%     % }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \Delta <:^\sharp \alpha \slash \tau}\ Universal lower closed subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall m\ \tau .\ m <: \tau \in \Delta' \iff  M, \Delta \entails 
%       m \in M
%       \land
%       m <: \alpha \in \Delta
%       % m <:^\sharp \alpha
%     } {
%       M, \Delta \entails \Delta' <:^\sharp \alpha \slash \tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\sharp m}\ Upper closed subtyping 
%   \begin{mathpar}
%     \inferrule {
%       m \in M
%       \\
%       \alpha <: m \in \Delta
%     } {
%       M, \Delta \entails  \alpha <:^\sharp m 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \slash \tau <:^\sharp \Delta}\ Universal upper closed subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau\ m .\ \tau <: m \in \Delta' \iff  
%       m \in M
%       \land
%       \alpha <: m \in \Delta
% % M, \Delta \entails \alpha <:^\sharp m 
%     } {
%       M, \Delta \entails \alpha <:^\sharp \Delta' 
%     }
%   \end{mathpar}
% \end{definition}


% \begin{definition}\boxed{M, \Delta, \Delta \entails M \lessdot \alpha}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \epsilon \lessdot \alpha
%     }

%     \inferrule {
%       m \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails M_1 \lessdot \alpha
%       \\\\
%       M_0, \Delta_0, \Delta_0 \entails M_2 \lessdot m 
%     } {
%       M_0, \Delta_0, \Delta_1 \ m<:\alpha 
%       \entails M_1 \cup M_2 \ m \lessdot \alpha
%     }

%     \inferrule {
%       \neg (\tau_l \in M_0 \land \tau_r = \alpha)
%       \\\\
%       M_0, \Delta_0, \Delta_1 \entails M_1 \lessdot \alpha
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r
%       \entails M_1 \lessdot \alpha
%     }
%   \end{mathpar}
% \end{definition}


% \begin{definition}\boxed{M, \Delta \entails \tau <:^\dagger \alpha}\ Lower transitive subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \tau \notin M
%       \\
%       \tau <: \alpha \in \Delta 
%     } {
%       M, \Delta \entails \tau <:^\dagger \alpha
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta \entails \tau <:^\dagger m 
%       \\
%       m <: \alpha \in \Delta 
%     } {
%       M, \Delta \entails \tau <:^\dagger \alpha
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \Tau <:^\dagger \alpha}\ Universal lower transitive subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau .\ \tau \in \Tau \iff  M, \Delta \entails \tau <:^\dagger \alpha
%     } {
%       M, \Delta \entails \Tau <:^\dagger \alpha
%     }
%   \end{mathpar}
% \end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\dagger \tau}\ Upper transitive subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \tau \notin M
%       \\
%       \alpha <: \tau \in \Delta 
%     } {
%       M, \Delta \entails \alpha <:^\dagger \tau
%     }

%     \inferrule {
%       m \in M
%       \\
%       \alpha <: m \in \Delta 
%       \\
%       M, \Delta \entails m <:^\dagger \tau 
%     } {
%       M, \Delta \entails \alpha <:^\dagger \tau 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\dagger \Tau}\ Universal upper transitive subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau .\ \tau \in \Tau \iff  M, \Delta \entails \alpha <:^\dagger \Tau
%     } {
%       M, \Delta \entails \alpha <:^\dagger \Tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \Tau \ll \alpha}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \epsilon \ll \alpha
%     }

%     \inferrule {
%       \tau \notin M
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau \ll \alpha
%     } {
%       M, \Delta_0, \Delta_1 \ \tau<:\alpha \entails \Tau\ \tau \ll \alpha
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau_0 \ll \alpha
%       \\
%       M, \Delta_0, \Delta_0 \entails \Tau_1 \ll z 
%     } {
%       M, \Delta_0, \Delta_1 \ m<:\alpha \entails \Tau_0 \cup \Tau_1 \ll \alpha
%     }

%     \inferrule {
%       \tau_r \neq \alpha
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau \ll \alpha
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \Tau \ll \alpha
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \lessdot M}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \lessdot \epsilon
%     }

%     \inferrule {
%       m \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot M_1 
%       \\\\
%       M_0, \Delta_0, \Delta_0 \entails m \lessdot M_2 
%     } {
%       M_0, \Delta_0, \Delta_1 \ \alpha<:m \entails \alpha \lessdot M_1 \cup M_2\ m 
%     }

%     \inferrule {
%       \neg (\tau_r \in M_0 \land \tau_l = \alpha)
%       \\\\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot M_1
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \lessdot M_1
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \ll \Tau}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \ll \epsilon
%     }

%     \inferrule {
%       \tau \notin M
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau
%     } {
%       M, \Delta_0, \Delta_1 \ \alpha<:\tau \entails \alpha \ll \Tau\ \tau
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau_0
%       \\
%       M, \Delta_0, \Delta_0 \entails m \ll \Tau_1
%     } {
%       M, \Delta_0, \Delta_1 \ \alpha<:m \entails \alpha \ll \Tau_0 \cup \Tau_1
%     }

%     \inferrule {
%       \tau_l \neq \alpha
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \star \tau <: m}\ Relational transitive closed subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l) 
%       \\
%       m \in M
%     } {
%       M, \Delta \entails \alpha \star \tau <: m 
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l) 
%       \\
%       m \in M
%       \\
%       \tau <: m \in \Delta
%       \\
%       M, \Delta \entails m <:^\sharp m' 
%     } {
%       M, \Delta \entails \alpha \star \tau <: m' 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \star \Delta}\ Universal relational transitive closed subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau_l\ \tau_r .\ \tau_l <: \tau_r \in \Delta \iff  M, \Delta \entails \alpha \star \tau_l <: \tau_r
%     } {
%       M, \Delta \entails \alpha \star \Delta 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \lessdot \Delta}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \lessdot \epsilon
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau)
%       \\
%       m_0 \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot \Delta_2
%       \\
%       M_0, \Delta_0, \Delta_0 \entails m_0 \lessdot M_1 
%     } {
%       M_0, \Delta_0
%       \entails
%       \Delta_1 \ \tau<:m_0
%       \entails
%       \alpha 
%       \lessdot 
%       \Delta_2 \cup \widebar{\tau<:m_1}^{m_1 \in M_1}\ \tau<:m_0
%     }

%     \inferrule {
%       \neg (\tau_r \in M_0 \land \alpha \in \text{FTV}(\tau_l))
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot \Delta_2 
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \lessdot \Delta_2
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \dagger \tau <: \tau}\ Relational subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \alpha \neq \tau_l
%       \\
%       \alpha \in \text{FTV}(\tau_l) 
%     } {
%       \Delta \entails \alpha \dagger \tau_l <: \tau_r 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \slash \tau \dagger \Delta}\ Relational substitution 
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau_l\ \tau_r .\ \tau_l[\alpha\slash\tau] <: \tau_r \in \Delta' \iff  M, \Delta \entails \alpha \dagger \tau_l <: \tau_r
%     } {
%       M, \Delta \entails \alpha \slash \tau \dagger \Delta' 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \ll \Delta}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \ll \epsilon
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l)
%       \\
%       \tau \notin M 
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Delta_2 \ \tau_l<:\tau_r
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau)
%       \\
%       m \in M 
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%       \\\\
%       M, \Delta_0, \Delta_0 \entails z \ll \Delta_3 
%     } {
%       M, \Delta_0, \Delta_1 \ \tau<:z \entails \alpha \ll \Delta_2 \cup \Delta_3
%     }

%     \inferrule {
%       \alpha \notin \text{FTV}(\tau_l)
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Delta_2
%     }
%   \end{mathpar}
% \end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subtyping Solving (Inductive) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}\boxed{M, \Delta, \Alpha \entails \vec{\delta}}
  \begin{mathpar}
    \inferrule {
    } {
      M, \Delta, \epsilon \entails \epsilon
    }

    \inferrule {
      \alpha \notin M 
      \\
      \forall \tau .\ \tau<:\alpha \notin \Delta
      \\
      M, \Delta, A \entails \vec{\delta}
    } {
      M, \Delta, A \ \alpha \entails \vec{\delta}
    }

    \inferrule {
      \alpha \notin M 
      \\
      \exists \tau .\  \tau<:\alpha \in \Delta
      \\
      M, \Delta, \Alpha \entails \vec{\delta}
    } {
      M, \Delta, \Alpha\ \alpha 
      \entails 
      \vec{\delta}\ \alpha \slash \J{|}(\widebar{\ \tau\ }^{\tau<:\alpha \in \Delta})
    }
  \end{mathpar}
\end{definition}

% \begin{definition}
% \boxed{\vec{\alpha} \entails \text{GFP}[\alpha]\vec{\Omega} \Rightarrow \alpha \rightarrow \alpha \fallingdotseq \text{LFP}[\alpha]\vec{\tau}}
% \ Fixpoint Duality
% \label{def:fixpoint_duality}

%   % NOTE: read "z, \- a0 Circle W  . a1 -> a2 --> T" as 
%   % - forall x y, (LFP[a] intersect vec{W}: a1 -> a2) <: (x -> y) iff (x, y) <: union of vec{T}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       \vec{\alpha}_f \entails 
%       \text{GFP}[\alpha_{h^+}] \epsilon \Rightarrow \alpha_l \rightarrow \alpha_r 
%       \fallingdotseq 
%       \text{LFP}[\alpha_{h^-}]\epsilon 
%     }

%     \inferrule {
%       \vec{\alpha}_f \entails 
%       \text{GFP}[\alpha_{\nu}] \vec{\Omega} \Rightarrow \alpha_l \rightarrow \alpha_r
%       \fallingdotseq 
%       \text{LFP}[\alpha_{\mu}]\vec{\tau}
%       \\\\
%       \Delta_\nu \entails \alpha_{\nu} \subtypes \vec{\tau}_\nu
%       \\
%       \Delta_\nu \entails \alpha_l \subtypes \vec{\tau}_l 
%       \\
%       \Delta_\nu \entails \vec{\tau}_r \subtypes \alpha_r
%       \\\\
%       \vec{\tau}_\nu \fallingdotseq \vec{\tau}_\mu
%       \\
%       \text{union}(\vec{\tau}_\mu) \subtypes \alpha_\mu \given \Delta_\mu
%       \\\\
%       \vec{\alpha}_f\ \alpha_{\mu}, \vec{\alpha}_c, \Delta_\nu\ \Delta_\mu \entails \J{\&$(\vec{\tau}_l)$*|$(\vec{\tau}_r)$} \cong^{-} \tau
%       % TODO: should closeds be included using universal constraint? 
%     } {
%       \vec{\alpha}_f \entails 
%       \text{GFP}[\alpha_{\nu}]\vec{\Omega}\ \left< \vec{\alpha}_c,\Delta_\nu \right> \Rightarrow \alpha_l \rightarrow \alpha_r 
%       \fallingdotseq 
%       \text{LFP}[\alpha_{\mu}] \vec{\tau}\ \tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{\vec{\tau} \fallingdotseq \vec{\tau} }\ Pair Duality 
% \label{def:pair_duality}
%   \begin{mathpar}

%     \inferrule {
%     } {
%       \epsilon \fallingdotseq \epsilon 
%     }

%     \inferrule {
%     } {
%       \vec{\tau}_\nu\ (\tau_l \J{->} \tau_r) \fallingdotseq \vec{\tau}_\mu\ (\tau_l \J{*} \tau_r)
%     }
%   \end{mathpar}
% \end{definition}

\begin{definition}\boxed{\Delta \entails \Alpha \pitchfork \Delta}\ Influential Filter 
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \Alpha \pitchfork \epsilon 
    }

    \inferrule {
      \alpha \in \Alpha  
      \\
      \alpha \in \text{FTV}(\tau_l) \cup \text{FTV}(\tau_r)
      \\
      \Delta \entails \Alpha \pitchfork \Delta'
    } {
      \Delta \ \tau_l<:\tau_r \entails N \pitchfork \Delta' \ \tau_l<:\tau_r
    }

    \inferrule {
      \forall \alpha .\ \alpha \in \Alpha \implies \alpha \notin \text{FTV}(\tau_l) \cup \text{FTV}(\tau_r)
      \\
      \Delta \entails \Alpha \pitchfork \Delta'
    } {
      \Delta \ \tau_l<:\tau_r \entails \Alpha \pitchfork \Delta'
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \Tau \subtypes \alpha}
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \epsilon \subtypes \alpha
    }

    \inferrule {
      \Delta \entails \Tau \subtypes \alpha
    } {
      \Delta \ \tau<:\alpha \entails \Tau\ \tau \subtypes \alpha
    }

    \inferrule {
      \tau_r \neq \alpha
      \\
      \Delta \entails \Tau \subtypes \alpha
    } {
      \Delta \ \tau_l<:\tau_r \entails \Tau \subtypes \alpha
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \alpha \subtypes \Tau}
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \alpha \subtypes \epsilon
    }

    \inferrule {
      \Delta \entails \alpha \subtypes \Tau
    } {
      \Delta \ \alpha<:\tau \entails \alpha \subtypes \Tau\ \tau
    }

    \inferrule {
      \tau_l \neq \alpha
      \\
      \Delta \entails \alpha \subtypes \Tau
    } {
      \Delta \ \tau_l<:\tau_r \entails \alpha \subtypes \Tau
    }
  \end{mathpar}
\end{definition}



\begin{definition}\boxed{\text{outer}(\pm) = \J{ALL}|\J{EXI}}
  \[\begin{array}{rclr}
    \\
    \text{outer}(+) 
    &=& 
    \J{EXI} 
    & \C{positive} 
    \\
    \text{outer}(-) 
    &=& 
    \J{ALL} 
    & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\text{inner}(\pm) = \J{ALL}|\J{EXI}}
  \[\begin{array}{rclr}
    \\
    \text{inner}(+) 
    &=& 
    \J{ALL} 
    & \C{positive} 
    \\
    \text{inner}(-) 
    &=& 
    \J{EXI} 
    & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\text{quantify}^{\pm}(\Alpha, \Delta, \Alpha, \Delta, \tau) = \tau}
  \[\begin{array}{rclr}
    \text{quantify}^{\pm}(\epsilon, \epsilon, \epsilon, \epsilon, \tau) 
    &=& 
    \tau
    \\
    \text{quantify}^{\pm}(\epsilon, \epsilon, \Alpha_i, \Delta_i, \tau) 
    &=& 
    \text{inner}(\pm)\J{[}\Alpha_i\J{ }\Delta_i\J{]}\tau
    \\
    \text{quantify}^{\pm}(\Alpha_o, \Delta_o, \epsilon, \epsilon, \tau) 
    &=& 
    \text{outer}(\pm)\J{[}\Alpha_o\J{ }\Delta_o\J{]}\tau
    \\
    \text{quantify}^{\pm}(\Alpha_o, \Delta_o, \Alpha_i, \Delta_i, \tau) 
    &=& 
    \text{outer}(\pm)\J{[}\Alpha_o\J{ }\Delta_o\J{]}
    \text{inner}(\pm)\J{[}\Alpha_i\J{ }\Delta_i\J{]}
    \tau
  \end{array}\]
\end{definition}


\begin{definition}\boxed{\Alpha, \Delta \entails \Delta \wr \Delta}
  \begin{mathpar}
    \inferrule {
    } {
      \Alpha_z, \epsilon \entails \epsilon \wr \epsilon 
    }

    \inferrule {
      \text{FTV}(\tau_l)\ \text{FTV}(\tau_r) = \Alpha_q
      \\
      \forall \alpha .\ \alpha \in \Alpha_q \implies \alpha \in \Alpha_z
      \\
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
    } {
      \Alpha_z, \Delta \ \tau_l<:\tau_r \entails \Delta_o \ \tau_l<:\tau_r \wr \Delta_i 
    }

    \inferrule {
      \text{FTV}(\tau_l)\ \text{FTV}(\tau_r) = \Alpha_q
      \\
      \alpha \in \Alpha_q \\ \alpha \notin \Alpha_z
      \\
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
    } {
      \Alpha_z, \Delta \ \tau_l<:\tau_r \entails \Delta_o \wr \Delta_i \ \tau_l<:\tau_r
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\VDash e}
  \label{def:expression_good_formation}
  \begin{mathpar}
    \inferrule {
      e = v
    } {
      \VDash e
    } 

    \inferrule { 
      e \rightsquigarrow e' 
      \\
      \VDash e'
    } {
      \VDash e
    } 
  \end{mathpar}
\end{definition}

\begin{theorem}(Typing Soundness)
  \label{theorem:typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \entails e \hastype \tau \given Z
    } {
      \VDash e
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } \entails e \hastype \tau \given Z$
    \item \Z $\B{let } \vec{\delta}\ \Gamma' \ \tau' \B{ s.t. } \vec{\delta}, \Gamma' \satisfies e \hastype \tau'$ by \D{Lemma \ref{theorem:proof_typing_soundness}}
    \item \Z $\vec{\delta}, \vec{\sigma} \satisfies \Gamma'$ by ...
    \item \Z $\VDash e[\vec{\sigma}]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $e[\vec{\sigma}] = e$ by ...
    \item \Z $\VDash e$ by substitution 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof typing consistency)
  \label{theorem:proof_typing_consistency}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \vec{\delta} .\ \vec{\delta} \satisfies Z
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\begin{theorem}(Proof typing soundness)
  \label{theorem:proof_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}


\begin{theorem}(Proof typing weak soundness)
  \label{theorem:proof_typing_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \forall \vec{\delta} .\ \vec{\delta} \satisfies Z \implies \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}

  \TODO{rewrite inductive hypotheses with just the conclusion implied by the case conditions}

  \TODO{rewrite cases with universal/implication in conclusion/hypotheses}

  Proof: 
  \item $
    \B{assume } 
    \Gamma \entails e \hastype \tau \given Z 
  $ 
    \item \Z $\B{induct on } \Gamma \entails e \hastype \tau \given Z$ 

    \item \Z $\B{case } e = \J{@} \I \tau = \J{@}$ 
      \item \Z\Z $\B{let } \vec{\delta}$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{@} \hastype \J{@}$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau$ by witness 

    \item \Z $\B{case } e = x \I \J{$x$:$\tau$} \in \Gamma$ 
    \item \Z $\B{wrt } x$ 
      \item \Z\Z $\B{let } \vec{\delta}$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies x \hastype \tau$  by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau$ by witness 

  \item \Z $\B{case } 
    \Gamma \entails e' \hastype \tau' \given Z
    \I
    \tau = \J{<$l$>$\tau'$}
    \I
    e = \J{<$l$>$e'$} 
  $ 
  \item \Z $\B{hypo } 
      \Gamma \entails e' \hastype \tau' \given Z  
      \implies
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau'
  $ 
  \item \Z $\B{wrt } e' \ \tau'$ 
    \item \Z\Z $\B{let } \vec{\delta} $ by definition
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau'
    $ by application
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \J{<$l$>$e'$} \hastype \J{<$l$>$\tau'$}
    $ by definition
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    $ by substitution
    \item \Z\Z $
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    $ by witness 

  \item \Z \TODO{remaining trivial introduction cases} 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item \Z $\B{case } $ 
  \item \Z $\B{hypo } $ 
  \item \Z $\B{wrt } $ 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %   \inferrule {
  %     \Gamma \entails R \hastype \tau_0 \given Z_0
  %     \\
  %     Z_0 \looparrowright Z_1
  %     \\
  %     \Gamma \entails e \hastype \tau_1 \given Z_1
  %   } {
  %     \Gamma \entails R\ \J{*$l$=$e$} \hastype \tau_0\ \J{\&}\ \J{$l$:$\tau_1$} \given Z_1
  %   }

  %   \inferrule {
  %     Z, \Gamma \entails F \liftfun \vec{\pi}, \Tau_n 
  %     \\
  %     \Gamma \entails \vec{\pi} \equiv \Tau 
  %   } {
  %     \Gamma \entails F \hastype \J{\&}(\Tau) \given Z
  %   }
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau_0 \subtypes \J{$l$->$\alpha$} \given Z_1
    \I
    e = \J{$e_0$.$l$} \I \tau = \alpha \I Z = Z_1
  $
   
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0 
    \implies 
    \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
  $ 
  \item \Z $\B{wrt } \vec{\delta}\ e' \ l \ \alpha \ \tau_0 \ Z_0 \ Z_1$ 

    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application

    \item \Z\Z $
      \B{let }
      M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \J{$l$->$\alpha$} \given M, \Delta
    $ by theorem \ref{theorem:proof_subtyping_choice}


    \item \Z\Z $
      \vec{\delta} \satisfies \tau_0  \subtypes \J{$l$->$\alpha$}
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness}
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \J{$l$->$\alpha$}
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \J{$e_0$.$l$} \hastype \alpha 
    $ by theorem \ref{theorem:model_subtyping_record_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by witness 


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \I
    e = \J{$e_0$($e_1$)} 
    \I 
    \tau = \alpha 
    \I
    Z = Z_2
  $ 
  \item \Z $ 
    Z_1 \looparrowright Z_2
    \I
    \tau_0 \subtypes \J{$\tau_1$->$\alpha$} \given Z_2
  $ 
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \implies 
    \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \implies 
    \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_1
  $ 
  \item \Z $\B{wrt } e_0\ e_1\ \alpha\ \tau_0\ \tau_1\ Z_0\ Z_1\ Z_2 $ 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_1
    $ by application

    \item \Z\Z $
      \B{let } M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \J{$\tau_1$->$\alpha$} \given \left<M, \Delta \right>
    $ by theorem \ref{theorem:proof_subtyping_choice} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \tau_0 \subtypes \J{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness} 
    \item \Z\Z $
      \vec{\delta} \satisfies e_0 \hastype \J{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \J{$e_0$($e_1$)} \hastype \alpha
    $ by theorem \ref{theorem:model_typing_implication_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by substitution 

  \item \Z $\B{case } 
    e = \J{loop($e'$)} 
  $ 
  \item \Z $\contin  
    \tau = \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFLFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$} 
  $
  \item \Z $\contin 
    Z = Z_0 
  $
  \item \Z $\contin  
    \Gamma \entails e' \hastype \J{$\alpha_{h^+}$->$\tau'$} \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau' \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
  $ 
  \item \Z $\contin  
    \text{FTV}(\Gamma) \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{hypo } 
    \forall \vec{\delta} .\ \vec{\delta} \satisfies Z_0 \implies
    \vec{\delta}, \Gamma \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau'$}
  $ 
  \item \Z $\B{wrt } e'\ \tau'\ \alpha_{h^+}\ \alpha_l\ \alpha_r\ \alpha_{h^-}\ \alpha_l'\ \alpha_r'\ \Tau\ Z_0\ Z_1 $ 
    \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies Z$
      \item \Z\Z\Z $\vec{\delta} \satisfies Z_0$ by substitution
      \item \Z\Z\Z $
        \vec{\delta}, \Gamma \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau'$}
      $ by instantiation and application
      \item \Z\Z\Z $
        \vec{\delta} \satisfies \tau' \subtypes 
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$}
      $ by theorem \ref{theorem:fixpoint_duality_soundness}

      \item \Z\Z\Z $
        \vec{\delta} \satisfies \tau' \subtypes \tau
      $ by substitution  

      \item \Z\Z\Z $
        \vec{\delta} \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau$}
      $ by theorem \ref{theorem:model_subtyping_elimination} 

      \item \Z\Z\Z $
        \vec{\delta} \satisfies \J{loop($e'$)} \hastype \tau 
      $ by theorem \ref{theorem:model_typing_implication_independence}

      \item \Z\Z\Z $
        \vec{\delta} \satisfies e \hastype \tau 
      $ by substitution 

    \item \Z\Z $
      \forall \vec{\delta} .\ \vec{\delta} \satisfies Z \implies \vec{\delta} \satisfies e \hastype \tau 
    $ by implication and generalization 

  \item \Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$
    by induction
  \item $\square$
\end{theorem}

\begin{theorem}(Fixpoint duality soundness (new))
  \label{theorem:fixpoint_duality_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \\
      \text{FTV}(\tau) \subseteq N
      \\
      \alpha_l \notin N
      \\
      \alpha_r \notin N
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \vec{\delta} \satisfies 
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\TODO{Cretin's corresponding theorem is Theorem 101 on p. 134}

\TODO{See how Cretin proves this without using subject reduction}

\begin{theorem}(Fixpoint duality soundness old)
  \label{theorem:fixpoint_duality_soundness_old}
  \begin{mathpar}
    \inferrule { 
      Z_0 \looparrowright Z_1
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \forall \tau .\ 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume }
    Z_0 \looparrowright Z_1
    \I
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $ 
  \item \Z $\B{induct on }
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{case }
    Z_1 = \epsilon \I \Tau = \epsilon
  $
    \item \Z\Z $\B{for } \tau$
      \item \Z\Z\Z $\B{assume }
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      $
        \item \Z\Z\Z\Z $
          \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given \epsilon 
        $ by substitution

        \item \Z\Z\Z\Z $
          \B{let } M\ \Delta\ \B{ s.t. } \left<M, \Delta\right> \in \epsilon 
        $ by theorem \ref{theorem:universe_proof_typing_worldly}  

        \item \Z\Z\Z\Z $\bot$ by theorem \ref{theorem:empty_containment_absurd}
      \item \Z\Z\Z $
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
        \implies
        \tau
        \subtypes
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
        \given Z_0
      $ by implication
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by generalization 
  \item \Z $\B{case }
    Z_1 = Z\ \left<M, \Delta \right> \I \Tau = \Tau_i\ \tau_i
  $
  \item \Z $\contin
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \J{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
  $
  \item \Z $\contin
    M, \Delta, \Delta \entails \alpha_{h^+} \subtypes \Tau_h
    \I
    M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
    \I
    M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
  $
  \item \Z $\contin
    \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\ \tau_r .\ \tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
  $
  \item \Z $\contin
    N \cup M \cup \text{FTV}(\Tau_l) \cup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
    \I
    \Delta \entails \Alpha \pitchfork \Delta_i  
  $
  \item \Z $\contin
    N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
  $
  \item \Z $\B{hypo }
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \J{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
    \implies
    \\
    \forall \tau .\ 
    \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z
    \implies
    \tau
    \subtypes
    \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
    \given Z_0
  $
  \item \Z $\B{wrt }
    Z\ M\ \Delta\ \Tau_i\ \tau_i
  $

    \item \Z\Z $\B{for } \tau \B{ assume }
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
    $
      \item \Z\Z\Z $
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z\ \left<M, \Delta\right>
      $ by substitution

      \item \Z\Z\Z $
        \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      $ by theorem \ref{theorem:proof_subtyping_decomposition}

      \item \Z\Z\Z $
        \tau
        \subtypes
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by instantiation and application 
      \item \Z\Z\Z $
        \tau
        \subtypes
        \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by theorem \ref{theorem:universe_proof_typing_fixpoint_extension}
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by implication and generalization 


  \item \Z $
    \forall \tau .\ 
    \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
    \implies
    \tau
    \subtypes
    \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    \given Z_0
  $ by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint extension)
  \label{theorem:universe_proof_typing_fixpoint_extension}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r$} 
      \\\\
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \cup M \cup \text{FTV}(\Tau_l) \cup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
    } {
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing case soundness)
  \label{theorem:universe_proof_typing_case_soundnes}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \cup M \cup \text{FTV}(\Tau_l) \cup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
    } {
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau_i$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint union)
  \label{theorem:universe_proof_typing_fixpoint_union}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau$)]$\alpha_r$} 
      \\
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau$]$\alpha_r$} 
    } {
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau\ \tau$)]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}\ Influential soundness 
  \label{theorem:influential_soundness}

  \TODO{Prove that any constraints on non-influential variables with have been transitively applied to the influential variables}

  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given M, \Delta
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      \text{FTV}(\tau) \subseteq \Alpha
      \\\\
      N, M, \Delta \cup \Delta' \given \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau
      \\
      N, M, \Delta_i \cup \Delta' \given \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau_i
    } {
      \vec{\delta} \satisfies \tau \subtypes \tau_i 
      \land
      \vec{\delta} \satisfies \tau_i \subtypes \tau
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

% \begin{theorem}(Universe proof typing implication expansion)
%   \label{theorem:universe_proof_typing_implication}
%   \begin{mathpar}
%     \inferrule { 
%       M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
%       \\
%     } {
%       \J{\&$(\Tau_l)$->|$(\Tau_r)$}
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:(\&$(\Tau_l)$,|$(\Tau_r)$)]$\alpha_r$} 
%       \given M, \Delta
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Universe proof typing implication expansion)
  \label{theorem:universe_proof_typing_implication_expansion}
  \begin{mathpar}
    \inferrule { 
    } {
      \J{$\tau_l$->$\tau_r$}
      \subtypes
      \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:($\tau_l$,$\tau_r$)]$\alpha_r$} 
      \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\forall x \in X .\ \exists y .\ (x,y) \in (X \times Y)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\neg (\exists x \in X \land \nexists y \in Y)$} 
  \item $\square$
\end{theorem}

\begin{theorem}(Upper bound interpretation sound)
  \label{theorem:upper_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \alpha \subtypes \Tau 
    } {
     \alpha \subtypes \J{\&$(\Tau)$} \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Lower bound interpretation sound)
  \label{theorem:lower_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \Tau \subtypes \alpha
      \\
    } {
     \J{|$(\Tau)$} \subtypes \alpha \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Universe proof typing worldly)
  \label{theorem:universe_proof_typing_worldly}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta\ .\ \left<M, \Delta\right> \in Z
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Empty containment absurd)
  \label{theorem:empty_containment_absurd}
  \begin{mathpar}
    \inferrule { 
      \left<M, \Delta\right> \in \epsilon 
    } {
      \bot
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing implication independence)
  \label{theorem:model_typing_implication_independence}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \J{$\tau_l$->$\tau_r$} 
      \\
      \vec{\delta} \satisfies \tau_r
    } {
      \vec{\delta}, \Gamma \satisfies \J{loop($e$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


% \begin{theorem}(Proof typing fix interpolation weakest pre-condition)
%   \label{theorem:fix_duality}
%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \J{$\alpha_0$->$\alpha_1$->$\alpha_2$} \given Z_1
%       \\\\
%       \text{FTV}(\Gamma) \entails \alpha_0 \cdot Z_1 \cdot \J{$\alpha_1$->$\alpha_2$} \fallingdotseq \alpha_3 \circlearrowright \Tau_{rel}
%     } {
%       \J{ALL[$\alpha_4$]$\alpha_4$->EXI[$\alpha_5$.($\alpha_4$,$\alpha_5$)<:LFP[$\alpha_3$.|$(\Tau_{rel})$]]$\alpha_5$} 
%       \subtypes
%       \J{$\alpha_1$->$\alpha_2$}
%       \given Z_1
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Proof subtyping decomposition)
  \label{theorem:proof_subtyping_decomposition}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z\ \left<M, \Delta\right>
    } {
      \tau_l \subtypes \tau_r \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Proof subtyping choice)
  \label{theorem:proof_subtyping_choice}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta .\ \tau_l \subtypes \tau_r \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Model subtyping elimination)
  \label{theorem:model_subtyping_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \vec{\delta}, \Gamma \satisfies e \hastype  \tau_l  
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_r 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    \I
    \vec{\delta}, \Gamma \satisfies e \hastype  \tau_l  
  $
  \item \Z $\B{invert on } \vec{\delta} \satisfies \tau_l \subtypes \tau_r$
  \item \Z $\B{case } \forall e'\ \Gamma' .\ \vec{\delta}, \Gamma' \satisfies e' \hastype  \tau_l  \implies \vec{\delta}, \Gamma' \satisfies e' \hastype \tau_r$
  \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype  \tau_l  \implies \vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by instantiation
  \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by application 
  \item \Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by inversion
  \item $\square$ by implication
\end{theorem}


\begin{theorem}(Model typing record elimination)
  \label{theorem:model_subtyping_record_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
    } {
      \vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \vec{\delta}, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
  $ 
    \item \Z $\B{induct on } 
      \vec{\delta}, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
    $ 
    \item \Z $\B{case }
      e = G
      \I
      \J{?$l$=>$v$} \in G
      \I
      \vec{\delta}, \Gamma \satisfies v \hastype \tau
      \I
      \forall v' .\ \J{?$l$=>$v'$} \in G \implies v' = v 
    $ 
    \item \Z $\B{wrt }
      G\ v 
    $
  
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies G \hastype \J{$l$->$\tau$}
      $ by substitution

      \item \Z\Z $
        \J{$G$.$l$} \rightsquigarrow v
      $ by definition 

      \item \Z\Z $
        \B{let } \vec{\sigma} \B{ s.t. } \vec{\delta}, \Gamma \satisfies \vec{\sigma} 
      $ by theorem \ref{...} 
      \item \Z\Z $
        \J{$G$.$l$}[\vec{\sigma}] \rightsquigarrow v
      $ by definition 
      \item \Z\Z $
        v = v[\vec{\sigma} \cup \epsilon] 
      $ by definition 
      \item \Z\Z $
        \J{$G$.$l$}[\vec{\sigma}] \rightsquigarrow v[\vec{\sigma} \cup \epsilon] 
      $ by substitution 
      \item \Z\Z $
        \vec{\delta}, \epsilon \satisfies \epsilon 
      $ by definition 

      \item \Z\Z $
        \vec{\delta}, \Gamma \cup \epsilon \satisfies v \hastype \tau
      $ by definition 
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies \J{$G$.$l$} \hastype \tau 
      $ by definition 
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
      $ by substitution


    \item \Z $\B{case }
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
      \I
      e[\vec{\sigma}] \rightsquigarrow e'[\vec{\sigma} \cup \vec{\sigma}']
      \I
      \vec{\delta}, \vec{\sigma}' \satisfies \Gamma'
      \I
      \vec{\delta}, \Gamma \cup \Gamma' \satisfies e' \hastype \J{$l$->$\tau$}
    $
    \item \Z $\B{hypo }
      \vec{\delta}, \Gamma \cup \Gamma' \satisfies e' \hastype \J{$l$->$\tau$}
      \implies
      \vec{\delta}, \Gamma \cup \Gamma' \satisfies \J{$e'$.$l$} \hastype \tau
    $
    \item \Z $\B{wrt }
      \vec{\sigma}\ e'\ \vec{\sigma}'\ \Gamma'
    $
      \item \Z\Z $
        \vec{\delta}, \Gamma \cup \Gamma' \satisfies \J{$e'$.$l$} \hastype \tau
      $ by application
      \item \Z\Z $
        \J{$e[\vec{\sigma}]$.$l$} \rightsquigarrow \J{$e'[\vec{\sigma} \cup \vec{\sigma}']$.$l$}
      $ by definition 
      \item \Z\Z $
        \J{$e[\vec{\sigma}]$.$l$} = \J{$e$.$l$}[\vec{\sigma}]
      $ by definition 
      \item \Z\Z $
        \J{$e'[\vec{\sigma} \cup \vec{\sigma}']$.$l$} = \J{$e'$.$l$}[\vec{\sigma} \cup \vec{\sigma}']
      $ by definition 
      \item \Z\Z $
        \J{$e$.$l$}[\vec{\sigma}] \rightsquigarrow \J{$e'$.$l$}[\vec{\sigma} \cup \vec{\sigma}']
      $ by substitution 
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
      $ by definition 

    \item \Z $
      \vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
    $ by induction 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof subtyping consistency)
  \label{theorem:proof_subtyping_consistency}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \vec{\delta} .\ 
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
\end{theorem}

\begin{theorem}(Proof subtyping soundness)
  \label{theorem:proof_subtyping_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \vec{\delta} .\ 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}
\end{theorem}


\begin{theorem}(Proof subtyping weak soundness)
  \label{theorem:proof_subtyping_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \forall \vec{\delta} .\ 
      \vec{\delta} \satisfies \Delta
      \implies
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}

\TODO{closed variabless simply remove variables from soundness consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (EXI[X . 1 <: X, X <: 3] X) <: 2  -| 1 <: X, X <: 3, ..., X <: 2  
% FAILS, not considered for soundness
% (EXI[X . 1 <: X, X <: 2] X) <: 2  -| 1 <: X, X <: 2, ..., X <: 2  
% PASSES, is considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2 <: (EXI[X . 1 <: X, X <: 3] X)  -| 2 <: X, ..., 1 <: X, X <: 3 
% PASSES, is considered for soundness
% 2 <: (EXI[X . X <: 1 ] X)  -| 2 <: X, ..., X <: 1
% FAILS, not considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Proof: 
  \item \TODO{think about how to handle the mutually recursive definition} 
  \item $\B{assume } 
    \tau_l \subtypes \tau_r \given M, \Delta 
  $
    \item \Z $\B{induct on } \tau_l \subtypes \tau_r \given M, \Delta$

    \item \Z $\B{case } \tau_l = \tau \I \tau_r = \tau$
    \item \Z $\B{wrt } \tau $
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau \subtypes \tau$
        by theorem \ref{theorem:model_typing_reflexivity}
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_l = \J{BOT}$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \J{BOT} \subtypes \tau_r$ by definition
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_r = \J{TOP}$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \J{TOP}$ by definition
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } 
      \tau_r = \J{$l$->($\tau_{rl}$\&$\tau_{rr}$)}
      \I
      \tau_l
      \subtypes
      \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
      \given M, \Delta
    $
    \item \Z $\B{hypo }
      \forall \vec{\delta} .\ 
      \vec{\delta} \satisfies \Delta
      \implies
      \vec{\delta} \satisfies \tau_l \subtypes \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
    $ 
    \item \Z $\B{wrt } l\ \tau_{rl}\ \tau_{rr}$ 
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
        by application
        \item \Z\Z\Z $\B{for } e\ \Gamma \B{ assume } \vec{\delta}, \Gamma \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
          by theorem \ref{theorem:model_typing_subsumption} 
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \J{$l$->$\tau_{rl}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \J{$l$->$\tau_{rr}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \tau_{rl}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \tau_{rr}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies \J{$e$.$l$} \hastype \J{$\tau_{rl}$\&$\tau_{rr}$}$ by definition
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \J{$l$->($\tau_{rl}$\&$\tau_{rr}$)}$ by theorem \ref{theorem:model_typing_record_introduction} 
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e\ \Gamma .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau_l \implies 
          \vec{\delta}, \Gamma \satisfies e \hastype \tau_r
        $ by implication and generalization
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$
        by definition 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 


    \item \Z $\B{case } 
      \tau_l = \J{$\tau_{ll}$|$\tau_{lr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      \tau_{ll} \subtypes \tau_r
      \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_{lr} \subtypes \tau_r
      \given M_1, \Delta_1
    $

    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies \tau_{ll} \subtypes \tau_r
      \I
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies \tau_{lr} \subtypes \tau_r
    $
    \item \Z $\B{wrt } \tau_{ll}\ \tau_{lr}$

      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } M, \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_{lr} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0$ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_{ll} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \J{$\tau_{ll}$|$\tau_{lr}$} \subtypes \tau_r$ 
        by definition
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
        by substitution 

      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \J{$\tau_{rl}$\&$\tau_{rr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin 
      \tau_l \subtypes \tau_{rl} \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_{rr} \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_{rl} 
      \I
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_{rr} 
    $
    \item \Z $\B{wrt } $
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_{rr}$ by instantiation and application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0 $ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_{rl}$ by instantiation and application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \J{$\tau_{rl}$\&$\tau_{rr}$}$ by definition 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization


    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \J{($\tau_{ra}$->$\tau_{rc}$)\&($\tau_{rb}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes 
    %   \J{$\tau_{ra}$|$\tau_{rb}$->$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \J{($\tau_{ra}$->$\tau_{rb}$)\&($\tau_{ra}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \J{$\tau_{ra}$->$\tau_{rb}$\&$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } 
      \tau_l = \J{EXI[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A \notfree \tau_r
      \I
      M_0 \cup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_b \subtypes \tau_r
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies M_1, \tau_b \subtypes \tau_r 
    $
    \item \Z $\B{mutu } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_b \subtypes \tau_r$ by application
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0 $ by theorem \ref{theorem:model_subtyping_sequence_prefix}
        \item \Z\Z\Z $\vec{\delta} \satisfies Q$ by application
        \item \Z\Z\Z $\B{for } e \B{ assume } \vec{\delta} \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \J{EXI[$\Alpha$ $Q$]$\tau_b$}$ by substitution
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \tau_r$ by theorem \ref{theorem:model_typing_existential_elimination} 
        \item \Z\Z\Z $\forall e .\ \vec{\delta} \satisfies e \hastype \tau_l 
          \implies \vec{\delta} \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \J{ALL[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A \notfree \tau_l
      \I
      M_0 \cup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_b
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_b 
    $
    \item \Z $\B{mutu } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_b$ by application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0$ by theorem \ref{theorem:model_subtyping_sequence_prefix} 
        \item \Z\Z\Z $\vec{\delta} \satisfies Q$ by application 
        \item \Z\Z\Z $\B{for } e \B{ assume } \vec{\delta} \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \J{ALL[$\Alpha$ $Q$]$\tau_b$}$ by theorem \ref{theorem:model_typing_universal_introduction} 
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e .\ \vec{\delta} \satisfies e \hastype \tau_l 
          \implies \vec{\delta} \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization
      \item \Z\Z \TODO{...} 

% e :  ALL[a b . 3 <: a ] (a,b) \implies e : (a,b)
    \item \Z $\B{case } 
      \tau_l = \alpha
      \I
      M = M_1
      \I
      \Delta = \Delta_1\ \alpha <: \tau_r
    $
    \item \Z $\contin
      \alpha \notin M_0
      \I
      M_0, \Delta_0 \entails \Delta_m <:^\sharp \alpha \slash \tau_r
      \I
      M_0, \Delta_0 \entails \Tau <:^\dagger \alpha
      \I
      M_0 \preceq M_1
    $
    \item \Z $\contin
      \Delta_0 \cup \Delta_m \preceq \Delta_1
      \I
      \J{|$(\Tau)$} <: \tau_r \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies
      \vec{\delta} \satisfies \J{|$(\Tau)$} <: \tau_r
    $
    \item \Z $\B{wrt } \alpha\ M_1\ \Delta_1\ M_0\ \Delta_0\ \Delta_m\ \Tau$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1 \J{($\alpha$<:$\tau_r$)}$ by substitution
        \item \Z\Z\Z $\vec{\delta} \satisfies \alpha <: \tau_r$ by theorem \ref{theorem:model_subtyping_sequence_last} 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l <: \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \notin M_0
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot M
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot \Delta_{skol}
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Tau 
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Delta_{rel}
    %   \\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \widebar{\J{.$\tau_0[\alpha\slash\tau_l]$<:$\tau_1$}}^{\tau_0<:\tau_1 \in \Delta_{rel}} \cup \widebar{\J{.$\tau_l$<:$\tau$}}^{\tau \in \Tau}
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    %   \cup \widebar{\tau_l<:z}^{z \in M}
    %   \cup \widebar{\tau[\alpha\slash\tau_l]<:z}^{\tau<:z \in \Delta_{skol}} \ \tau_l<:\alpha 
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \alpha <: \tau \in (\Delta_0 \cup \text{factor}(\Delta_0, \alpha))
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau \subtypes \tau_r
    %   \given M_1, \Delta_1
    % } {
    %   \alpha \subtypes \tau_r
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \tau <: \alpha \in \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau_l \subtypes \tau
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q
    %   \given M_1, \Delta_1
    % } {
    %   \J{ALL[$\Alpha$ $Q$]$\tau_l$}
    %   \subtypes 
    %   \tau_r
    %   \given M_1, \Delta_1 
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r
    %   \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q \given M_1, \Delta_1
    % } {
    %   \tau_l
    %   \subtypes 
    %   \J{EXI[$\Alpha$ $Q$]$\tau_r$}
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{ll} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \J{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{lr} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \J{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rl}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \J{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rr}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \J{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
    by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem} Model typing existential elimination 
  \label{theorem:model_typing_existential_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies e \hastype \J{EXI[$\Alpha$ $Q$]$\tau_l$}
      \\
      \vec{\delta} \satisfies Q
      \\
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha \notfree \tau_r
    } {
      \vec{\delta} \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: 
% depends on proof subtyping 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ... |= 2 : (EXI[X . 1 <: X, X <: 3] X)
% X/1 |= 1 <: X, X <: 3
% -------------------------
% X/1 |= 2 : 1 (FAIL) 
% -------------------------
% X/1 |= 2 : 4  (PASS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% X <: 4  -| X, 1 <: X, X <: 3

\end{theorem}

\begin{theorem} Model typing universal introduction 
  \label{theorem:model_typing_universal_introduction}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l
      \\
      \vec{\delta} \satisfies Q
      \\
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha \notfree \tau_l
    } {
      \vec{\delta} \satisfies e \hastype \J{ALL[$\Alpha$ $Q$]$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}
\end{theorem}





\begin{theorem} Model subtyping sequence last 
  \label{theorem:model_subtyping_sequence_last}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta\ \J{($\tau_l$<:$\tau_r$)}
    } {
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence reduction 
  \label{theorem:model_subtyping_sequence_reduction}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta\ \delta
    } {
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence prefix  
  \label{theorem:model_subtyping_sequence_prefix}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta'
      \\
      \Delta \preceq \Delta'
    } {
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence uncat 
  \label{theorem:model_subtyping_sequence_uncat}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta \cup \Delta'
    } {
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} concatenation prefix 
  \label{theorem:concatenation prefix}
  \begin{mathpar}
    \inferrule { 
    } {
      \Delta \preceq \Delta \cup \Delta'
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model subtyping unsub left 
  \label{theorem:Modle_subtyping_unsub_left}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_l \in \vec{\delta}
    } {
      \vec{\delta} \satisfies \alpha \subtypes \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping unsub right 
  \label{theorem:Modle_subtyping_unsub_right}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_r \in \vec{\delta}
    } {
      \vec{\delta} \satisfies \tau_l \subtypes \alpha
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping something 
  \label{theorem:Modle_subtyping_something}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta 
      \\
      M, \Delta \entails \Tau \subtypes^\sharp \alpha  
    } {
      \alpha\slash\J{|$(\Tau)$} \in \vec{\delta}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem} Model typing record introduction 
  \label{theorem:model_typing_record_introduction}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \J{$e$.$l$} \hastype \tau
    } {
      \vec{\delta} \satisfies e \hastype \J{$l$->$\tau$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing implication introduction 
  \label{theorem:model_typing_implication_introduction}
  \TODO{this is really messed up}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \J{$e_0$($e_1$)} \hastype \tau_r
      \\
      \vec{\delta} \satisfies e_1 \hastype \tau_l
      \\
      \forall \tau .\ \vec{\delta} \satisfies e_1 \hastype \tau \implies \tau_l \subtypes \tau
    } {
      \vec{\delta} \satisfies e_0 \hastype \J{$\tau_l$->$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing intersection elimination 
  \label{theorem:model_typing_intersection_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l \& \tau_r
    } {
      \vec{\delta} \satisfies e \hastype \tau_l 
      \land
      \vec{\delta} \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model typing reflexivity
  \label{theorem:model_typing_reflexivity}
  \begin{mathpar}
    \inferrule { 
    } {
      \vec{\delta} \satisfies \tau \subtypes \tau
    } 
  \end{mathpar}
  Proof:
  \item $\B{for } e\ \Gamma \B{ assume } \vec{\delta}, \Gamma \satisfies e \hastype \tau$
    \item \Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ by identity
  \item $\forall e\ \Gamma .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau \implies \vec{\delta}, \Gamma \satisfies e \hastype \tau$
  by implication and generalization
  \item $\square$ by definition
\end{theorem}


\begin{theorem}(Model typing subsumption)
  \label{theorem:model_typing_subsumption}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
      \\
      \vec{\delta}, \Gamma \satisfies \tau_l <: \tau_r
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
  \I \vec{\delta}, \Gamma \satisfies \tau_l <: \tau_r
  $
    \item \Z $\B{invert on}\ \vec{\delta}, \Gamma \satisfies \tau_l <: \tau_r$
    \item \Z $\B{case}\ \forall e' .\ \vec{\delta}, \Gamma \satisfies e' : \tau_l \implies \vec{\delta}, \Gamma \satisfies e' : \tau_r$
      \item \Z\Z $\forall e' .\ \vec{\delta}, \Gamma \satisfies e' : \tau_l \implies \vec{\delta}, \Gamma \satisfies e' : \tau_r$ by identity
    \item \Z $\forall e' .\ \vec{\delta}, \Gamma \satisfies e' : \tau_l \implies \vec{\delta}, \Gamma \satisfies e' : \tau_r$ by inversion
    \item \Z $\vec{\delta}, \Gamma \satisfies e : \tau_l \implies \vec{\delta}, \Gamma \satisfies e : \tau_r$ by instantiation 
    \item \Z $\vec{\delta}, \Gamma \satisfies e : \tau_r$ by application
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}(Model typing implication elimination)
  \label{theorem:model_typing_implication_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r
      \\
      \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_l
    } {
      \vec{\delta}, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume }
    \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r
    \I 
    \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_l
  $ 

    \item \Z $\B{let } \vec{\sigma} \B{ s.t. } \vec{\delta}, \vec{\sigma} \satisfies \Gamma$ by theorem \ref{...}
    \item \Z $\B{induct on } \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r$

    \item \Z $\B{case }$ \TODO{...}

    % \inferrule { 
    %   \vec{\delta}, \Gamma \cup \Gamma' \satisfies p \pattype \tau_p
    %   \\
    %   \vec{\delta}, \Gamma \cup \Gamma'  \satisfies e \hastype \tau_r
    %   \\\\
    %   \forall e .\ 
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
    %     \implies
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_p 
    %     \land
    %     (\forall \tau_n\ \tau .\ \vec{\delta}, \Gamma \satisfies F \hastype \J{$\tau_n$->$\tau$} \implies \neg (\vec{\delta}, \Gamma \satisfies e \hastype \tau_n))
    % } {
    %   \vec{\delta}, \Gamma \satisfies \J{$F$*$p$=>$e$} \hastype \J{$\tau_l$->$\tau_r$}
    % }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \inferrule { 
    %   \vec{\delta}, \Gamma \satisfies F \hastype \J{$\tau_l$->$\tau_r$}
    % } {
    %   \vec{\delta}, \Gamma \satisfies \J{$F$*$p$=>$e$} \hastype \J{$\tau_l$->$\tau_r$}
    % } 
    \item \Z $\B{case }
      e_0 = \J{$F$?$p$=>$e_2$}
      \I
      \vec{\delta}, \Gamma \satisfies F \hastype \J{$\tau_l$->$\tau_r$}
    $ 
    \item \Z $\B{hypo }
      \vec{\delta}, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
    $
    \item \Z $\B{wrt }
      F\ p\ e_2 
    $
      \item \Z\Z $\VDash \J{$F$($e_1$)}[\vec{\sigma}] $
      by theorem \ref{theorem:model_typing_soundness}
      \item \Z\Z $\B{invert on } \VDash \J{$F$($e_1$)}[\vec{\sigma}]$
      \item \Z\Z $\B{case } \J{$F$($e_1$)}[\vec{\sigma}] = v$
      \item \Z\Z $\B{wrt } v$
        \item \Z\Z\Z $\J{$F$($e_1$)}[\vec{\sigma}] \neq v$ by definition 
        \item \Z\Z\Z $\bot$ by application
      \item \Z\Z $\B{case } 
        (\J{$F$($e_1$)})[\vec{\sigma}] \rightsquigarrow e_3
        \I
        \vec{\delta}, \Gamma \satisfies e_3 \hastype \tau_r
      $
      \item \Z\Z $\B{wrt } e_3$
        \item \Z\Z\Z $(\J{$F$($e_1$)})[\vec{\sigma}] = \J{$F[\vec{\sigma}]$($e_1[\vec{\sigma}]$)}$ by definition
        \item \Z\Z\Z $\J{$F[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\B{let } F' \B{ s.t. } F[\vec{\sigma}] = F'$ by theorem \ref{...} \TODO{...}
        \item \Z\Z\Z $\B{let } e_1' \B{ s.t. } e_1[\vec{\sigma}] = e_1'$ by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\text{FV}(e_2[\vec{\sigma}\backslash\text{FV}(p)]) \subseteq \text{FV}(p)$ 
        by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\J{$F'$($e_1'$)} \rightsquigarrow e_3$ by substitution 
        \item \Z\Z\Z $\J{($F'$?$p$=>$e_2[\vec{\sigma}\backslash\text{FV}(p)]$)($e_1'$)} \rightsquigarrow e_3$ by definition 
        \item \Z\Z\Z $(\J{$F[\vec{\sigma}]$?$p$=>$e_2[\vec{\sigma}\backslash\text{FV}(p)]$)($e_1[\vec{\sigma}]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $(\J{($F$?$p$=>$e_2$)($e_1$)})[\vec{\sigma}] = \J{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\text{FV}(p)]$)($e_1[\vec{\sigma}]$)}
        $ by definition
        \item \Z\Z\Z $(\J{($F$?$p$=>$e_2$)($e_1$)})[\vec{\sigma}] \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% OLD 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \item \Z $\B{case }
    %   \vec{\delta}, \Gamma \cup \Gamma' \satisfies p \hastype \tau_l
    %   \I
    %   \vec{\delta}, \Gamma \cup \Gamma'  \satisfies e \hastype \tau_r
    % $
    % \item \Z $ 
    %   \contin
    %   F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r
    %   \I
    %   e_0 = \J{($F$?$p$=>$e$)} 
    % $
    % \item \Z $
    %   \B{hypo} \  \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r \implies \vec{\delta}, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
    % $
    % \item \Z $
    %   \B{wrt} \ F \ p \ e \ \Gamma' \  
    % $
    %   \item \Z\Z $F = \epsilon \lor \vec{\delta}, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r$ by application
    %   \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r$ by substitution 
    %   \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_reduced_implication_elimination}
    %   \item \Z\Z $\vec{\delta}, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ by substitution 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \item \Z $\B{case }
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
      \I
      e_0[\vec{\sigma}] \rightsquigarrow e_0'
      \I
      \vec{\delta}, \Gamma \satisfies e_0' \hastype \tau_l \J{->} \tau_r
    $
    \item \Z $\B{hypo}\ 
      \vec{\delta}, \Gamma \satisfies e_0' \hastype \tau_l \J{->} \tau_r
      \implies
      \vec{\delta}, \Gamma \satisfies \J{$e_0'$($e_1$)} \hastype \tau_r
    $
    \item \Z $ 
    \B{wrt}\ \vec{\sigma}\ e_0' 
    $
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e_0'\J{(}e_1\J{)} \hastype \tau_r$ by application 
      \item \Z\Z $e_0[\vec{\sigma}]\J{(}e_1\J{)} \rightsquigarrow e_0'\J{(}e_1\J{)}$
      \item \Z\Z ($e_0\J{(}e_1\J{)})[\vec{\sigma}] \rightsquigarrow e_0'\J{(}e_1\J{)}$
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ 

    \item \Z $\vec{\delta}, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ by induction
  \item $\square$
\end{theorem}

\begin{theorem}\ Model typing reduced implication elimination  

  \label{theorem:model_typing_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r
      \\
      \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_l
      \\
      F = \epsilon \lor \vec{\delta}, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
    } {
      \vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume } \VDash e_1[\vec{\sigma}]$


    \item \Z $\B{let } \vec{\sigma} \B{ s.t. } \vec{\delta}, \vec{\sigma} \satisfies \Gamma $ by theorem \ref{theorem:model_typing_assignability} 
    \item \Z $\VDash e_1[\vec{\sigma}]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $\B{induct on } \VDash e_1[\vec{\sigma}]$

    \item \Z $\B{case } e_1[\vec{\sigma}] = v_1 $
    \item \Z $\B{wrt } v_1$  
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_fully_reduced_implication_elimination}

    \item \Z $\B{case}\ e_1[\vec{\sigma}] \rightsquigarrow e_1' \I \VDash e_1'$
    \item \Z $\B{hypo}\ \VDash e_1' \implies \vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$
    \item \Z $\B{wrt}\ e_1' $

      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$ by application
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow \J{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1'$)}$ by definition 
      \item \Z\Z $\forall x .\ x \notin \B{FV}(e_1')$ by theorem \ref{theorem:reduction_closed} 
      \item \Z\Z $e_1' = e_1'[\vec{\sigma}]$ by by theorem \ref{theorem:closed_substitution} 
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow \J{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1'[\vec{\sigma}]$)}$ by substitution 
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow (\J{($F$?$p$=>$e$)($e_1'$)})[\vec{\sigma}]$ by definition 
      \item \Z\Z $\vec{\sigma} \cup \epsilon = \vec{\sigma}$ by definition 
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow (\J{($F$?$p$=>$e$)($e_1'$)})[\vec{\sigma} \cup \epsilon]$ by substitution 
      \item \Z\Z $\Gamma \cup \epsilon = \Gamma$ by definition
      \item \Z\Z $\vec{\delta}, \epsilon \satisfies \epsilon$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \cup \epsilon \satisfies \J{($F$?$p$=>$e$)($e_1'$)}$ by substitution 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by definition
    \item \Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by induction
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}\ Model typing fully reduced implication elimination 
  \label{theorem:model_typing_fully_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r
      \\
      F = \epsilon \lor \vec{\delta}, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
      \\
      \vec{\delta} \satisfies e_1 \hastype \tau_l
      \\
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
      \\
      e_1[\vec{\sigma}] = v_1
      \\
    } {
      \vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume}\ F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r$
    \TODO{add more assumptions}
    \item \Z $\vec{\delta} \satisfies e_1[\vec{\sigma}] \hastype \tau_l$ by theorem \ref{theorem:model_typing_valuation} 
    \item \Z $\vec{\delta} \satisfies v_1 \hastype \tau_l$ by substitution 
    \item \Z $\B{invert on}\ F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r$
    \item \Z $\B{case } F = \epsilon$ 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{$F$?$p$=>$e$} \hastype \tau_l \J{->} \tau_r$ by theorem \ref{theorem:model_typing_unwrapping} 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r$ by substitution 

      \item \Z\Z $\B{let}\ \vec{\sigma}' \B{ s.t. } p \equiv v_1 \given \vec{\sigma}'$ 
      by theorem \ref{theorem:model_typing_pattern_matching} 

      \item \Z\Z $\B{for } e'$ 
        \item \Z\Z\Z $\neg \epsilon[\vec{\sigma}]\J{($v_1$)} \rightsquigarrow e'$ by definition
        \item \Z\Z\Z $\neg F[\vec{\sigma}]\J{($v_1$)} \rightsquigarrow e'$ by substitution 
      \item \Z\Z $\forall e' .\ \neg F[\vec{\sigma}]\J{($v_1$)} \rightsquigarrow e'$ by generalization 

      \item \Z\Z $\J{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\vec{\sigma}\backslash\B{FV}(p)][\vec{\sigma}]$ by definition 

      \item \Z\Z $\forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\vec{\sigma}')$ 
      by theorem \ref{theorem:pattern_matching_consistency}
      \item \Z\Z $\vec{\sigma}\backslash\B{FV}(p) = \vec{\sigma}\backslash\B{dom}(\vec{\sigma}')$ 
      by theorem \ref{theorem:consistency_diffing}
      \item \Z\Z $e[\vec{\sigma}\backslash\B{dom}(\vec{\sigma}')][\vec{\sigma}'] = e[\vec{\sigma} \cup \vec{\sigma}']$ 
      by theorem \ref{theorem:concatenation_substitution}

      \item \Z\Z $\J{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\vec{\sigma}\backslash\B{dom}(\vec{\sigma}')][\vec{\sigma}]$ 
        by substitution
      \item \Z\Z $\J{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\vec{\sigma} \cup \vec{\sigma}']$ 
        by substitution 
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\vec{\sigma}]$($v_1$)} \rightsquigarrow e[\vec{\sigma} \cup \vec{\sigma}']$ by definition 
      \item \Z\Z $\J{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow e[\vec{\sigma} \cup \vec{\sigma}']$ by substitution  

      \item \Z\Z $\J{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} = (\J{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}]$ by definition  
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow e[\vec{\sigma} \cup \vec{\sigma}']$ by substitution  

      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition

    \item \Z $\B{case } \vec{\delta}, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r$ 
      \item \Z\Z $\B{let } e' \B{ s.t. } (\J{$F$($e_1$}))[\vec{\sigma}] \rightsquigarrow e' \land \vec{\delta}, \Gamma \satisfies e' \hastype \tau_r$ by theorem \ref{theorem:model_typing_function_progress}
      \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow e'$ by definition 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
    \item \Z $\vec{\delta}, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
  \item $\square$ by implication
\end{theorem}


\begin{theorem}\ (Pattern matching consistency)
  \label{theorem:pattern_matching_consistency}
  \begin{mathpar}
    \inferrule {
      p \equiv v \given \vec{\sigma}
    } {
      \forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\vec{\sigma})
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}\ (Consistency diffing)
  \label{theorem:consistency_diffing}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \in X_l \iff x \in X_r 
    } {
      \vec{\sigma}\backslash X_l = \vec{\sigma}\backslash X_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Concatenation Substitution )
  \label{theorem:concatenation_substitution}
  \begin{mathpar}
    \inferrule {
    } {
      e[\vec{\sigma}\backslash\B{dom}(\vec{\sigma}')][\vec{\sigma}'] = e[\vec{\sigma} \cup \vec{\sigma}']
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}(Model typing valuation)
  \label{theorem:model_typing_valuation}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau 
      \\
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
    } {
      \vec{\delta} \satisfies e[\vec{\sigma}] \hastype \tau 
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    \I
    \vec{\delta}, \vec{\sigma} \satisfies \Gamma
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing pattern matching)
  \label{theorem:model_typing_pattern_matching}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r
      \\
      \vec{\delta} \satisfies v \hastype \tau_l 
    } {
      \exists \vec{\sigma} .\  p \equiv v \given \vec{\sigma}
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \vec{\delta}, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r
    \I
    \vec{\delta} \satisfies v \hastype \tau_l 
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Well-formed function valuation)
  \label{theorem:wellformed_function_valuation}
  \begin{mathpar}
    \inferrule {
      \VDash F
    } {
      \exists v .\ v = F 
    } 
  \end{mathpar}
\end{theorem}
\begin{proof}
  \item $\B{assume } \VDash F$ 
    \item \Z $\B{invert on } \VDash F$
    \item \Z $\B{case } v = F$
      \item \Z\Z $v = F$ by identity
    \item \Z $\B{case } F \rightsquigarrow e$
    \item \Z $\B{wrt } e$
      \item \Z\Z $\neg F \rightsquigarrow e$ by definition
      \item \Z\Z $\bot$ by application 
    \item \Z $v = F$ by inversion 
  \item $\square$
\end{proof}


\begin{theorem}(Reduction closed)
  \label{theorem:reduction_closed}
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \forall x .\ x \notin \B{FV}(e')
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    e \rightsquigarrow e'
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Closed substitution)
  \label{theorem:closed_substitution}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \notin \B{FV}(e)
    } {
      e = e[\vec{\sigma}]
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \forall x .\ x \notin \B{FV}(e)
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}



% \begin{theorem}(Progress of pattern matching)
%   \label{theorem:pattern_matching_progress}
%   \begin{mathpar}
%     \inferrule {
%       \J{*$p$=>$e$} \in F 
%       \\
%       p \equiv v \given \vec{\sigma} 
%       \\
%       \forall e' .\ \J{*$p$=>$e'$} \in F \implies e' = e 
%     } {
%       \exists e' .\ F\J{(}v\J{)} \rightsquigarrow e'
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{for } p\ e\ F\ v\ \vec{\sigma}\ \B{assume }
%       \J{*$p$=>$e$} \in F 
%       \I
%       p \equiv v \given \vec{\sigma} 
%       \I
%       \forall e' .\ \J{*$p$=>$e'$} \in F \implies e' = e 
%   $

%   \item \Z $\B{case }
%     F = F'\ \J{*$p$=>$e$} 
%     \I
%     \J{*$p$=>$e$} \notin F'
%   $

%   \item \Z\Z $\B{for } e'$
%   \item \Z\Z\Z $\B{case}\ F'\J{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\J{(}F'\ \J{*}p\J{=>}e\J{)(} v \J{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z\Z\Z $F\J{(}v\J{)} \rightsquigarrow e'$ by substitution 
%   \item \Z\Z\Z $\B{case}\ \neg F'\J{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\J{(}F'\ \J{*}p\J{=>}e\J{)(} v \J{)} \rightsquigarrow e[\vec{\sigma}]$ by definition
%   \item \Z\Z\Z\Z $F\J{(}v\J{)} \rightsquigarrow e[\vec{\sigma}]$ by substitution 
%   \item \Z\Z\Z $\exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by decidability of $F'\J{($v$)} \rightsquigarrow e'$
%   \item \Z\Z $\forall e' .\ \exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by summarization
%   \item \Z\Z $\exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by independence 

%   \item \Z $\B{case }
%     F = F'\ f 
%     \I
%     \J{*$p$=>$e$} \in F' 
%   $
%   \item \Z\Z $\B{let } e' \B{ s.t. } F'\J{(}v\J{)} \rightsquigarrow e'$ by induction hypothesis
%   \item \Z\Z $F'\ f\J{(}v\J{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z $F\J{(}v\J{)} \rightsquigarrow e'$ by definition
%   \item \Z $\exists e' .\ F\J{(}v\J{)} \rightsquigarrow e'$ by induction on $\J{*$p$=>$e$} \in F$
%   \item $\square$
% \end{theorem}

\begin{theorem}(Model typing assignability)
  \label{theorem:model_typing_assignability}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } {
      \exists \vec{\sigma} .\ \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem}(Model typing soundness)
  \label{theorem:model_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } {
      \forall \vec{\sigma} .\ 
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
      \implies
      \VDash e[\vec{\sigma}]
    } 
  \end{mathpar}
  Proof:
  \item \TODO{redo using universal/implication}
  \item $\B{assume }
        \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
        \I \vec{\delta}, \Gamma \satisfies e \hastype \tau
  $
    \item \Z $\B{case } e = \J{@}$
      \item \Z\Z $\B{let } v \B{ s.t. } \J{@} = v$
      \item \Z\Z $e[\vec{\sigma}] = v$
      \item \Z\Z $ \VDash e[\vec{\sigma}]$


    \item \Z $\B{case } 
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau'
      \I 
      e = \J{<}l\J{>}e' 
      \I 
      \tau = \J{<}l\J{>}\tau'
    $
      \item \Z\Z $\Vdash e'$ by induction hypothesis
      \item \Z\Z $\B{case } e'[\vec{\sigma}] = v$
        \item \Z\Z\Z $\B{let } v' \B{ s.t. } \J{<}l\J{>}v = v'$
        \item \Z\Z\Z $\J{<}l\J{>}e'[\vec{\sigma}] = v'$
        \item \Z\Z\Z $(\J{<}l\J{>}e')[\vec{\sigma}] = v'$
        \item \Z\Z\Z $e[\vec{\sigma}] = v'$
        \item \Z\Z\Z $\VDash e[\vec{\sigma}] $

      \item \Z\Z $\B{case } e'[\vec{\sigma}] \rightsquigarrow e'' \I \VDash e''$
        \item \Z\Z\Z $\J{<}l\J{>}e'[\vec{\sigma}] \rightsquigarrow \J{<}l\J{>} e''$
        \item \Z\Z\Z $\VDash \J{<}l\J{>}e'' $
        \item \Z\Z\Z $\VDash \J{<}l\J{>}e'[\vec{\sigma}] $
        \item \Z\Z\Z $\VDash (\J{<}l\J{>}e')[\vec{\sigma}] $
        \item \Z\Z\Z $\VDash e[\vec{\sigma}] $

      \item \Z\Z $\VDash e[\vec{\sigma}] $ by cases on $\VDash e' $

    \item \Z \TODO{remaining introduction cases}

    \item \Z $\B{case } 
      x \hastype \tau \in \Gamma
      \I 
      x \slash v \in \vec{\sigma}
      \I 
      e = x
    $
      \item \Z\Z $x[\vec{\sigma}] = v$
      \item \Z\Z $e[\vec{\sigma}] = v$
      \item \Z\Z $\VDash e[\vec{\sigma}] $

    \item \Z $\B{case } 
      e[\vec{\sigma}] \rightsquigarrow e' 
      \I 
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau
    $ 
      \item \Z\Z $\VDash e'[\vec{\sigma}] $ by induction hypothesis
      \item \Z\Z $\VDash e[\vec{\sigma}] $

    \item \Z $\VDash e[\vec{\sigma}] $ by induction on $\vec{\delta}, \Gamma \satisfies e \hastype \tau$
  \item $\square$
  \item \TODO{Cretin's corresponding theorem is by definition of pretypes on p. 125}
\end{theorem}

\noindent
\B{NOTE: } The induction hypothesis includes the generalized assumption, e.g. $\forall e' .\ e' < e \implies Q(e')$ if inducting on $e$ or $\forall e' .\ (P(e') \implies P(e)), P(e') \implies Q(e')$ if inducting on predicate $P$

\noindent
\B{NOTE: } we induct on $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ instead of $e$, as the predicate acts as a guard/ordering in lieu of a decreasing e.
This allows us to use the induction hypothesis on the reduction step result in the elimination case.

\noindent
\B{NOTE: } Kozen says, "Intuitively, one can appeal to the coinductive hypothesis as long as there
has been progress in observing the elements of the stream (guardedness) and there is no
further analysis of the tails (opacity)".  Kozen demonstrates a legal proof by induction on infinite streams too

% \begin{theorem}(Progress of proof typing)
%   \label{theorem:proof_typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       e \B{ progressive}
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}

% \begin{theorem}(Preservation of proof typing)
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%       \\
%       e \rightsquigarrow e'
%     } {
%       \Gamma \entails e' \hastype \tau \given Z  
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}


\begin{definition}\boxed{\vec{\delta}, \vec{\sigma} \satisfies \Gamma}
  \label{def:model_typing_environment}
  \begin{mathpar}
    \inferrule { 
    } {
      \vec{\delta}, \vec{\sigma} \satisfies \epsilon  
    } 

    \inferrule { 
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
      \\
      \vec{\delta} \satisfies v \hastype \tau 
    } {
      \vec{\delta}, \vec{\sigma} \ x \slash v \satisfies \Gamma \ x:\tau 
    } 
  \end{mathpar}
\end{definition}


\end{document}