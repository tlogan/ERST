\documentclass[acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage[dvipsnames]{xcolor}
\usepackage{array}
\usepackage{wasysym}

\usepackage{pifont}% http://ctan.org/pkg/pifont

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\newcounter{pdc}
\newcounter{sdc}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={let, fix, in}
}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]
% \newtheorem{proof}{Proof}[section]

\newtheorem{experiment}{Experiment}[section]


\title{Extrinsic Type Inference (DRAFT 2025-05-25)}
\author{Thomas Logan}

\begin{document}

\newcommand{\pdc}{\stepcounter{pdc}\arabic{pdc}}
\newcommand{\sdc}{\stepcounter{sdc}\arabic{sdc}}

\newcommand{\Par}[1]{\paragraph{\textbf{#1}}}
\newcommand*{\code}{\fontfamily{pcr}\selectfont}
\newcommand{\J}[1]{\texttt{\code #1}}
\newcommand{\lab}[1]{\text{\color{Gray}\ [#1]}}
\newcommand{\entails}{\vdash}
\newcommand{\satisfies}{\vDash}
\newcommand{\given}{\dashv}
\newcommand{\with}{\ \diamond\ }
\newcommand{\notfree}{\ \#\ }
\newcommand{\consis}{\ \star}
\newcommand{\safe}{\ \checkmark}
\newcommand{\relational}{\ \Re}


% \newcommand{\cmark}{\ding{51}}%
% \newcommand{\xmark}{\ding{55}}%
\newcommand{\pass}{\text{\normalsize \color{Green} \ding{51}}}
\newcommand{\assisted}{\text{\normalsize \color{Purple} \ding{45}}}
\newcommand{\fail}{\text{\normalsize \color{red} \ding{55}}}

\newcommand{\unique}{\ \dagger}

\newcommand{\factorsinto}{\Vvdash}


\newcommand{\allsafe}{\ \Re\checkmark}

\newcommand{\qua}{\ .\ }



\newcommand{\ignore}{\varnothing}
\newcommand{\dTheta}{\dot{\Theta}}
\newcommand{\closed}{\bullet}
\newcommand{\local}{\blacktriangle}
\newcommand{\open}{\circ}



\newcommand{\up}{\ \land\ }
\newcommand{\down}{\ \lor\ }

% \newcommand{\tl}{\textasciitilde{}}

\newcommand{\multi}[1]{\widebar{\ #1\ }}
\newcommand{\hastype}{:}
\newcommand{\pattype}{\ \lozenge\ }
\newcommand{\liftfun}{:}

\newcommand{\sz}[1]{\text{\small #1}}

\newcommand{\R}[1]{\color{teal}\ \ [\emph{#1}]}
 
\newcommand{\subtypes}{<:}
\newcommand{\supertypes}{:>}
\newcommand{\I}{\hspace{4mm}}
\newcommand{\Z}{.\hspace{4mm}}
\newcommand{\Alpha}{\mathrm{A}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\F}[1]{\text{#1}}
\newcommand{\bigand}{\bigwedge\nolimits}
\newcommand{\bigor}{\bigvee\nolimits}
\newcommand{\C}[1]{\color{teal} \rhd\ \emph{#1}}
\newcommand{\com}[1]{\color{Gray}\I \emph{#1}}
\newcommand{\D}[1]{\small \textsc{#1}}
% \newcommand{\fig}[1]{Fig. {\color{red} \fig{#1}}}
\newcommand{\FIG}[1]{Fig. {\color{red} \ref{#1}}}
\newcommand{\TODO}[1]{\noindent \B{\color{red} TODO: #1}}

\newcommand{\is}{\ ::=\ }
\newcommand{\sep}{\ \ |\ \ }
\newcommand{\nonterm}[1]{#1\ }
\newcommand{\contin}{|\ \ \ \ \ \ \ }
\newcommand{\wrt}{\B{wrt }}
% \newcommand{\let}{\B{let }}
% \newcommand{\for}{\B{for }}



\newcommand{\pc}{\hfill \break \noindent \ $\diamond$ \ }


\newcommand{\N}{\ $\cdot$\ \ }

\newcommand{\pitem}{\item[$\diamond$]}

\newcommand{\tl}{\textasciitilde{}}
\newcommand{\typdiff}{\J{\textbackslash}}

\maketitle


\section{Introduction}
\label{sec:introduction}

\TODO{note the use case of analyzing code that someone else wrote}

\TODO{extrinsic is necessary, because you can't easily modify the code to contain intrinsically typed constructors}

\TODO{MLStruct/MLScript are closely related, but still rely on intrinsic types}



Automatically catching errors in programs is a hard enough problem
that many languages require users to provide simple specifications to limit the space of correctness.
In languages such as as Java or ML, programmers must declare each data constructor along with the weakest space it belongs to. 
That is, the data constructors are intrinsically typed.
The clever design of ML allows annotations to be fairly sparse by 
having types specified at constructor declarations and relying on type inference elsewhere.
However, one of the drawbacks of intrinsically typed languages is that they prevent reusing of
constructors in contexts that are weaker than or incomparable to their declared spaces. 
For instance, if a programmer declares data constructors \emph{cons} and \emph{nil} to belong to type list,
and \emph{node} and \emph{empty} to belong to type tree, then it is impossible to construct a function
that accepts either a list or a tree, or returns either a list or a tree. The only option would be to define
a new datatype that contains isomorphs of all of the above the data constructors, which would 
likely add overhead to development, compilation, and execution.

For various reasons, which may include the reusability drawbacks just mentioned, 
intrinsically typed languages have lost favor,
and untyped languages, 
such as Javascript and Python, have increased in popularity. 
Untyped languages remove the burden on the programmer to prescribe the weakest space each data constructor belongs to, 
which in turn allows programmers to mix and match data constructors in
various contexts, with the potential for enhancing the reusability and clarity of code.
However, the automatic detection of errors is still important. Python and Javascript have 
evolved over the years to include extrinsic types, whereby the programmer annotates particular uses of
their data constructors with types, rather than the declarations of data constructors.
 
Because extrinsically typed languages do not require users to specify the weakest space each data constructor belongs to,
extrinsically typed languages lack the type inference capabilities of intrinsically typed languages, such as ML. 
A lack of type inference is a significant drawback, since it results in code cluttered with annotations in order
to achieve any safety assurance.

There have been some relaxations of intrinsic type systems, allowing for sightly more code reusability.
Refinement types (Pfenning) \cite{} allow reusing data constructors in stronger spaces than their intrinsic types, by
inferring refinement types for particular uses.
Unfortunately, refinements aren't sufficient to handle the full range of data constructor reusability allowed by untyped languages.

In order to achieve a language with a high degree of both code reusability and type inference, 
This work presents an extremely extrinsic type inference system
that allows programs to be as flexible as those in untyped languages
without any required annotation burden. 
Neither parametric data nor structural data is required to have
any intrinsic type information annotated by the programmer in order
to guarantee that highly reusable code does not get stuck.
Although annotations are allowed to enable programmers to check their logic,
annotations do not play any role in aiding type inference. In fact, 
type checking of annotations is constructed from type inference, 
so soundness and completeness of type inference with respect to type checking is trivial.  


\TODO{note how the key to extrinsic type inference is describing flow}

In order to achieve a language with a high degree of both code reusability and type inference, 
we introduce a novel type system with extrinsic type inference. 
To avoid hindering the reusability allowed in untyped programming, 
the type system must allow the type of a given data constructor in one context
to be stronger, weaker, or incomparable to the type of 
the same data constructor in a different context. 
Due to the fact that a data constructor can belong to infinitely many types of varying precision,
the system leverages subtyping to check, construct, and notate types.

As a byproduct of inferring extrinsic types using subtyping, the system also happens to infer the principal types for 
certain kinds of higher-order functions, which was first solved by SuperF \cite{}. 
However, SuperF's programming language and type system is purposefully 
restricted, and it isn't sufficient for the high-degree of code reusability allowed by untyped languages.

Our extrinsic type system relies on intersection, union, along with their indexed version, and recursive types, in order 
to construct strong types from the observed programs. 
To keep things simple, we restrict the reasoning of recursive types to scalars. In future work, 
we will extend the system to include inductive relational reasoning. By adding inductive relational
reasoning to the extrinsic type system, one effectively gets an extrinsic alternative to CHC solving \cite{} 
or liquid types \cite{}.


In section \ref{sec:overview}, we give examples of the expressions and types that the system reasons with
and demonstrate a few of the ways the system can reason. 
In section \ref{sec:structures}, we define the forms of expressions, types, and ancillaries. 
In section \ref{sec:dynamic_system}, we define the ground truth.
In section \ref{sec:static_system}, we describe the verification and type inference mechanisms.

When possible we will guide the design of definitions by soundness and/or completeness properties,
which, in effect, constrain the space of correct designs with upper and/or lower bounds, respectively. 
The derivations of these properties are hinted at by the inductive nature of the definitions 
along with other properties mentioned throughout.
Proofs of these properties are in the appendix \TODO{...}, section \ref{sect:appendix}.

\section{Overview}
\label{sec:overview}
We designed the type system around a simple applicative language with pattern matching,
since such a language is syntactically close to predicate logic. Likewise,
we designed the language of types to share many similarities with predicate logic. 
To get a feel for the languages and reasoning capabilities, it's best to start by
looking at a few examples.


\Par{Finite Isomorphism.}
A function can be constructed from multiple paths. 
Consider the function $\J{talky}$, which completes a simple English phrase.

\[
  \begin{array}[t]{@{} l}
    \J{let talky = (}
      \\
      \I \J{? <hello> @ => <world> @}
      \\
      \I \J{? <good> @ => <morning> @} 
      \\
      \I \J{? <thank> @ => <you> @} 
      \\
    \J{)}
  \end{array}
\]

\noindent
Since there is no recursion, the number of paths is finite.
For these simple finite functions, the type system constructs
an isomorphic type without any weakening in precision. 

\[
  \begin{array}[t]{@{} l}
    \J{TOP}
      \\
      \J{\& <hello> @ -> <world> @}
      \\
      \J{\& <good> @ -> <morning> @} 
      \\
      \J{\& <thank> @ -> <you> @} 
  \end{array}
\]

\noindent
Each path is represented using the path type,
and the paths are joined together using the intersection type.

\Par{Selection.}
Although the type of function $\J{talky}$ is no weaker than the actual function,
lifting into the type syntax avails it to approximate reasoning at application.
Consider an application of the function to a variable argument. 

\[
  \begin{array}[t]{@{} l}
    \J{let x : <hello> @ | <thank> @ = ... in}
    \\
    \J{...}
    \\
    \J{talky(x)} 
    \\
    \J{...}
  \end{array}
\]

\noindent
If the type system affirms the type annotation,
then it goes on to infer the type of the application. 
\[
  \J{<world> @ | <you> @}
\]

\noindent
In effect, the type system applies application to all possible arguments
and unions the results derived from only the paths of those arguments. 

\Par{Learning.}
The paths of a function are not always syntactically apparent. 
If a variable is applied to arguments, the variable should implicitly behave 
like a function, or else the program is erroneous. 
Consider the higher order function $\J{foo}$ which takes a function as input
and applies it to the number two and the boolean true.

\[
  \J{let foo = ? f => (f(<succ> <succ> <zero> @), f(<true> @))}
\]

\noindent
Type systems for System F have traditionally struggled to find the best
type for such programs. If restricted to unqualified parametric types, there are many choices,
without there being a clear best or principal type, 
which is because it's not possible to find the weakest type for the function parameter
$\J{f}$.
One possibility is that the type system requires that $\J{f}$ is a function that wraps its
input in an option. 

\[
  \J{f : ALL[X] X -> <some> X}
\]

\noindent
Another possibility is that the type system requires that $\J{f}$ is a function that wraps its
input in an list. 

\[
  \J{f : ALL[X] X -> (LFP[R] <nil> @ | <cons> X*R)}
\]

\noindent
Both are valid, but neither is weaker than the other. The problem is that unqualified parametric
types are insufficient for describing the weakest safe input type.
It was not until SuperF introduced a technique for solving subtyping constraints
that a principal type could be automatically constructed for functions like $\J{foo}$
Our extrinsic type system relies on similar principles of solving subtyping constraints,
and likewise, can construct the weakest safe type for $\J{f}$, and thus the principal type for $\J{foo}$.

\[
  \J{ALL[X Y] (<succ> <succ> <zero> @ -> X) \& (<true> @ -> Y) -> X*Y}
\]

\noindent
Although the subtyping constraints are not present in the type's notation,
the intersection of paths is chosen because it represents the weakest type
consistent with the subtyping constraints on a variable representing the parameter's type. 
Suppose the type system chooses the variable type $\J{F}$ for the input parameter $\J{f}$.
Eventually, due to the applications of the parameter $\J{f}$, the type
system will attempt to find a solution to two constraints on $\J{F}$
\[
  \begin{array}[t]{@{} l}
    \J{F} \subtypes \J{(<succ> <succ> <zero> @ -> X)}
    \\
    \J{F} \subtypes \J{(<true> @ -> Y)}
  \end{array}
\]


\Par{Factorization.}
A function can represent infinite paths by using recursion.
Consider the function $\J{repeat}$, which takes an item and a natural number
as inputs and returns a list of that item repeated the input number of times.

\[
  \begin{array}[t]{@{} l}
      \J{let repeat = ? x => loop(? self =>}
      \\
      \I \J{? <zero> @ => <nil> @}
      \\
      \I \J{? <succ> n => <cons>(x,self(n))}
      \\
      \J{)}
  \end{array}
\]

\noindent
One possibility for constructing the type of the recursive function would
be to follow the idea of finite isomorphism and construct a type 
that preserves all the paths. If our type system had a greatest fixed point
type constructor, then we could concisely represent such a type with minimal
rewriting.

\[
  \begin{array}[t]{@{} l}
      \J{ALL[T] T -> GFP[R]( TOP} 
      \\
      \I \J{\& <zero> @ -> <nil> @}
      \\
      \I \J{\& (ALL[N L](R <: N->L) <succ> N -> <cons> T*L)}
      \\
      \J{)} 
  \end{array}
\]

\noindent
Although the strength of precision of this type would be very beneficial,
reasoning with such a type would be complicated. To keep the type system as
simple as possible for the purpose of extrinsic type inference with a high-degree
of code reusability, we leave such relational reasoning of recursive and co-recursive types out of
the type system. 
In this work, the type system actually avoids constructing a relational type, and instead, it
constructs a type that is significantly weaker than the actual behavior of the function,
by factoring the paths into a recursive space of inputs and a recursive space of outputs. 

\[
  \begin{array}[t]{@{} l}
      \J{ALL[T] T ->} 
      \\
      \I \J{(LFP[R] <zero> @ | <succ> R)}
      \\
      \I \J{->}
      \\
      \I \J{(LFP[R] <nil> @ | <cons> T*R)}
  \end{array}
\]

\noindent
This eager weakening approximation enables the type system
to simply reason with recursive scalars and avoids the need for complicated
relational reasoning. In a follow up paper,
we will show how to remedy this limitation by augmenting the type system with
mechanisms for inductive relational reasoning.

\Par{Scalar Unrolling.} 
Since the inputs to functions may have recursive types, the type 
system must be able to check for errors at function application by unrolling
recursive types.
Consider applying the function $\J{repeat}$ to some item and the number two, 
which results in the type system checking that two is in fact an instance of the natural numbers.

\[
  \J{ <succ> <succ> <zero> @} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
\]

\noindent
The type system confirms that two is a valid input by unrolling the recursive type three times.
Unfortunately, because the type system eagerly factored the type of $\J{repeat}$, it
is unable to infer a stronger type for the application than the original list type. 
In the followup paper, inductive relational reasoning will remedy this limitation.


\Par{Scalar Induction.} 
Another scenario that may arise is one in which the input to a function has an recursive type.
Consider the application of the function $\J{repeat}$ to a variable whose type represents the even natural numbers.

\[
  \begin{array}[t]{@{} l}
    \J{let x : (LFP[R] <zero> @ | <succ> <succ> R) = ... in}
    \\
    \J{...}
    \\
    \J{repeat(...)(x)} 
    \\
    \J{...}
  \end{array}
\]

\noindent
The application results in the type system checking that natural numbers are weaker than even numbers. 

\[
  \begin{array}[t]{@{} l}
    \J{LFP[R] <zero> @ | <succ> <succ> R}
    \\
    \subtypes
    \\
    \J{LFP[R] <zero> @ | <succ> R}
  \end{array}
\]

\noindent
Since even numbers are represented recursively, the type system performs mathematical induction,
proving under the assumption that the subtyping relation holds for the self reference of the even numbers. 

\[
  \begin{array}[t]{@{} l}
    \J{E} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
    \\
    \entails
    \\
    \J{(<zero> @ | <succ> <succ> E)} \subtypes \J{(LFP[R] <zero> @ | <succ> R)}
  \end{array}
\]

\noindent
In practice, the type system actually substitutes the supertype into
the self reference of the subtype, if the self reference occurs in a positive position of the subtype.

\[
  \begin{array}[t]{@{} l}
    \J{(<zero> @ | <succ> <succ> (LFP[R] <zero> @ | <succ> R))} 
    \\
    \subtypes 
    \\
    \J{(LFP[R] <zero> @ | <succ> R)}
  \end{array}
\]

\noindent
In effect, by using mathematical induction, the type system ensures that 
every type contained within the type of even natural numbers is also
contained within the type of natural numbers.
In followup work, we will extend this inductive reasoning to handle inductive relations. 

\Par{Multi-specialization} 
Functions on lists can be generic, in that they may be independent of the item values, as in $\J{repeat}$,
or they may factor out the details that depend on item values, as in $\J{sort}$. 
\[
  \begin{array}[t]{@{} l}
    \J{let sort : ALL[X] (X*X->} \textbf{Bool} \J{) -> }\textbf{List}(\J{X}) \J{ -> } \textbf{List}(\J{X}) \J{ = }
    \\
    \J{? cmp => ...}
  \end{array}
\]
\noindent
The notation $\textbf{Bool}$ and $\textbf{List}(\J{X})$ are meta-language terms representing types.
The function $\J{sort}$ can be specialized by passing in different implementations of comparison functions.
In intrinsically typed languages, the programmer would need a different specialization for every predefined
datatype (in ML) or class hierarchy (in Java). 

\[
  \begin{array}[t]{@{} l}
    \J{let scalarSort = sort(scalarCmp) in}
    \\
    \J{let lexicoSort = sort(lexicoCmp) in} 
    \\
    \J{...} 
  \end{array}
\]

\noindent
Having many different specializations burdens the client of
the generic function to know many different names for roughly the same behavior and can obscure the meaning
of code at the call site. 
Untyped languages or extrinsically typed languages can bypass this rigidity found in intrinsically typed by specializing in multiple ways.

\[
  \begin{array}[t]{@{} l}
    ...
    \\
    \J{let stdCmp = \{ a,b => } 
    \\
    \I \J{a |> (}
    \\
    \I\I \J{\{zero;@ => scalarCmp(a,b)\}}
    \\
    \I\I \J{\{succ;n => scalarCmp(a,b)\}}
    \\
    \I\I \J{\{nil;@ => lexicoCmp(a,b)\}}
    \\
    \I\I \J{\{cons;(x,xs) => lexicoCmp(a,b)\}}
    \\
    \I \J{)}
    \\
    \J{) in} 
    \\
    \J{let stdSort : (TOP}
    \\
    \I \J{\& (}\textbf{List}(\textbf{Nat}) \J{ -> } \textbf{List}(\textbf{Nat})
    \\
    \I \J{\& (}\textbf{List}(\textbf{List}(\textbf{nat})) \J{ -> } \textbf{List}(\textbf{List}(\textbf{Nat}))
    \\
    \J{) = sort(stdCmp) in}
    \\
    \J{...} 
  \end{array}
\]

\noindent
Some intrinsically typed languages also have ways to perform multi-specialization, but they introduce additional
complexity, since data constructors can't be mixed in arbitrary ways. In Lean and Haskell, multi-specialization
is achieved via type classes \cite{}. 
The notion of type classes, among other things, translates the notion of pattern matching to the syntactic category of types.

\section{Structures}
\label{sec:structures}
\TODO{divide this section between static and dynamic systems}
To demonstrate the capabilities of the extrinsic type system, we rely on an applicative
programming language with pattern matching, but without effects.
The design attempts to keep the forms of expressions and types relatively 
similar to each other when their semantics are also similar. 
It should not be difficult to modify the techniques presented towards
languages based on conditional branching instead of pattern matching. However,
extensions to include effects would require 
significant modifications to the current system.

\begin{definition} Expressions
  \label{def:expressions}
  \small
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{e} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      x \sep 
      \J{@} \sep
      r \sep
      f \sep 
      e\J{.}l \sep
      e\J{(}e\J{)} \sep
      \\
      \J{loop(}e\J{)} \sep
      \J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e \sep
      s
    \end{array}
    & \com{expression}
    \\
    \nonterm{r} & \is \epsilon \sep r\ \J{<}l\J{>}e 
    & \com{record}
    \\
    \nonterm{f} & \is \epsilon \sep f\ \J{?}p\J{=>}e
    & \com{function}
    \\
    \nonterm{s} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      l \J{;} e \sep
      e \J{,} e \sep
      e\ \J{|>}\ e \sep
      \J{if}\ e\ \J{then}\ e\ \J{else}\ e \sep
      \J{let}\ x\ \J{=}\ e\ \J{in}\ e
    \end{array}
    & \com{sugar}
  \end{array}\]
\end{definition}

\noindent
A program is an expression $e$, which may be composed of variables $x$, unit $\J{@}$,
records $... \J{<}l\J{>} e ...$, functions $...\J{?}p \J{=>} e ...$, record
projection $e\J{.}l$, function application, $e\J{(}e\J{)}$, recursion $\J{loop(}e\J{)}$,
or bindings with type annotations, $\J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e$.
A record $r$ is constructed from zero or more entries $r$, where an entry
is a label associated with an expression $\J{<}l\J{>}e$.
A function $f$ is constructed from zero or more paths $f$, where a path is distinguished by a pattern
and leads to an expression $\J{?}p \J{=>} e$.
That is, construction of branches is inherent to functions and decoupled from pattern matching.
Therefore, pattern matching is subsumed by function application.

Projection $e\J{.}l$ allows getting the value from a particular entry in a record. 
Application $e\J{(}e\J{)}$ handles instantiation functions and pattern matching. 
Recursion $\J{loop(}e\J{)}$ is represented using a fixed point combinator $\J{loop}$.
A binding with type annotation $\J{let}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e$ allows the programmer 
to verify expressions against a custom specification, instead of relying on merely 
the specification generated by type inference.
The annotation is used in two ways. First, the type system checks that specification is an approximation
of the expression bound to the variable. Second, the type system checks that the approximation,
although possibly weaker than the inferred type, is sufficient for the continuing expression to be error-free. 

\begin{definition} 
  \label{def:expression_desugaring}
  Expression Desugaring
  \hfill 
  \small
  \boxed{\llbracket s \rrbracket^\square = e}
  \\
  \begin{align*}
      \llbracket l \J{;} e \rrbracket^\square &= \J{<}l \J{>}\ e
      \\
      \llbracket e_l \J{,} e_r \rrbracket^\square &= \J{<left>}\ e_l \ \J{<right>}\ e_r
      \\
      \llbracket e_l\ \J{|>}\ e_r \rrbracket^\square &= e_r\J{(}e_l\J{)}
      \\
      \llbracket \J{if}\ e_c\ \J{then}\ e_t\ \J{else}\ e_f \rrbracket^\square &= 
      \begin{array}[t]{@{} l}
        e_c \J{ |> (}
          \\
          \I \J{? <true> @ => } e_t
          \\
          \I \J{? <false> @ => } e_f
          \\
        \J{)}
      \end{array}
      \\
      \llbracket \J{let}\ x\ \J{=}\ e\ \J{in}\ e' \rrbracket^\square &= (\J{?}x \J{=>} e')\J{(}e\J{)}
  \end{align*}

\end{definition} 

\noindent
For convenience and clarity, expressions include syntactic sugar for tuples $e\J{,}e$, 
unannotated bindings $\J{let}\ x\ \J{=}\ e\ \J{in}\ e$, data flow $e\ \J{|>}\ e$,
and conditional branching $\J{if}\ e\ \J{then}\ e\ \J{else}\ e$.
For any metalanguage statement or term containing sugar $s$, we assume that $s$ is implicitly replaced with $\llbracket s \rrbracket^\square$.

\begin{definition} Patterns 
  \label{def:patterns}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{p} & \is 
      x \sep
      \J{@} \sep
      k
    & \com{pattern}
    \\
    \nonterm{k} & \is \epsilon \sep k\ \J{<}l\J{>}p
    & \com{record}
  \end{array}\]
\end{definition}

\noindent
A pattern $p$ may be composed of variables $x$, unit $\J{@}$, or records $k$. 

\begin{definition} Values 
  \label{def:values}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{v} & \is 
      \J{@} \sep
      g \sep
      f
    & \com{value}
    \\
    \nonterm{g} & \is \epsilon \sep g\ \J{<}l\J{>}v
    & \com{record}
  \end{array}\]
\end{definition}

\noindent
A value $v$ may be composed of unit $\J{@}$, records $g$, or functions $f$. 

\begin{definition} Types 
  \label{def:types}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \kappa \sep 
      \phi \sep 
      \psi \sep 
      \J{LFP[}\alpha\J{]}\tau \sep
      \tau \typdiff \eta \sep
      \gamma
    \end{array}
    & \com{type}
    \\
    \nonterm{\kappa} & \is 
    \begin{array}[t]{@{}l}
      \J{<} l \J{>} \tau \sep 
      \tau\J{->}\tau
    \end{array}
    & \com{implication}
    \\
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{|}\tau \sep 
      \J{EXI[}\Theta\J{]} \Delta \J{:} \tau
    \end{array}
    & \com{expansion}
    \\
    \nonterm{\psi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{\&}\tau \sep 
      \J{ALL[}\Theta\J{]} \Delta \J{:} \tau
    \end{array}
    & \com{refinement}
    \\
    \nonterm{\eta} & \is 
    \begin{array}[t]{@{}l}
      \J{EXI[}\Theta \J{]} \rho \sep 
      \rho
    \end{array}
    & \com{subtracted}
    \\
    \nonterm{\rho} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \J{<}l\J{>}\rho \sep 
      \rho\J{\&}\rho \sep
      \rho\J{*}\rho
    \end{array}
    & \com{pattern}
    \\
    \nonterm{\gamma} & \is 
    \begin{array}[t]{@{}l}
      \J{TOP} \sep \J{BOT} \sep 
      \tau \J{*} \tau 
    \end{array}
    & \com{sugar}
  \end{array}\]
\end{definition}

\noindent
Types provide the representation for approximate specification.
To accommodate a high degree of data constructor reusability,
it is important that the forms of types accommodate a wide range of precision.
To manage the complexity of the various forms, we subdivide the type forms
according to some themes.
A type $\tau$ may be composed of unit $\J{@}$, variables $\alpha$, 
implication $\kappa$, expansions $\phi$, refinements $\psi$,
least fixed points $\J{LFP[}\alpha \J{]} \tau$,
differences $\tau \typdiff \eta$, and sugar $\gamma$.

An implication type $\kappa$ reflects the structure of 
its inhabitants and may take the form of  
entries $\J{<}l\J{>}\tau$ or paths $\tau \J{->} \tau$.

An expansion type $\phi$ is either a binary union $\tau \J{|} \tau$ or 
an indexed union $\J{EXI[}\Theta \J{]} \Delta \J{:} \tau$.
An expansion type is weaker than its constituent types. 
An indexed union is parametrized by type variables $\Theta$ 
and qualified by subtyping constraints $\Delta$.
It represents the compounded union of all instantiations of its constituent type 
consistent with its subtyping constraints.
In effect, the qualification by subtyping constraints provides an upper bound, in which
the weaker the qualification, the weaker the indexed union.

A refinement type $\psi$ is either a binary intersection $\tau \J{\&} \tau$ or 
an indexed intersection $\J{ALL[} \Theta \J{]} \Delta \J{:}\tau$.
A refinement type is strengthened relative to its constituent types. 
An indexed intersection is parametrized by type variables $\Theta$ 
and qualified by subtyping constraints $\Delta$.
It represents the compounded intersection of all instantiations of its constituent type 
consistent with its subtyping constraints.
In effect, the qualification by subtyping constraints provides a lower bound, in which
the weaker the qualification, the stronger the indexed intersection.

A least fixed point type $\J{LFP[}\alpha \J{]}$ 
enables the representation of an infinite space of data,
e.g. natural numbers or lists. 
A difference type represents subtracting one space from another.
Its subtracted type $\eta$ has a restricted form of either
a pattern type $\rho$ or an unqualified indexed union 
over a pattern $\J{EXI[}\Theta \J{]} \rho$, for which the type system
is complete, thus making its negation sound.  
This restricted form is of no hindrance to type inference, since the 
subtracted types arise only from patterns, whose forms are sufficiently
limited.
A pattern type $\rho$ reflects the forms of pattern expressions, consisting of 
variables $\alpha$, unit $@$, entries $\J{<} l \J{l} \rho$, intersections $\rho \J{\&} \rho$,
and pairs $\rho \J{*} \rho$ (whose form is just syntactic sugar).


\begin{definition} 
  \label{def:type_desugaring}
  Type Desugaring 
  \hfill 
  \small
  \boxed{\llbracket \gamma \rrbracket^\square = \tau}
  \\
  \begin{align*}
    \llbracket \J{TOP} \rrbracket^\square &= \J{EXI[} \alpha \J{]} \alpha
    \\
    \llbracket \J{BOT} \rrbracket^\square &= \J{ALL[} \alpha \J{]} \alpha
    \\
    \llbracket \tau_l \J{*} \tau_r \rrbracket^\square &= (\J{<left>}\ \tau_l)  \J{\&} (\J{<right>}\ \tau_r)
  \end{align*}
\end{definition} 

\noindent
For convenience and clarity, types include syntactic sugar for top $\J{TOP}$, 
bottom $\J{BOT}$, and pairs $\tau \J{*} \tau$.
For any metalanguage statement or term containing sugar $\gamma$, we assume that $\gamma$ is implicitly replaced with $\llbracket \gamma \rrbracket^\square$.


\begin{definition} Sequences 
  \label{def:sequences}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\Theta} & \is \epsilon \sep \Theta\ \alpha 
    & \com{type var seq}
    \\
    \nonterm{\Delta} & \is \epsilon \sep \Delta \  \tau \J{<:} \tau
    & \com{subtyping seq}
    \\
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ x \hastype \tau
    & \com{typing seq}
    \\
    \nonterm{\Pi} & \is \epsilon \sep \Pi\ (\Theta, \Delta, \tau) 
    & \com{schema seq}
    \\
    \nonterm{\Xi} & \is \epsilon \sep \Xi\ \eta 
    & \com{subtracted type seq}
    \\
    \nonterm{\Omega} & \is \epsilon \sep \Omega \  \tau \J{<:} \eta
    & \com{restricted subtyping seq}
    \\
    \nonterm{C} & \is \epsilon \sep C\ \iota 
    & \com{composite seq}
    \\
    \nonterm{\iota} & \is 
    \alpha
    \sep 
    \tau \J{<:} \tau
    \sep
    x \hastype \tau
    \sep
    (\Theta, \Delta, \tau)
    \sep
    \eta
    \sep
    \tau \J{<:} \eta

    & \com{item}
  \end{array}\]
\end{definition}

\TODO{make sure there are no free vars in the eta of the Omega}

\TODO{add collection concatentation to library}


There are a few ancillary structures, upon which both the representation of types and the reasoning with types depend.
A type variable sequence $\Theta$ is either empty $\epsilon$ or a smaller sequence extended by a single variable $\Theta\ \alpha$
A subtyping environment $\Delta$ is either empty $\epsilon$ or a smaller environment extended by a single
subtyping constraint $\Delta \  \tau \J{<:} \tau$.
A typing environment $\Gamma$ is either empty $\epsilon$ or a smaller environment extended by a single
typing constraint over a variable $\Gamma\ x \subtypes \tau$.
a World $\Omega$ is simply a pair of a type variables sequence and a subtyping environment $\Theta, \Delta$.
A world represents the context for judging a typing or a subtyping relation.


For clarity, we omit writing $\epsilon$ explicitly when describing semantics or instances of the forms.
That is, for any structure, if there is a malformed structure due to a missing piece, 
we assume it is replaced by a well-formed structure, 
where $\epsilon$ is inserted wherever necessary to make it well-formed.


\begin{definition} 
  \label{def:sequence_setting}
  Sequence Setting 
  \hfill 
  \small
  \boxed{\textbf{set}(C) = S}
  \\
  \[
  \begin{array}[t]{r@{}c@{}l}
      \textbf{set}(\epsilon)
      &\ =\ & 
      \emptyset 

      \\

      \textbf{set}(C\ \iota)
      &\ =\ & 
      \textbf{set}(C) \cup \{ \iota \} 
  \end{array}
  \]
\end{definition} 

\begin{definition} 
  \label{def:set_sequencing}
  Set Sequencing 
  \hfill 
  \small
  \boxed{\textbf{seq}(S) = C}
  \\
  \[
  \begin{array}[t]{r@{}c@{}l}
      \textbf{seq}(\emptyset)
      &\ =\ & 
      \epsilon 

      \\

      \textbf{seq}(S \cup \{\iota\})
      &\ =\ & 
      \textbf{seq}(S \backslash \{\iota\})\ \iota 
  \end{array}
  \]
\end{definition} 

\noindent
To keep the reinvention of basic definitions and theorems to a minimum, 
we may implicitly convert collections into sets, or sets into collections.
We assume that any collection term $C$ is implicitly replaced with $\textbf{set}(C)$,
or any set term $S$ is implicitly replaced with $\textbf{collect}(S)$, if it helps
us make progress.


\section{Dynamic System}
\label{sec:dynamic_system}

The programming language is pure and applicative. 


\begin{definition}
  \label{def:progression}
  Progression
  \hfill 
  \small
  \boxed{e \rightsquigarrow e}
  \\
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      r\J{<}l\J{>}e \rightsquigarrow r\J{<}l\J{>}e'
    }

    \inferrule {
      r \rightsquigarrow r'
    } {
      r \J{<}l \J{>} v \rightsquigarrow r' \J{<} l \J{>} v
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      e\J{.}l \rightsquigarrow e'\J{.}l
    }

    \inferrule {
      \J{?}l\J{=>}v \in g
      \\
      \forall\ e .\ \J{?}l\J{=>}e \in g \implies e = v
    } {
      g\J{.}l \rightsquigarrow v
    }

    \inferrule {
      e_f \rightsquigarrow e_f'
    } {
      e_f\J{(}e\J{)} \rightsquigarrow e_f'\J{(}e\J{)}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      f\J{(}e\J{)} \rightsquigarrow f\J{(}e'\J{)}
    }

    \inferrule {
      f\J{(}v\J{)} \rightsquigarrow e'
      \\
      \text{FV}(e) \subseteq \text{FV}(p)
    } {
      (f\J{?}p\J{=>}e)\J{(}v\J{)} \rightsquigarrow e' 
    }

    \inferrule {
      \exists e' .\ f\J{(}v\J{)} \rightsquigarrow e'
      \\
      p \equiv v \given \sigma 
    } {
      (f\J{?}p\J{=>}e)\J{(}v\J{)} \rightsquigarrow e[\sigma]
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \J{loop(}e\J{)} \rightsquigarrow \J{loop(}e'\J{)}
    }

    \inferrule {
    } {
      \J{loop(?}x\J{=>}e\J{)} \rightsquigarrow e[x \slash \J{loop(?}x\J{=>}e\J{)}]
    }
  \end{mathpar}
\end{definition}

Progression of an expression is a small-step operational semantics. 
It adheres to typical definitions of applicative languages for the most part. One 
slight departure is that pattern matching is merely a special case of function application. 
Likewise, a switch is merely a function abstraction.
Records are similar to functions, except that their entries are guarded by literal identifiers. 
Additionally, records may act as patterns, but functions may not.
The semantics enables recursion via the fixed point combinator \J{loop}.

\begin{definition} Interpretation Map
  \label{def:interpretation_map}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\sigma} & \is \epsilon \sep \sigma\ x \slash e 
    & \com{expr interp map}
    \\
    \nonterm{\delta} & \is \epsilon \sep \delta\ \alpha \slash \tau
    & \com{type interp map}
  \end{array}\]
\end{definition}

% \begin{definition}
%   \label{def:stability}
%   Stability 
%   \hfill
%   \boxed{\VDash e}
%   \\
%   \begin{mathpar}
%     \inferrule {
%       e = v
%     } {
%       \VDash e
%     } 

%     \inferrule { 
%       e \rightsquigarrow e' 
%       \\
%       \VDash e'
%     } {
%       \VDash e
%     } 
%   \end{mathpar}
% \end{definition}

% \noindent
% A expression is stable if and only if it is a value or it can take a step to a stable expression.
% In other words, if an expression is not a value then its behavior is defined by progression.

% \begin{property}
%   \label{def:model_typing_soundness}
%   Model Typing Soundness 
%   \\
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies e \hastype \tau
%     } {
%       \VDash e 
%     } 
%   \end{mathpar}
% \end{property}

% \noindent
% Model typing $\delta \satisfies e \hastype \tau$ attempts to imbue types
% with meaning.  At the very least, types should inform us that an expression is stable.  

\begin{definition}
  \label{def:model_typing}
  Model Typing
  \hfill
  \small
  \boxed{\delta \satisfies e \hastype \tau}
  \\
  \begin{mathpar}
    \inferrule { 
    } {
      \delta \satisfies \J{@} \hastype \J{@}
    } 

    \inferrule { 
    } {
      \delta \satisfies \epsilon \hastype \J{TOP}
    } 

    \inferrule { 
      \J{<}l \J{>} v \in g
      \\
      \delta \satisfies v \hastype \tau 
      \\
      \forall v' .\ \J{<} l \J{>} v' \in g \implies v' = v
    } {
      \delta \satisfies g \hastype \J{<} l \J{>} \tau
    } 

    \inferrule { 
      \delta \satisfies f \hastype \tau_l \J{->} \tau_r
    } {
      \delta \satisfies f \J{?}p \J{=>} e \hastype \tau_l \J{->} \tau_r
    } 

    \inferrule { 
      \forall \sigma.\ 
      \delta \satisfies p[\sigma] \hastype \tau_l
      \implies
      \delta  \satisfies e[\sigma] \hastype \tau_r
      \\\\
      \forall \tau_l'\ \tau_r'.\ 
      \delta \satisfies f \hastype \tau_l' \J{->} \tau_r'
      \implies
      \delta \satisfies \tau_l \subtypes \tau_l'
      \implies
      \delta \satisfies \tau_r' \subtypes \tau_r
    } {
      \delta \satisfies f \J{?}p \J{=>} e \hastype \tau_l \J{->} \tau_r
    }

    \inferrule { 
      \delta \satisfies e \hastype \tau_l
      \\
      \neg\ (\delta \satisfies e \hastype \tau_r)
    } {
      \delta \satisfies e \hastype \tau_l \typdiff \tau_r
    } 

    \inferrule { 
      \delta \satisfies e \hastype \tau_l
      \\
      \delta \satisfies e \hastype \tau_r
    } {
      \delta \satisfies e \hastype \tau_l \J{\&} \tau_r
    } 

    \inferrule { 
      \delta \satisfies e \hastype \tau_l
    } {
      \delta \satisfies e \hastype \tau_l \J{|} \tau_r
    } 

    \inferrule { 
      \delta \satisfies e \hastype \tau_r
    } {
      \delta \satisfies e \hastype \tau_l \J{|} \tau_r
    } 

    \inferrule { 
      \textbf{dom}(\delta') \subseteq \Theta
      \\
      \delta \oplus \delta' \satisfies \Delta 
      \\
      \delta \oplus \delta' \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \J{EXI[}\Theta\J{]}\Delta \J{:} \tau
    } 

    \inferrule { 
      \forall \delta' \qua
      \textbf{dom}(\delta') \subseteq \Theta \implies
      \delta \oplus \delta' \satisfies \Delta \implies 
      \delta \oplus \delta' \satisfies e \hastype \tau
      \\\\
      \exists \delta' \qua 
      \textbf{dom}(\delta') \subseteq \Theta \up 
      \delta \oplus \delta' \satisfies \Delta
    } {
      \delta \satisfies e \hastype \J{ALL[}\Theta\J{]}\Delta \J{:} \tau
    } 

    \inferrule { 
      \delta \ \alpha \slash \J{LFP[}\alpha \J{]} \tau \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \J{LFP[} \alpha \J{]} \tau
    } 

    \inferrule { 
      e \rightsquigarrow e'
      \\
      \delta \satisfies e' \hastype \tau 
    } {
      \delta \satisfies e \hastype \tau 
    } 

    \inferrule { 
      \alpha \slash \tau \in \delta
      \\
      \delta \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \alpha 
    } 
  \end{mathpar}
\end{definition}

\noindent
Model typing describes how the various forms of 
types are introduced based on the various forms of values. 
There are no rules for elimination 
of type forms. Rather, the progression of expressions is leveraged to eliminate
expression forms, from which further type forms may be introduced.
The indirection into progression is not practical, but it guides the design 
of a sound type system that can directly prove the validity of typings and subtypings 
by eliminating type forms.

\TODO{describe the various rules of model typing}

\TODO{note how indexed intersection disallows vacuous non-empty types, which would allow erroneous expressions to have a type}

\begin{definition}
  \label{def:expression_congruence}
  Expression Congruence 
  \hfill
  \small
  \boxed{e_l \cong e_r}
  \\
  \begin{mathpar}
    \inferrule { 
      \forall \delta, \tau \qua 
      \delta \satisfies e_l \hastype \tau 
      \iff
      \delta \satisfies e_r \hastype \tau
    } {
      e_l \cong e_r 
    } 
  \end{mathpar}
\end{definition}


% \hfill
% \begin{definition}
%   \label{def:model_type_inhabitation}
%   Model Type Inhabitation 
%   \hfill
%   \boxed{\delta \satisfies \tau}
%   \\
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies e \hastype \tau 
%     } {
%       \delta \satisfies \tau 
%     } 
%   \end{mathpar}
% \end{definition}
% \hfill

% As a matter of convenience, a type is inhabited if and only if there is 
% an expression for which model typing holds. 


\begin{definition}
  \label{def:model_subtyping}
  Model Subtyping
  \hfill
  \small
  \boxed{\delta \satisfies \tau <: \tau}
  \\
  \begin{mathpar}
    \inferrule { 
      \forall e .\ 
      \delta \satisfies e \hastype \tau_l \implies 
      \delta \satisfies e \hastype \tau_r 
    } {
      \delta \satisfies \tau_l <: \tau_r
    } 
  \end{mathpar}
\end{definition}


\begin{definition}
  \label{def:model_subtyping_sequence}
  Model Subtyping Sequence 
  \hfill
  \small
  \boxed{\delta \satisfies \Delta}
  \\
  \begin{mathpar}
    \inferrule { 
    } {
      \delta \satisfies \epsilon 
    } 

    \inferrule { 
      \delta \satisfies \Delta 
      \\
      \delta \satisfies \tau_l \subtypes \tau_r
    } {
      \delta \satisfies \Delta \  \tau_l \J{<:} \tau_r
    } 
  \end{mathpar}
\end{definition}

\begin{definition}
  \label{def:model_typing_sequence}
  Model Typing Sequence 
  \\
  \begin{mathpar}
    \inferrule {
      \forall x \qua
      x \hastype \tau \in \Gamma
      \implies
      \delta \satisfies x[\sigma] \hastype \tau
    } {
      \delta, \sigma \satisfies \Gamma
    }
  \end{mathpar}
\end{definition}



\section{Static System}
\label{sec:static_system}
The static system is a strengthening of the dynamic system, designed to
ensure that expressions can make progress and satisfy approximate specifications
represented by types. 
The entry point into the static system is Proof Typing $(
  \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
)$, which aims to infer types and verify typings. 
The predicate represents a procedure 
that inherits skolem variables $\Theta$, subtyping constraints $\Delta$ and typing constraints $\Gamma$,
takes an expression $e$, and then generates a type $\tau$,
a new set of skolem variables $\Theta'$, and a new set of subtyping constraints $\Delta'$.

\begin{property}
  \label{prop:proof_typing_soundness}
  Proof Typing Soundness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \exists \delta' \qua \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta \up 
      (
      \forall \delta \qua
      \delta \oplus \delta' \satisfies \Delta' \implies
      \delta, \sigma \satisfies \Gamma \implies
      \delta \oplus \delta' \satisfies e[\sigma] \hastype \tau
      )
    }
  \end{mathpar}

\end{property}


\noindent
The most basic requirement is Proof Typing Soundness (Prop. \ref{prop:proof_typing_soundness}),
which, states that the generated type $\tau$ contains the input expression $e$, 
$(e \hastype \tau)$ with respect to Model Typing (Def. \ref{def:model_typing}) 
if the generated constraints $\Delta'$ hold with respect to 
Model Subtyping Sequence (Def. \ref{def:model_subtyping_sequence})
and input typing constraints $\Gamma$ hold with respect to Model Typing Sequence
(Def. \ref{def:model_typing_sequence}).
Additionally, the guarded typing must be satisfiable with respect to the skolem variables
$\Theta' \backslash \Theta$, and it it must be valid with respect to the remaining type variables. 

\TODO{intution: input skolems make the premise Proof Typing more strict}

\TODO{intuition: output skolems make the generated constraints weaker, therefore, easy to satisfy
even in some cases where the typing fails}

\begin{property}
  \label{prop:proof_typing_substance}
  Proof Typing Substance 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \forall \delta \qua \textbf{dom}(\delta) \subseteq \Theta \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta
      \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta'
    }
  \end{mathpar}
\end{property}

\noindent
The property of Proof Typing Soundness is actually a bit weak on its own. It does not
require that a program has no errors, since the property could be satisfied vacuously by
having Proof Typing generate an unsatisfiable set of subtyping constraints $\Delta'$.
To ensure that a program $e$ has no errors,
we need Proof Typing Substance \ref{prop:proof_subtyping_substance}, 
which requires that the subtyping constraints generated by Proof Typing hold. 
The guarded subtyping constraints must be valid with respect to the skolem variables $\Theta$,
and they must be satisfiable with respect to the remaining type variables. 

\begin{property}
  \label{prop:proof_typig_annotation_soundness}
  Proof Typing Annotation Soudness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails \J{let } x \J{:} \tau_a \J{ = } e \J{ in } e' \hastype \tau' \given \Theta', \Delta'
    } {
      \forall \delta, \sigma \qua 
      \delta, \sigma \satisfies \Gamma \implies
      \delta \satisfies e \hastype \tau_a
    }
  \end{mathpar}
\end{property}

\noindent
In addition to constructing types from programs, we are also interested in checking that 
programs meets specifications annotated by the programmer. Proof Typing Soundness
does not directly reference these annotations, so we need an additional property to ensure
the annotations are respected. Proof Typing Annotation Soundness 
\ref{prop:proof_typig_annotation_soundness} requires that the expressions
used in the binding syntax respect the type annotations.  

\begin{definition} 
  \label{def:proof_typing}
  Proof Typing
  \hfill 
  \small
  \boxed{\Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta, \Gamma \entails \J{@} \hastype \J{@} \given \Theta, \Delta
    }

    \inferrule {
      x:\tau \in \Gamma
    } {
      \Theta, \Delta, \Gamma \entails x \hastype \tau \given \Theta, \Delta 
    }

    \inferrule {
    } {
      \Theta, \Delta, \Gamma \entails \epsilon \hastype \J{TOP} \given \Theta, \Delta
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails r \hastype \tau \given \Theta', \Delta'  
      \\\\
      \Theta', \Delta', \Gamma \entails e \hastype \tau' \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta, \Gamma \entails r\ \J{<}l \J{>} e \hastype (\tau\ \J{\&}\ \J{<} l \J{>} \tau') 
      \given \Theta'', \Delta'' 
    }

    \inferrule {
      \exists \Xi \qua \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
      \\\\
      \textbf{pack}^+(\Theta \cup \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) \entails \Pi) = \tau 
      \\\\
      \TODO{update proof to avoid dTheta}
    } {
      \Theta, \Delta, \Gamma \entails f \hastype \tau \given \Theta, \Delta
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta' 
      \\\\
      \Theta', \Delta' \entails 
      \tau \subtypes  \J{<} l \J{>} \alpha 
      \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta, \Gamma \entails e\J{.}l \hastype \alpha \given \Theta'', \Delta''
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e_f \hastype \tau_f \given \Theta', \Delta'
      \\
      \Theta', \Delta', \Gamma \entails e_a \hastype \tau_a \given \Theta'', \Delta''
      \\\\
      \Theta'', \Delta'', \tau_f \subtypes \tau_a\J{->}\alpha \given \Theta''', \Delta'''
    } {
      \Theta, \Delta, \Gamma \entails e_f\J{(}e_a \J{)} \hastype \alpha \given \Theta''', \Delta'''
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta' 
      \\
      \textbf{ftv}(\tau_a) \subseteq \emptyset
      \\\\
      \exists \Theta^\dagger, \Delta^\dagger \qua \Theta', \Delta' \entails \tau \subtypes \tau_a \given \Theta^\dagger, \Delta^\dagger
      \\
      \Theta', \Delta', \Gamma, x:\tau_a \entails e' \hastype \tau' \given \Theta'', \Delta''
    } {
      \Theta, \Delta, \Gamma \entails \J{let } x \J{:} \tau_a \J{ = } e \J{ in } e' \hastype \tau' \given \Theta'', \Delta''
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given  \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \tau \subtypes \alpha_\nu \rightarrow \Pi_\nu
      \\\\
      \alpha_\nu \downarrow \Pi_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \Pi_\mu
      \\
      \textbf{pack}^-(\textbf{ftv}(\Delta')\ \alpha_\mu \entails \Pi_\mu) = \tau_\mu
      \\\\
      \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<left>}\ \tau_l
      \\
      \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<right>}\ \tau_r
    } {
      \Theta, \Delta, \Gamma \entails \J{loop(}e\J{)} 
      \hastype 
      \tau_l \J{->} \tau_r
      \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}


\noindent
The definition of Proof Typing (Def. \ref{def:proof_typing}) consists of a few rules, which are 
distinguished by the form of the expression. The definition is recursive and also depends on
other definitions, which we will elaborate on as they arise.

For the unit expression \J{@}, Proof Typing simply returns the unit type \J{@}. 
For a variable expression, $x$, Proof Typing looks for a corresponding typing in the environment, 
and it returns the type it found.
For an empty expression $\epsilon$, Proof Typing returns the top type \J{TOP},
thereby providing a basis for constructing types for record expressions. 
For a non-empty record expression $r\ \J{<}l\J{>}e$, Proof Typing 
recursively constructs the type for each entry, and
refines their types against each other via compounded intersection.

For a function expression $f$, Proof Typing 
delegates the work to two helpers. 
The predicate for path sequence typing 
$(\Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi)$
constructs a sequence of path types, 
with each path type associated with a world, represented by $\Pi$.
Then, the metalanguage function for positive packing 
$(\textbf{pack}^+(\Theta \cup \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) \entails \Pi) = \tau)$
takes the path schemas and for each path schema,
it rewrites the schema into a type by wrapping the path type in indexed unions
and indexed intersections qualified by the constraints in the schema's subtyping environment. 
The positive $+$ annotation on pack indicates that the resulting type 
is should approximate an expression used in a positive position,
which determines whether closed and open variables are mapped to
bindings in indexed unions or indexed intersections.

For projection $e\J{.}l$, Proof Typing
leverages Proof Subtyping $(... \entails \tau \subtypes \J{<}l\J{>}\alpha \given ...)$ 
to check that there is an entry with the label $l$ 
in the supposed record $e$ with type $\tau'$, 
and it learns a lower bound 
on the type of the body $\alpha$, which is associated with that label.
For application $e_f\J{(}e_a\J{)}$, Proof Typing
leverages Proof Subtyping $(... \entails \tau_f \subtypes \tau_a \J{->} \alpha \given ...)$
to check that that the function $e_f$ can actually
map the argument $e_a$ to a result. It learns a lower bound 
on the type of the result $\alpha$, which is associated with that argument.
For an annotated binding, $\J{let}\ x \J{:} \tau_a\ \J{=}\ e\ \J{in}\ e'$, 
Proof Typing checks the definition's source $e$ against the annotation $\tau_a$,
and adds the annotation to the typing environment when checking the continuation $e'$.

For a looping expression, $\J{loop(}e{)}$, Proof Typing
eagerly factors the paths of the recursive function 
to construct a single path type with an recursive type as its input and an recursive type as its output. 
First, it ensures that argument of the fixed point combinator $e$ is indeed a 
function that returns a function.
The rule infers its type $(\Theta, \Delta, \Gamma \entails e \hastype \tau \given  \Theta', \Delta')$
and then rewrites it as a single path containing multiple path schemas $(
  \Theta', \Delta' \entails \tau \subtypes \alpha_\nu \rightarrow \Pi_\nu
)$
. 
Then, by leveraging subtyping $(... \entails \tau \subtypes \alpha_l \J{->} \alpha_r \given ...)$, 
it gathers all the path types that approximate the body of $e$ (via its type $\tau$)
into a sequence $\Pi$, which pairs each parametric path type with a world to qualify its meaning.
As it collects the path schemas, it leverages positive type interpretation 
$\llbracket ... \entails \Delta', \alpha_l \J{->} \alpha_r \rrbracket^+$ 
to instantiate the parametric path type with interpretations consistent with its corresponding world. 
This interpretation makes the path type more readable and the subtyping environment more compact.


      % 
      % \\
      % 
      % \\\\
      % \alpha_\nu \downarrow \Pi_\nu
      % \fallingdotseq 
      % \alpha_\mu \uparrow \Pi_\mu
      % \\
      % \textbf{pack}^-(\textbf{ftv}(\Delta')\ \alpha_\mu \entails \Pi_\mu) = \tau_\mu
      % \\\\
      % \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<left>}\ \tau_l
      % \\
      % \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<right>}\ \tau_r





Using the whole collection path schemas $\Pi$, 
Proof Typing delegates to Schema Sequence Duality
$(
  \alpha_\nu \downarrow \Pi_\nu
  \fallingdotseq 
  \alpha_\mu \uparrow \Pi_\mu
)$, which rewrites the implicitly co-recursive path schemas into
implicitly recursive pair schemas. 
Rewriting the co-recursive paths into recursive pairs is the first
step towards factoring the infinite paths of the recursive function into a weaker single path.
By leveraging the negative packing $\textbf{pack}^-(... \entails \Pi_\mu) = \tau_\mu$,
the qualification by the worlds becomes embedded in a single type $\tau_\mu$. 
Finally, it makes recursive nature of the relational type explicit,
by wrapping the type in a least fixed point $\J{LFP[} \alpha_\mu \J{]}$, 
and it leverages the factorization predicate on the left of the pair $(
  \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<left>}\ \tau_l
)$
and the right of the pair $(
  \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<right>}\ \tau_r
)$ 
to factor the recursive relational type into a recursive antecedent and a recursive consequent
of a single path type.

Proof Subtyping $(
  \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
)$ is the most significant of the predicates that the rules of Proof Typing 
depends on.  
The predicate represents a procedure 
that inherits skolem variables $\Theta$, subtyping constraints $\Delta$, 
and takes two types $\tau_l$ and $\tau_r$, 
and then generates a new set of skolem variables $\Theta'$
and a new set of subtyping constraints $\Delta'$.

\begin{property} 
  \label{prop:proof_subtyping_soundness}
  Proof Subtyping Soundness 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
    } {
      \exists \delta' \qua 
      \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
      \up
      (
      \forall \delta \qua 
      \delta \oplus \delta' \satisfies \Delta' \implies
      \delta \oplus \delta' \satisfies \tau_l \subtypes \tau_r
      )
    }
  \end{mathpar}
\end{property}

\noindent
The most basic requirement is Proof Subtyping Soundness (Prop. \ref{prop:proof_subtyping_soundness}),
which, states that the generated subtyping $(\tau_l \subtypes \tau_r)$ holds 
with respect to Model Subtyping (Def. \ref{def:model_subtyping})
if the generated constraints $\Delta'$ hold with respect 
to Model Subtyping Sequence (Def. \ref{def:model_subtyping_sequence}),
Additionally, the guarded subtyping must be satisfiable with respect to the skolem variables
$\Theta' \backslash \Theta$, and it must be valid with respect to the remaining type variables. 


\begin{property}
  \label{prop:proof_subtyping_substance}
  Proof Subtyping Substance 
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
    } {
      \forall \delta \qua \textbf{dom}(\delta) \subseteq \Theta \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta
      \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta'
    }
  \end{mathpar}
\end{property}

The property of Proof Subtyping Soundness is a bit weak on its own. It does not require that 
the subtyping holds, since the property could be met vacuously by having Proof Subtyping 
generate an unsatisfiable set of subtyping constraints.
To ensure that the subtyping holds,
we need Proof Subtyping Substance \ref{prop:proof_subtyping_substance}, 
which requires that the subtyping constraints generated by Proof Subtyping hold. 
The guarded subtyping constraints must be valid with respect to the skolem variables $\Theta$,
and they must be satisfiable with respect to the remaining type variables. 


\begin{definition} 
  \label{def:proof_subtyping}
  Proof Subtyping
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'}
\end{definition}

\noindent
The subtyping relation must consider the forms of both types in the subtyping relation.
There are elimination rules, which make decisions based on the form of the subtype,
and there are introduction rules, which make decisions based on the form of the supertype.
Some rules handle both elimination and introduction of type forms.
Due to the complexity of types and there being two input types,
Proof Subtyping relies on many rules. 
For clarity, we subdivide the Proof Subtyping rules 
according to some themes.

\begin{definition} 
  \label{def:proof_subtyping_reflection}
  Proof Subtyping (Reflection)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta \entails \tau \subtypes \tau \given \Theta, \Delta 
    }
  \end{mathpar}
\end{definition}

\noindent
Proof subtyping is reflexive. In other words, a type
is considered both weaker than and stronger than itself. 
We implicitly assume alpha conversion for variables
bound in indexed unions and indexed intersections.
An algorithmic interpretation could convert to a nameless representation,
such as de Bruijin indexes \cite{} before comparing type forms.

\begin{definition} 
  \label{def:proof_subtyping_implication_preservation}
  Proof Subtyping (Implication Preservation)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \kappa_l \subtypes \kappa_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \tau_l \subtypes \tau_r
      \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails 
      \J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r
      \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails \tau_{x} \subtypes \tau_{p} \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \tau_{q} \subtypes \tau_{y} \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails 
      \tau_{p} \J{->} \tau_{q} 
      \subtypes 
      \tau_{x} \J{->} \tau_{y}
      \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
Both entry types and path types may be viewed as analogs of propositional implication. 
However, unlike the typical separate rules for introduction and elimination in propositional implication,
The Proof Subtyping for each implication types combines the semantics for introduction
and elimination into a single preservation rule.
For entries and paths, Proof Subtyping preserves the form if the type's constituent parts meet certain criteria. 
For entries $(... \entails \J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r \given ...)$,
Proof Subtyping simply checks that the entries' labels match and that 
subtyping holds for their contents.
For paths $(... \entails \tau_{p} \J{->} \tau_{q} \subtypes \tau_{x} \J{->} \tau_{y} \given ...)$
Proof Subtyping simply checks that the antecedent of the subtype
is weaker than the antecedent of the supertype, and the consequent
of the subtype is stronger than the consequent of the supertype. 

\begin{definition} 
  \label{def:proof_subtyping_implication_rewriting}
  Proof Subtyping (Implication Rewriting)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \tau_l \subtypes
      (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r)
      \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \tau_l \subtypes 
      (\tau_a\J{|}\tau_b)\J{->}\tau_r
      \given \Theta', \Delta' 
    }


    \inferrule {
      \Theta, \Delta \entails 
      \tau_l
      \subtypes
      (\tau_r\J{->}\tau_a)
      \J{\&}
      (\tau_r\J{->}\tau_b)
      \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails 
      \tau_l \subtypes 
      \tau_r\J{->}(\tau_{a}\J{\&}\tau_{b})
      \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails 
      \tau
      \subtypes
      (\J{<} l \J{>} \tau_a)
      \J{\&}
      (\J{<} l \J{>} \tau_b)
      \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails 
      \tau \subtypes 
      \J{<} l \J{>} (\tau_{a}\J{\&}\tau_{b})
      \given \Theta', \Delta'
    }

  \end{mathpar}
\end{definition}

\noindent
Just as entries and paths are analogous to propositional implication,
the analogy extends to union and intersection.
Union is analogous to propositional disjunction,
and intersection is analogous to propositional conjunction. 
However, since the Proof Subtyping rules simply preserve implication types,
rather than introducing and eliminating them,
The subtyping logic needs an union antecedent rule, corresponding
to disjunction elimination, and intersection consequent rules,
corresponding to conjunction introduction. 

For elimination of a path with a union antecedent 
$(
... \entails \tau_l \subtypes (\tau_a\J{|}\tau_b)\J{->}\tau_r \given ...
)$, Proof Subtyping breaks apart the union and checks
that the subtype holds against two paths 
whose antecedents are the union's constituent parts. 
For elimination of a path with an intersection consequent 
$(
... \entails \tau_l \subtypes \tau_r \J{->}(\tau_a\J{\&}\tau_b) \given ...
)$, Proof Subtyping breaks apart the intersection and checks
that the subtype holds against two paths 
whose consequents are the intersection's constituent parts. 
For elimination of an entry with an intersection consequent
$(
... \entails \tau \subtypes \J{<}l\J{>} (\tau_a\J{\&}\tau_b) \given ...
)$, Proof Subtyping breaks apart the intersection and checks
that the subtype holds against two entries 
whose consequents are the intersection's constituent parts. 

\begin{definition} 
  \label{def:proof_subtyping_expansion_elimination}
  Proof Subtyping (Expansion Elimination)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \phi \subtypes \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails
      \tau_a \subtypes \tau
      \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails
      \tau_b \subtypes \tau
      \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails
      \tau_a\J{|}\tau_b \subtypes \tau
      \given \Theta'', \Delta'' 
    }

    \inferrule {
      \Theta_l \cap \textbf{ftv}(\Delta) \subseteq \emptyset 
      \\
      \Theta_l \cap \textbf{ftv}(\tau_r) \subseteq \emptyset
      \\
      (\forall \tau, \eta \qua (\tau \J{<:} \eta) \in \Omega \implies \textbf{ftv}(\eta) \subseteq \emptyset) 
      \\\\
      \Theta, \Delta \entails \Omega \given \Theta', \Delta'
      \\
      \Theta' \cup \Theta_l, \Delta' \entails
      \tau_l \subtypes \tau_r \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails
      \J{EXI[}\Theta_l\J{]}\Omega \J{:} \tau_l \subtypes \tau_r
      \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
For elimination of a union $(
... \entails \tau_a\J{|}\tau_b \subtypes \tau \given ...
)$,
Proof Subtyping solves the easier sub-problems
on the union's constituents.
For elimination of an indexed union $(
... \entails \J{EXI[}\Theta_l \J{]} \Omega \J{:}\tau_l \subtypes \tau_r \given ...
)$, 
Proof Subtyping ensures that the indexed union's bound variables
are not free in the super type $\tau_r$. 
Then it finds a solution for the qualifiers $\Delta_l$.
Finally it finds a solution for eliminating the indexed union's body $\tau_l$,
assuming the solution to the qualifiers $\Delta$.

When eliminating the indexed union's body,
the the bound variables $\Theta_l$ must be treated as skolem variables.
Since the indexed union is in the elimination position, 
the qualifiers $\Delta_l$ and its solution $\Delta$ indicate 
the strongest information that can safely be assumed when eliminating the body $\tau_l$.
Marking $\Theta_l$ as skolem variables ensures that Proof Subtyping
does not erroneously learn stronger information on those variables 
in order to prove the elimination of $\tau_l$.
Another requirement for safety is that 
eliminating of $\tau_l$ must hold under all solutions of the qualifiers $\Delta_l$.
Proof subtyping ensures this with the even stronger restriction that the solution
to $\Delta_l$ is unique. That is, instead of letting the proof split into
different worlds and then recombining when necessary, Proof Subtyping simply prevents
splitting the worlds too eagerly. 

\begin{definition} 
  \label{def:proof_subtyping_refinement_introduction}
  Proof Subtyping (Refinement Introduction)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau \subtypes \psi \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails
      \tau \subtypes \tau_{a} \given \Theta', \Delta' 
      \\
      \Theta', \Delta' \entails
      \tau \subtypes \tau_{b} \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails
      \tau \subtypes \tau_{a}\J{\&}\tau_{b} \given \Theta'', \Delta''
    }

    \inferrule {
      \Theta_r \cap \textbf{ftv}(\Delta) \subseteq \emptyset
      \\
      \Theta_r \cap \textbf{ftv}(\tau_l) \subseteq \emptyset
      \\
      (\forall \tau, \eta \qua (\tau \J{<:} \eta) \in \Omega \implies \textbf{ftv}(\eta) \subseteq \emptyset) 
      \\\\
      \Theta, \Delta \given \Omega \given \Theta', \Delta'
      \\
      \Theta' \cup \Theta_r, \Delta' \entails \tau_l \subtypes \tau_r \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails \tau_l \subtypes \J{ALL[}\Theta_r\J{]}\Omega \J{:} \tau_r \given \Theta'', \Delta''
    }
  \end{mathpar}
\end{definition}

\noindent
Refinement introduction is the dual of expansion elimination, so its rules
rely on analogous techniques.

\begin{definition} 
  \label{def:proof_subtyping_variable_elimination}
  Proof Subtyping (Variable Elimination)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \alpha \subtypes \tau \given \Theta', \Delta'} 
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \notin \Theta
      \\
      \Theta, \Delta \entails \Delta[\alpha\slash\tau]^{+} \backslash \Delta \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails \alpha \subtypes \tau \given \Theta', \Delta'\ \alpha\J{<:}\tau
    }

    \inferrule {
      \TODO{update to learn constraints more constraints}
      \\\\
      \alpha \in \Theta 
      % \\
      % \Theta, \Delta \entails \alpha \subtypes \tau \safe
      \\
      \nexists \alpha'  \qua \tau = \alpha'
      \\
      \exists \Theta', \Delta' \qua
      \Theta, \Delta \entails \Delta[\alpha\slash\tau]^{+} \backslash \Delta \given \Theta', \Delta'
      \\\\
      \exists \tau' \qua  \alpha \J{<:} \tau' \in \Delta
      \up 
      (
      (\exists \alpha' \qua \tau' = \alpha' \up \alpha' \notin \Theta) 
      \down 
      (\exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau' \subtypes \tau \given \Theta', \Delta') 
      )
    } {
      \Theta, \Delta \entails 
      \alpha \subtypes \tau
      \given \Theta, \Delta\ \alpha \J{<:} \tau
    }
  \end{mathpar}
\end{definition}

\noindent
Variable elimination has two cases:
one for skolem variables $(\alpha \in \Theta)$
and one for learnable variables $(\alpha \not\in \Theta)$.
For learnable variable elimination, Proof Subtyping simply learns
the subtyping constraint that it's proving.
However, it must check that the constraint is consistent
with the other assumptions of the world.
To check consistency of the subtyping with the assumptions,  
Proof Subtyping leverages Polar Subtyping Sequence Substitution $(
... \entails \Delta[\alpha/\tau]^+ \backslash \Delta \given ...
)$ to ensure that the subtyping constraints still hold with the substitution of
 the supertype $\tau$ into all positive occurrences
of $\alpha$ .

To eliminate a closed variable $(\alpha \in \Theta)$,
Proof Subtyping 
\TODO{...}
A variable may be eliminated if it meets two conditions.
The first condition is that the variable has an upper bound that is either an open variable or can be eliminated.
An upper bound of an open variable indicates that the variable being eliminated
can be as strong as its lower bounds.
The second condition is that all lower bounds of that variable can be eliminated. 
\TODO{...}
which checks that all possible interpretations for $\alpha$
are stronger than $\tau$.

\begin{definition} 
  \label{def:proof_subtyping_variable_introduction}
  Proof Subtyping (Variable Introduction)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau \subtypes \alpha \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \notin \Theta
      \\
      \Theta, \Delta \entails \Delta[\alpha\slash\tau]^{-} \backslash \Delta \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \tau \subtypes \alpha \given \Theta', \Delta'\ \tau\J{<:}\alpha
    }

    \inferrule {
      \TODO{update to learn constraints more constraints}
      \\\\
      \alpha \in \Theta 
      \\
      % \Theta, \Delta \entails \tau \subtypes \alpha \safe
      % \\
      \nexists \alpha' \qua \tau = \alpha'
      \\
      \exists \Theta', \Delta' \qua
      \Theta, \Delta \entails \Delta[\alpha\slash\tau]^{-} \backslash \Delta \given \Theta', \Delta'
      \\\\
      \exists \tau' \qua  \tau' \J{<:} \alpha \in \Delta
      \up 
      (
      (\exists \alpha' \qua \tau' = \alpha' \up \alpha' \notin \Theta) 
      \down 
      (\exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau \subtypes \tau' \given \Theta', \Delta') 
      )
    } {
      \Theta, \Delta \entails 
      \tau \subtypes \alpha 
      \given \Theta, \Delta\ \tau \J{<:} \alpha 
    }
  \end{mathpar}
\end{definition}

\noindent
Variable introduction is the dual of variable elimination, so its rules
rely on analogous techniques.


\begin{definition} 
  \label{def:proof_subtyping_lfp_elimination}
  Proof Subtyping (Least Fixed Point Elimination)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l[\alpha \slash \tau_r]^+ = \tau^\dagger
      \\
      \Theta, \Delta \entails 
      \tau^\dagger \subtypes \tau_r \given 
      \Theta', \Delta'
      \\
      \alpha \not\in \textbf{ftv}(\tau^\dagger)
      \\
      \alpha \not\in \textbf{ftv}(\tau_r)
    } {
      \Theta, \Delta \entails 
      \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r 
      \given \Theta', \Delta' 
    }
  \end{mathpar}
\end{definition}


\noindent
For least fixed point elimination $(
... \entails \J{LFP[} \alpha \J{]} \tau_l \subtypes \tau_r \given ...
)$, 
Proof Subtyping reasons by mathematical induction. 
It substitutes the super type $\tau_r$
into all positive occurrences of the self reference $\alpha$ in the least fixed point body $\tau_l$.
It then solves the elimination of this substitution into the super type 
$(
... \tau^\dagger \subtypes \tau_r \given ...
)$.
Using this polar substitution is stronger than the direct requirement of mathematical induction,
which is that the body is stronger than the supertype $\tau_l \subtypes \tau_r$ 
assuming the induction hypothesis that the self reference is stronger than the super type
$\alpha \subtypes \tau_r$ 

\begin{definition} 
  \label{def:proof_subtyping_difference_intro}
  Proof Subtyping (Difference Introduction)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails\tau \subtypes \rho \typdiff \eta \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \tau \subtypes \rho \given \Theta', \Delta' 
      \\
      \textbf{ftv}(\eta) \subseteq \emptyset
      \\
      \nexists \Theta', \Delta' \qua  
      \Theta, \Delta \entails 
      \tau \subtypes \eta \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \tau \subtypes \rho \typdiff \eta
      \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}

\noindent
For difference introduction $(
... \entails \tau \subtypes \tau_r \typdiff \eta \given ...
)$, 
Proof Subtyping checks that subtyping holds for the positive part 
$(
... \entails \tau \subtypes \rho \given ...
)$.
Then it requires that there are no free variables
in the subtracted part $(
\textbf{ftv}(\eta) \subseteq \emptyset
)$,
and also that introduction of the subtracted part fails $(
  \nexists \Theta', \Delta' .\  
  \Theta, \Delta \entails \tau \subtypes \eta \given \Theta', \Delta'
)$.
The restricted form of a subtracted type $\eta$ and its lack of free variables
ensures that its introduction is complete,
which in turn ensures that its failure is sound.

\begin{definition} 
  \label{def:proof_subtyping_lfp_intro}
  Proof Subtyping (Least Fixed Point Introduction)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \circlearrowleft \J{LFP[} \alpha \J{]} \tau_r
      \\
      \Theta, \Delta \entails
      \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
      \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails
      \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}

\noindent
For least fixed point introduction $(
... \entails \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given ...
)$,
Proof Subtyping employs a heuristic $(
... \entails \tau_l \circlearrowleft \J{LFP[} \alpha \J{]} \tau_r
)$ 
to approximately judge whether or not the subtyping constraint is decidable. 
Once the syntactic forms of the types indicate that a decision can be made,
then Proof Subtyping simply unrolls the least fixed point type 
and solves the new subproblem $(
... \entails \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
\given ...
)$.

\begin{definition} 
  \label{def:proof_subtyping_diff_elimination}
  Proof Subtyping (Difference Elimination)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \rho \typdiff \eta \subtypes \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails 
      \rho \subtypes \eta \J{|} \tau \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails 
      \rho \typdiff \eta \subtypes \tau \given \Theta', \Delta'
    }
  \end{mathpar}
\end{definition}

\noindent
For difference elimination $(
... \entails \rho \typdiff \eta \subtypes \tau \given ...
)$,
Proof Subtyping simply rewrites the problem in terms of union
$(
... \entails \rho \subtypes \tau \J{|} \eta \given ...
)$.

\begin{definition} 
  \label{def:proof_subtyping_expansion_introduction}
  Proof Subtyping (Expansion Introduction)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \tau \subtypes \phi \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \tau_{l} \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Theta', \Delta' 
    }

    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \tau_{r} \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Theta', \Delta' 
    }

    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
      \\\\
      \Theta', \Delta' \entails \Delta_r \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails 
      \tau_l
      \subtypes 
      \J{EXI[}\Theta_r\J{]}\Delta_r \J{:} \tau_r \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
Expansion introduction provides a means for introducing
generalized types from one of their instances.
For union introduction $(
... \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given ...
)$, 
Proof Subtyping can choose from two possible worlds:
one where the left part is introduced $(
... \entails \tau \subtypes \tau_l \given ...
)$,
or one where the right part is introduced $(
... \entails \tau \subtypes \tau_r \given ...
)$. 
For index union introduce $(
... \entails \tau_l \subtypes \J{EXI[}\Theta_r \J{]} \Delta_r \J{:}\tau_r \given ...
)$,
Proof Subtyping constructs potential witnesses by solving the introduction
of the indexed union's body $(
... \entails \tau_l \subtypes \tau_r \given ...
)$, 
where the witnesses can be inferred from the subtyping environment of the world $\Omega$.
It then confirms these are the potential witnesses are valid
by proving the qualifiers hold under such witnesses $(
... \entails \Delta_r \given ...
)$.


\begin{definition} 
  \label{def:proof_subtyping_refinement_elimination}
  Proof Subtyping (Refinement Elimination)
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \psi \subtypes \tau \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_{l} \subtypes \tau \given \Theta', \Delta'
    } {
      \Theta, \Delta \entails \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Theta', \Delta' 
    }

    \inferrule {
      \Theta, \Delta \entails \tau_{l} \subtypes \tau \given \Theta', \Delta' 
    } {
      \Theta, \Delta \entails \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
      \\\\
      \Theta', \Delta' \entails \Delta_l \given \Theta'', \Delta'' 
    } {
      \Theta, \Delta \entails 
      \J{ALL[}\Theta_l\J{]} \Delta_l \J{:} \tau_l
      \subtypes 
      \tau_r
      \given \Theta'', \Delta'' 
    }
  \end{mathpar}
\end{definition}

\noindent
Refinement elimination is the dual of expansion introduction, so its rules
rely on analogous techniques.

\begin{definition} 
  \label{def:proof_sequence_subtyping}
  Proof Sequence Subtyping
  \hfill
  \small
  \boxed{\Theta, \Delta \entails \Delta_q \given \Theta', \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta \entails \epsilon \given \Theta', \Delta'
    }

    \inferrule {
      \Theta, \Delta \entails \tau_l \J{<:} \tau_r \given \Theta', \Delta'
      \\
      \Theta', \Delta' \entails \tau_l \J{<:} \tau_r \given \Theta'', \Delta''
    } {
      \Theta, \Delta \entails \Delta_q\ \tau_l \J{<:} \tau_r \given \Theta'', \Delta''
    }
  \end{mathpar}
\end{definition}

% \begin{definition} 
%   \label{def:unique_proof_subtyping_environment}
%   Unique Proof Subtyping Environment 
%   \hfill
%   \boxed{\Theta, \Delta \entails \Delta_q \given \Theta', \Delta' \unique}
%   \\
%   \begin{mathpar}
%     \inferrule {
%       \TODO{compeleteness of qualifiers is required for soundness}
%       \\\\
%       \TODO{decidable qualifiers are sound and complete}
%       \\\\
%       \Theta, \Delta \entails \Delta_q \given \Theta', \Delta'
%       \\
%       \textbf{decidable}(\Delta_q)
%       \\\\
%       \forall \Theta'', \Delta'' \qua 
%       \Theta, \Delta \entails
%       \Delta_q \given \Theta'', \Delta'' \implies (\Theta'', \Delta'') = (\Theta', \Delta')
%     } {
%       \Theta, \Delta \entails \Delta_q \given \Theta', \Delta' \unique
%     }
%   \end{mathpar}
% \end{definition}


% \section{Experiments}

% \TODO{develop 12 tree/list experiments}

% \section{Related work}

% \TODO{...}


% \paragraph{Tree interpolation}
% Exemplified by CHC duality solver.

% \paragraph{Hindley-Milner type inference}
% Exemplified by ML.

% \paragraph{Logic programming.}
% Exemplified by Prolog. 


% Similar: both have backchaining. 

% Different: RLT is fully declarative, lacks negations, but has implication. 

% Different: RLT allows comparing inductive relations via subtyping. 

% \paragraph{Semantic subtyping.} 
% Exemplified by XDuce and CDuce. complete subtyping.

% Similar: set-like combinators: union and intersection.

% Different: RLT uses rigid syntactic rules; incomplete subtyping.

% % set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% % semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
% The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
% "semantics subtyping" means the semantics of types is determined indirectly by the semantics of another structure.
% "syntactic subtyping" means the semantics of types is determined directly by the type structure

% \paragraph{Extrinsic typing.}
% Exemplified by Typescript, which is unsound. Maybe not as lenient?  
% The static behavior of a program is not necessarily specified/prescribed; 
% it may be over-approximated from the program composition. 
% Intrinsic vs extrinsic is orthogonal to static vs dynamic, although static and dynamic are often used to mean the former.
% All modern languages use a combination of static and dynamic type checking.
% The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
% even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.

% \paragraph{Refinement Types.}
% Exemplified by Refinement ML. Base types with intersections and subtyping.

% \paragraph{Predicate Subtyping.}
% Exemplified by Liquid Types. An extension of refinement types.

% Similar: both use type inference to infer expressive relational properties. 

% Different: RLT starts with an invalid post-condition, then weakens return type to a valid post-condition from outside in by expanding unions.

% Different: RLT starts with an invalid pre-condition, then strengthens parameter type to a valid pre-condition from inside out by adding intersections.

% Different: Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.


% \paragraph{Abstraction Refinement.} 
% Similar: type unification over subtyping resembles abstraction refinement  
% where solving for variables and failing on different sides of the subtyping relation corresponds to
% solving with the abstractor vs solving with the refiner.

% \paragraph{Craig interpolation.} 
% Similar: extracting an recursive type with unions and intersections 
% from a recursive program without needing to specify a predicate universe might be similar to
% craig interpolation.

% \paragraph{PDR.}
% exemplified by IC3. 

% Similar: RLT infers abstract type for return type, 
% then safely constrains the variables in previous step (fix's antecedent) 
% to subtype the least fixed point.
% This lazily propagates the type for the last step to the previous steps.
% This is safe as antecedent is stronger than consequent at any step.
% Seems similar to the notion in PDR of propagating negation of loss points to previous steps. 

% Different: RLT isn't cartesian


\section{Experiments}
\label{sec:experiments}



\noindent
We performed experiments to see how type inference performs on both parametric data and structural data. 
These two categories have historically been tackled independently of each other, where parametric types
tend to rely on notions of instantiation, and structural types rely on notions of equality or subtyping.
Our system unifies these historically distinct problems by describing both kinds of types in terms of subtyping.
However, the distinction is useful for comparing our design to previous work. 

We implemented an extrinsic type inference system that corresponds to the predicate definitions
presented thus far. 
To observe the expressiveness of our system on parametric data, 
we evaluated our implementation on the same suite of programs 
that SuperF was evaluated on, as presented in the paper on SuperF \cite{}.
Based on these experiments, our system all programs admitted by SuperF, as well as some programs 
that SuperF is unable to admit.
Thus, our system appears to be more expressive on parametric data than the previous most expressive
type inference system that we know of.
To observe the expressiveness of our system on structural data, 
we constructed simple programs that represent the kind of flexible and reusable code
often found programs written in untyped scripting languages. 
We ran these examples in our implementation, and created analogous version to run
in the online implementation of MLScript \cite{},
which represents the theoretical system MLStruct \cite{}. 
All of these examples are admitted by our system, while MLStruct
can either requires intrinsic specifications to admit the program, 
or simply can't admit the program.



\begin{definition} Experimental Expressions and Types  
  \label{def:experimental_expressions_and_types}
  \scriptsize
  \[
  \begin{array}[t]{ll}
    \begin{array}[t]{r@{}c@{}l}
      \textbf{Bool} 
      &\ \ =\ \ & 
      \J{(<true>@ | <false>@)} 
      \\
      \textbf{Nat} 
      &\ \ =\ \ & 
      \J{(LFP[R] <zero>@ | <succ>R)} 
      \\
      \textbf{Even} 
      &\ \ =\ \ & 
      \J{(LFP[R] <zero>@ | <succ><succ>R)} 
      \\
      \textbf{List}(\alpha) 
      &\ \ =\ \ & 
      \J{(LFP[R] <nil>@ | <cons>((}\alpha\J{)*R))} 
      \\
      \textbf{ChurchNum} 
      &\ \ =\ \ & 
      \J{(ALL[T] (T -> T) -> T -> T)}
    \end{array}
    &
    \begin{array}[t]{r@{}c@{}l}
      \textbf{ST}(\alpha^\dagger, \alpha) 
      &\ \ =\ \ & 
      \J{(<tag>(}\alpha^\dagger \J{) <result>(} \alpha \J{))}
      \\
      \textbf{z} 
      &\ \ =\ \ & 
      \J{\{f => \{x => x\}\}} 
      \\
      \textbf{s} 
      &\ \ =\ \ & 
      \J{\{n => \{f => \{x => f(n(f(x)))\}\}\}} 
      \\
      \textbf{n3} 
      &\ \ =\ \ & 
      \textbf{s}\J{(}\textbf{s}\J{(}\textbf{s}\J{(}\textbf{z}\J{)}\J{)}\J{)} 
    \end{array}
  \end{array}
  \]
\end{definition}

\noindent
For clarity, we define a few metalinguistic terms to stand in for 
types and expressions used as inputs to our system. 

\begin{definition} Experimental Typing Context  
  \label{def:experimental_typing_context}
  \scriptsize
  \[
  \begin{array}[t]{ll}
    \begin{array}[t]{r@{}c@{}l}
      \textbf{ctx} & = &  \hfill
      \\
      \J{head} &\J{ : }& \J{ALL[T] }\textbf{List}(\J{T})\J{ -> T}
      \\
      \J{tail} &\J{ : }& \J{ALL[T] }\textbf{List}(\J{T})\J{ -> }\textbf{List}(\J{T})
      \\
      \J{nil} &\J{ : }& \J{ALL[T] }\textbf{List}(\J{T})
      \\
      \J{single} &\J{ : }& \J{ALL[T] T -> }\textbf{List}(\J{T})
      \\
      \J{append} &\J{ : }& \J{ALL[T] }\textbf{List}(\J{T}) \J{ -> } \textbf{List}(\J{T}) \J{ -> } \textbf{List}(\J{T})
      \\
      \J{length} &\J{ : }& \J{ALL[T] }\textbf{List}(\J{T}) \J{ -> } \textbf{Nat}
      \\
      \J{const} &\J{ : }& \J{ALL[T U] T -> U -> T}
      \\
      \J{id} &\J{ : }& \J{ALL[T] T -> T}
      \\
      \J{ids} &\J{ : }& \textbf{List}(\J{ALL[T] T -> T}\J{)}
      \\
      \J{inc} &\J{ : }& \textbf{Nat}\J{ -> }\textbf{Nat}
      \\
      \J{choose} &\J{ : }& \J{ALL[T] T -> T -> T}
      \\
      \J{poly} &\J{ : }& \J{(ALL[T] T -> T) -> } \textbf{Nat}\J{*}\textbf{Bool}
      \\
      \J{fst} &\J{ : }& \J{ALL[T U] T*U -> T}
      \\
      \J{sort} &\J{ : }& \J{ALL[T] (T * T -> } \textbf{Bool} \J{) -> }\textbf{List}(\J{T})\J{ -> }\textbf{List}(\J{T})
      \\
      \J{scalarCmp} &\J{ : }& \textbf{Nat} \J{\*} \textbf{Nat} \J{ -> } \textbf{Bool} 
      \\
      \J{lexicoCmp} &\J{ : }& \textbf{List}(\textbf{Nat}) \J{\*} \textbf{List}(\textbf{Nat}) \J{ -> } \textbf{Bool} 
    \end{array}
    &
    \begin{array}[t]{r@{}c@{}l}
      \\
      \J{auto} &\J{ : }& \J{(ALL[T] T -> T) -> (ALL[T] T -> T)}
      \\
      \J{auto'} &\J{ : }& \J{ALL[U] (ALL[T] T -> T) -> U -> U}
      \\
      \J{map} &\J{ : }& \J{ALL[T U] (T -> U) -> } \textbf{List}(\J{T}) \J{ -> } \textbf{List}(\J{U})
      \\
      \J{app} &\J{ : }& \J{ALL[T U] (T -> U) -> T -> U}
      \\
      \J{revapp} &\J{ : }& \J{ALL[T U] T -> (T -> U) -> U}
      \\
      \J{runST} &\J{ : }& \J{ALL[T] (ALL[U] } \textbf{ST}(\J{U}, \J{T})\J{) -> T}
      \\
      \J{argST} &\J{ : }& \J{ALL[U] } \textbf{ST}(\J{U}, \textbf{Nat})
      \\
      \J{zero} &\J{ : }& \textbf{ChurchNum}
      \\
      \J{succ} &\J{ : }& \textbf{ChurchNum} \J{ -> } \textbf{ChurchNum}
      \\
      \J{foo} &\J{ : }& \J{ALL[T] (T -> T) -> } \textbf{List}(\J{T}) \J{ -> T}
      \\
      \J{g} &\J{ : }& \J{ALL[T] }\textbf{List}(\J{T}) \J{ -> } \textbf{List}(\J{T}) \J{ -> T}
      \\
      \J{k} &\J{ : }& \J{ALL[T] T -> } \textbf{List}(\J{T}) \J{ -> T}
      \\
      \J{h} &\J{ : }& \textbf{Nat} \J{-> ALL[T] T -> T}
      \\
      \J{l} &\J{ : }& \textbf{List}(\J{ALL[T] } \textbf{Nat} \J{ -> T -> T}\J{)}
      \\
      \J{r} &\J{ : }& \J{(ALL[T] T -> ALL[U] B -> B) -> }\textbf{Nat}
    \end{array}
  \end{array}
  \]
\end{definition}

\noindent
Additionally, for the purpose of experiment, it is useful to assume that   
the typing of some identifiers have already been learned or verified.

\begin{experiment}
  \label{experi:parametric_data_part_1}
  Parametric Data (Part 1) 
  \\
  \scriptsize
  % \setlength{\arrayrulewidth}{0.5mm}
  % \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{center}
  \centering
  % \setlength{\tabcolsep}{2pt}
  \begin{tabular}{|l m{30em} || >{\centering}m{5em} || >{\centering}m{5em} | >{\centering\arraybackslash}m{5em} |} 
    \multicolumn{5}{l}{
      \sz{
      Does $ impl(\textbf{ctx}\entails e)
      $ admit the expression? 
      }
      \sz{
      \pass\ yes \ \ $\cdot$\ \ \fail\ no \ \ $\cdot$\ \ \assisted\ conditionally w/ annotations 
      }
    } \\
    \hline
    \multicolumn{2}{|c||}{} & \multicolumn{3}{c|}{$impl$} \\ 
    \hline
    \multicolumn{2}{|c||}{$e$} & \textbf{Extrinsic} & \textbf{SuperF} & \textbf{SF no D} \\ 
    \hline\hline
    \pdc. &
    \J{\{x => \{y => y\}\}} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{choose(id)} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{choose(nil)(id)} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{\{x => x(x)\}} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{id(auto)} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{id(auto')} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{choose(id)(auto)} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{choose(id)(auto')} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{foo(choose(ids))(ids)} 
    & \fail & \pass & \pass \\
    \hline
    \pdc. &
    \J{poly(id)} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{poly(\{x => x\})} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{id(poly)(\{x => x\})} 
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{\{f => f(succ;zero;@), f(true;@)\}}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{\{xs => poly(head(xs))\}}
    & \pass & \pass & \pass \\
    \hline
  \end{tabular}
  \end{center}
\end{experiment}

\noindent
In the experiment on parametric data, we 
are interested to observe if our implementation (\textbf{Extrinsic})
can admit various programs on parametric data. 
For our implementation, we reject a program if the implementation
finds a contradiction, diverges, or infers the top type. 
In our system, we infer a top type when the top level 
expression represents a function and all of its branches 
have errors. Since the top level function is not applied,
the program technically cannot produce an error, but it's 
perfectly useless and would produce an error if applied to any value. 
We compare our system to SuperF and Super without Distributivity (\textbf{SF no D}). 

% $\approx \exists \tau, \Delta, \Theta \qua \epsilon, \epsilon, \textbf{ctx} \entails e \hastype \tau \given \Theta, \Delta$ 

\begin{experiment}
  \label{experi:parametric_data_part_2}
  Parametric Data (Part 2) 
  \\
  \begin{center}
  \scriptsize
  % \setlength{\arrayrulewidth}{0.5mm}
  \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{|l m{30em} || >{\centering}m{5em} || >{\centering}m{5em} | >{\centering\arraybackslash}m{5em} |} 
    \multicolumn{5}{l}{
      \sz{
      Does $ impl(\textbf{ctx}\entails e)
      $ admit the expression? 
      }
      \sz{
      \pass\ yes \ \ $\cdot$\ \ \fail\ no \ \ $\cdot$\ \ \assisted\ conditionally w/ annotations 
      }
    } \\
    \hline
    \multicolumn{2}{|c||}{} & \multicolumn{3}{c|}{$impl$} \\ 
    \hline
    \multicolumn{2}{|c||}{$e$} & \textbf{Extrinsic} & \textbf{SuperF} & \textbf{SF no D} \\ 
    \hline\hline
    \pdc. &
    \J{length(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{tail(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{head(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{single(id)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{cons(id)(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{cons(\{x => x\})(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{append(single(inc))(single(id))}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{g(single(id))(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{map(poly)(single(id))}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{map(head)(single(ids))}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{app(poly)(id)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{revapp(id)(poly)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{runST(argST)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{app(runST)(argST)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{revapp(argST)(runST)}
    & \pass & \pass & \pass \\
    \hline
  \end{tabular}
  \end{center}
\end{experiment}

\begin{experiment}
  \label{experi:typing_parameters_part_3}
  Typing Parameters (Part 3) 
  \\
  \begin{center}
  \scriptsize
  % \setlength{\arrayrulewidth}{0.5mm}
  \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{|l m{30em} || >{\centering}m{5em} || >{\centering}m{5em} | >{\centering\arraybackslash}m{5em} |} 
    \multicolumn{5}{l}{
      \sz{
      Does $ impl(\textbf{ctx}\entails e)
      $ admit the expression? 
      }
      \sz{
      \pass\ yes \ \ $\cdot$\ \ \fail\ no \ \ $\cdot$\ \ \assisted\ conditionally w/ annotations 
      }
    } \\
    \hline
    \multicolumn{2}{|c||}{} & \multicolumn{3}{c|}{$impl$} \\ 
    \hline
    \multicolumn{2}{|c||}{$e$} & \textbf{Extrinsic} & \textbf{SuperF} & \textbf{SF no D} \\ 
    \hline\hline
    \pdc. &
    \J{k(h)(l)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{k(\{x => h(x)\})(l)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{r(\{x => \{y => y\}\})}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{auto(id)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{cons(head(ids))(ids)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{head(ids)(succ;succ;succ;zero;@)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{choose(head(ids))}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{let f = revapp(id) in f(poly)}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{choose(id)(\{x => auto'(x)\})}
    & \pass & \pass & \pass \\
    \hline
  \end{tabular}
  \end{center}
\end{experiment}

\begin{experiment}
  \label{experi:parametric_data_part_4}
  Parametric Data (Part 4)
  \\
  \begin{center}
  \scriptsize
  % \setlength{\arrayrulewidth}{0.5mm}
  \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{|l m{30em} || >{\centering}m{5em} || >{\centering}m{5em} | >{\centering\arraybackslash}m{5em} |} 
    \multicolumn{5}{l}{
      \sz{
      Does $ impl(\textbf{ctx}\entails e)
      $ admit the expression? 
      }
      \sz{
      \pass\ yes \ \ $\cdot$\ \ \fail\ no \ \ $\cdot$\ \ \assisted\ conditionally w/ annotations 
      }
    } \\
    \hline
    \multicolumn{2}{|c||}{} & \multicolumn{3}{c|}{$impl$} \\ 
    \hline
    \multicolumn{2}{|c||}{$e$} & \textbf{Extrinsic} & \textbf{SuperF} & \textbf{SF no D} \\ 
    \hline\hline
    \pdc. &
    \J{let ignore : } \textbf{ChurchNum} \J{ = z in @}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{s}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{let ignore : } \textbf{ChurchNum} \J{ -> } \textbf{ChurchNum} \J{ = s in @}
    & \pass & \pass & \fail \\
    \hline
    \pdc. &
    \J{let ignore : } \textbf{ChurchNum} \J{ = n3 in @}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{let ignore : } \J{@ -> }\textbf{ChurchNum} \J{ = \{@ => n3(n3)\} in @}
    & \pass & \pass & \fail \\
    \hline
    \pdc. &
    \J{fst(fst(fst(n3(\{x => x,(zero;@)\})(succ;zero;@))))}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{(s(s(z)))(s(s(z)))}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \begin{array}[t]{l}
      \J{let to\_church = loop(\{self => } 
      \\
      \I \J{\{zero;@ => z\}}
      \\
      \I \J{\{succ;n => s(self(n))\}}
      \\
      \J{\}) in ...}
    \end{array}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{let ignore : } \textbf{Nat} \J{ -> } \textbf{ChurchInt} \J{ = to\_church in @}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \J{loop(\{self => \{x => if true;@ then x else self(self)(x)\}\}} 
    & \fail & \fail & \fail \\
    \hline
    \pdc. &
    \J{\{x => x(x)\}(\{x => x(x)\})}
    & \pass & \fail & \fail \\
    \hline
    \pdc. &
    \J{auto(auto'(id))}
    & \pass & \pass & \fail \\
    \hline
    \pdc. &
    \J{\{k => (k(\{x => x\})),(k(\{x => single(x)\})) \}(\{f => (f(succ;zero;@)),(f(true;@))\})}
    & \pass & \pass & \pass \\
    \hline
    \pdc. &
    \begin{array}[t]{l}
      \J{\{f => } 
      \\
      \I \J{let a = \{@ => f(id)\} in }
      \\
      \I \J{let y : } \textbf{Nat} \J{ -> (ALL[T] T -> T) = a(@) in }
      \\
      \I \J{y}
      \\
      \J{\}(const(const(id)))}
    \end{array}
    & \pass & \fail & \pass \\
    \hline
  \end{tabular}
  \end{center}
\end{experiment}


\begin{experiment}
  \label{experi:typing_structures}
  Typing Structures 
  \\
  \begin{center}
  \scriptsize
  % \setlength{\arrayrulewidth}{0.5mm}
  \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{|l m{35em} || >{\centering}m{5em} || >{\centering\arraybackslash}m{5em} |} 
    \multicolumn{4}{l}{
      \sz{
      Does $ impl(\textbf{ctx}\entails e)
      $ admit the expression? 
      }
      \sz{
      \pass\ yes \ \ $\cdot$\ \ \fail\ no \ \ $\cdot$\ \ \assisted\ conditionally w/ annotations 
      }
    } \\
    \hline
    \multicolumn{2}{|c||}{} & \multicolumn{2}{c|}{$impl$} \\ 
    \hline
    \multicolumn{2}{|c||}{$e$} & \textbf{Extrinsic} & \textbf{MLStruct} \\ 
    \hline\hline
    \sdc. &
    \begin{array}[t]{l}
      \J{let stdCmp = \{ a,b => } 
      \\
      \I \J{a |> (}
      \\
      \I\I \J{\{zero;@ => scalarCmp(a,b)\}}
      \\
      \I\I \J{\{succ;n => scalarCmp(a,b)\}}
      \\
      \I\I \J{\{nil;@ => lexicoCmp(a,b)\}}
      \\
      \I\I \J{\{cons;(x,xs) => lexicoCmp(a,b)\}}
      \\
      \I \J{)}
      \\
      \J{\} in ...}
    \end{array}
    & \pass & \assisted \\
    \hline
    \sdc. &
    \begin{array}[t]{l}
      \J{let stdSort : (TOP } 
      \\
      \I \J{ \& (} \textbf{List}(\textbf{Nat}) \J{ -> } \textbf{List}(\textbf{Nat}) \J{)}
      \\
      \I \J{ \& (} \textbf{List}(\textbf{List}(\textbf{Nat})) \J{ -> } \textbf{List}(\textbf{List}(\textbf{Nat})) \J{)}
      \\
      \J{) = sort(stdCmp) in ...} 
    \end{array}
    & \fail & \assisted \\
    \hline
    \sdc. &
    \begin{array}[t]{l}
      \J{let double : } \textbf{Nat} \J{ -> } \textbf{Even} \J{ = loop(\{self => } 
      \\
      \I \J{\{zero;@ => zero;@\}}
      \\
      \I \J{\{succ;n => succ;succ;(self(n))\}}
      \\
      \J{\}) in ...}
    \end{array}
    & \pass & \fail \\
    \hline
    \sdc. &
    \begin{array}[t]{l}
      \J{let halve : } \textbf{Even} \J{ -> } \textbf{Nat} \J{ = loop(\{self => } 
      \\
      \I \J{\{zero;@ => zero;@\}}
      \\
      \I \J{\{succ;succ;n => succ;(self(n))\}}
      \\
      \J{\}) in ...}
    \end{array}
    & \pass & \fail \\
    \hline
    \sdc. &
    \begin{array}[t]{l}
      \J{\{zero;@ => \{zero;@ => @\}(@)\}}
      \\
      \J{\{nil;@ => @\}}
    \end{array}
    & \pass & \fail \\
    \hline
  \end{tabular}
  \end{center}
\end{experiment}

\noindent
The experiment on programs with structural data demonstrate
that our system is roughly as expressive as untyped languages
without sacrificing safety guarantees.
Our system can easily mix structures together, reducing
the need for programmers to call different interfaces for different data.  
If there is an error in one branch of a function, the
system can still admit the program by ensuring 
that the erroneous branch is never used, and there
is at least one branch that could be used.


\section{Related Work}
\label{sec:related_work}

Over the past decades many type inference have been designed and analyzed 
with varying degrees of expressivity and varying degrees of intrinsic requirements
or extrinsic relaxations, with respect to both parametric data (e.g. functions or paths dependent on variables)
and structural data (e.g. data constructors or records).  
The first technique to infer parametric types for parametric
data without any assistance from annotations was Hindley-Milner type inference \cite{}. Despite its age, 
it remains one of the foundational 
theoretical underpinnings of practical programming languages used today, such as Standard ML \cite{}. 
For instance, in Standard ML, the system infers the identifier $\J{foo}$ in $(\J{fun foo f = (f 123);})$
to have type $(\J{forall 'a . (int -> 'a) -> 'a})$ 
Despite its practical utility, a significant drawback of Hindley-Milner type inference is that
certain kinds of flexible programs are simply not allowed.
For instance, in Standard ML, the system rejects the program $(\J{fun fooPair f = (f 123, f true);})$.

In order to type the program $\J{fooPair}$, a type system would either need to determine that
$\J{f}$ is parametric, or that the types of $\J{123}$ and $\J{true}$ are compatible.
Treating the parameter $\J{f}$ is allowed in systems that have impredicative parametric polymorphism \cite{}, which
was introduced into ML-style languages using boxed polymorphism \cite{} and developed further with ML$^F$ \cite{}. 
Unfortunately, it's not clear what parametric type should be inferred for $\J{f}$.
For instance, $(\J{forall 'a . 'a -> 'a})$, $(\J{forall 'a . 'a -> 'a list})$, $(\J{forall 'a . 'a -> 'a option})$, 
or an infinite number of
other parametric types could be used, but none is weaker than all the rest.
Therefore, these systems with impredicative parametric polymorphism rely on annotations of parameters to
determine second order parametric types, which we believe constitutes intrinsic typing of
of parametric data. Since there is no parameter type that is weaker than all the rest,
relying on intrinsic second order parametric type significantly restricts the reusability
of the program.

In order to avoid this loss of expressivity and the annotation burden of intrinsic typing, 
SuperF \cite{} introduced 
a technique that relies on extrinsic subtyping polymorphism, 
which bypasses the need for intrinsic parametric polymorphism.
In the previous example, SuperF can infer the principal type for $\J{fooPair}$ by inferring the 
weakest type of its parameter $\J{f}$, which it achieved by leveraging subtyping to find 
a type that is compatible with both $\J{123}$ and $\J{true}$.
The SuperF type system infers subtyping constraints that represent the data flow represented by
function application and pattern matching. It relies 
intersection and union type combinators to represent the strongest or weakest interpretations
of type variables that meet certain subtyping constraints.   
With SuperF's type inference mechanism, it is possible to infer the principal type for the 
previous problematic example $\J{fooPair: (forall 'a 'b . (int -> 'a) /\textbackslash\ (bool -> 'b) -> 'a * 'b)}$.

SuperF has a restricted language of types. It is concerned with the type inference
of parametric data, and it is agnostic towards type inference of structural data. 
It restricts the type and subtyping constraint syntax according to polarity; that is, a
types position within an implication type or subtyping relation. Depending on polar position,
universal types (i.e. indexed intersections) may or may not be qualified by subtyping constraints.
The authors of SuperF highlight some technical features, including extrusion and distributivity.
Their extrusion technique ensures that types are not overly specialized
when inferring types of nested parametric data. Their distributivity technique allows
rewriting universal quantifiers to increase the chance that skolemization occurs before instantiation. 
They point out that the distributivity rule is an improvement for most cases, but there are certain
problems for which it more actually more restrictive.


The high level ideas in SuperF of relying on subtyping constraints were very influential in our work.
Like SuperF, our system relies syntax-directed subtyping rules to check constraints and to learn 
new subtyping constraints by traversing previously learned constraints;
Additionally, our system also relies on instantiation and skolemization in its subtyping rules. 
Type polarity is also important in our system.
However, our system does not restrict the syntax of types based on polarity. Instead, we rely on
polarity to constrain Proof Typing and Proof Subtyping when interpreting or checking interpretations
of type variables.    
Our system does not need extrusion because Packing $(\textbf{pack(...)})$ preserves the nested structure of 
parametric data at the type level, such that the constraint between inner and outer bound type variables
qualifies the inner parametric type, which ensures that instantiation of the inner parametric type 
continues to constrain the outer bound type variables.  
Our system does not need distributivity of type variable bindings, because it is requires
that skolemization occurs before learning constraints on type variables. Therefore, it is fine to allow
instantiation to occur before skolemization in our system, 
since it does not cause learning constraints before skolemization.  

\TODO{look into what SuperF folks mean by no backtracking in light of rhs union}

In addition to parametric data, practical programming languages need to have some form of structural data.
Although Hindley-Milner type inference offered an extrinsic type inference solution for predicative parametric data
very early on, type inference has always relied on some degree of intrinsic types for structural data.
intrinsically typed structural data is exemplified by the datatype mechanism of Standard ML.
For instance, the list datatype $(\J{'a list = nil | cons 'a * 'a list})$ specifies that 
data constructed with ${\J{nil}}$ or $\J{cons}$ have the type ${\J{'a list}}$. Additionally,
it requires that the input to the constructor $(\J{cons})$  has the types $(\J{'a * 'a list})$
Although the datatype mechanism has been used with great success across many languages (including Lean, Haskell, Ocaml, and Isabelle),
it enforces a very rigid form of programming. For instance, there is no way to guarantee
that the output of a function is a nonempty list and then use that output in a function that expects an optionally empty list.

To get around this limitation, refinement types \cite{} relaxed the meaning of the datatype mechanism, to 
allow constructions to represent types that are stronger than their intrinsic type.
For instance, $(\J{nil})$ could have a type as strong as the single type $\J{?nil}$ or as weak as $(\J{'a list})$.
Likewise, a list of two elements $\J{cons(x, cons(y, nil))}$ could have a type as strong $(\J{?cons 'a * (?cons 'a * nil)})$
or as weak as $(\J{'a list})$. A refinement type system can choose how strong to make the type based on how the data is used, 
which depends on how data flows, for which subtyping provides a natural formulation. 
It can find these stronger types by starting with intrinsic weakest type and using intersection with 
all the ways it sees the data being used.
However, the refinement relaxation is not enough to allow common flexible idioms used in untyped languages. 
For instance, it would allow pattern matching that chooses between a list and a number.

To allow arbitrary mixing of constructions in pattern matching, the extrinsic type of constructions
must be abolished so that there is no intrinsic weakest type other than a top type. 
Typescript \cite{} does not have an intrinsic weakest type for structural data,
and it can infer output types of functions that return different structural forms in different branches.
However, it is unable to infer a weak type for the parameters, and thus requires annotation of parameters.  
Typescript and other systems for scripting languages, rely on flow-sensitive, or occurrence typing \cite{},
which can refine the types of variables in branches based on the condition guarding each branch.
For Typescript, this flow information is only used in one direction, and it is not leveraged to infer
the weakest type of parameters.

To extend type inference of scripting languages further, MLStruct \cite{} and others like MLSub \cite{}, 
leveraged the flow information to infer both input types and output types of functions.
MLStruct, along with SuperF, represents some of the foundational ideas of the MLScript language.
Like SuperF, it learns the data flow of programs in terms of subtyping constraints.
Other than our system, it appears that MLStruct has the best type inference of structural data
with the least amount of intrinsic type requirements. 
However, MLStruct still has a significant intrinsic type requirement, which reduces flexibility compared
to untyped languages. It requires that the inputs to data constructors have an intrinsic type.  
In essence, this requirement prescribes a lower bound on data constructions,
which reduces the flexibility of programs compared to untyped languages. 
As our tests (Experiment \ref{experi:typing_structures})
illustrate, it is not possible to type a function that expects only even numbers that is interoperable with natural numbers.
Moreover, the additional annotation burden alone would prevent the analysis of untyped code without
significant effort in augmenting the code with annotations.
In contrast to MLStruct, our system relies completely on learning data flow in the form of subtyping constraints
without any annotation requirements on structural data. 

The common ingredient in all of these systems that perform some amount of extrinsic type inference is
learning data flow. Data flow analysis comes in many forms. As the goal for these systems is verification,
subtyping is a natural choice. There has been some work on extracting rules for checking subtyping relations
from the semantic interpretation of types, known as semantic subtyping \cite{}, or set-theoretic types \cite{}.
Other approaches, like algebraic subtyping \cite{}, and Cretin \cite{}, and superF, 
rely on designing syntax-directed subtyping rules and then proving their soundness with respect to some semantic interpretation. 
Additionally, there are similarities between type inference with subtyping and control-flow analysis \cite{}, or polyvariant flow analysis \cite{}.
In control-flow analysis, expressions can be associated with a label, and each label can map to a set of abstract values,
determined by learning subset constraints from the control-flow of the program. 
Instead of labels, type inference with subtyping associate types  
with expressions and learns subtyping constraints.

\TODO{discuss recursive types}

\TODO{discuss regular trees}

\TODO{look into the issue of caching related to recursion}


\section{Conclusion}
\label{sec:conclusion}
We have presented a novel extrinsic type inference system
that can guarantee programs are bug-free while maintaining
code-reusability nearly on par with untyped scripting languages,
and exceeding that of an previous type inference system we know of.  
We have incorporated previous studied ideas of subtyping constraints,
intersection types, union types, parametric types, and recursive types into
a cohesive design that enables more principal types to be inferred 
and more subtyping relations to be verified than in previous systems. 
In particular, our system is able to learn recursive types of function inputs
and outputs purely from the construction of recursive functions without 
any intrinsic recursive type specifications.
Additionally, our system can perform inductive reasoning to
verify than one recursive type subtypes another.
In the future, we will extend the recursive type reasoning capabilities
to handle recursive relational types, enabling the infinite paths
of recursive functions to be represented and reasoned with at the type level. 
With inductive reasoning over relational types, we will be
moving closer to a full fledged theorem proving system,
in which subtyping enables a form of proof automation,
by reusing the proof of one proposition as a proof for another. 

\newpage

\begin{thebibliography}{9}

% \bibitem{syngar}
% X. Wang, I, Dillig, R. Singh. Program synthesis using abstraction refinement. In POPL, 2017.

% \bibitem{love}
% M. Heizmann, J. Hoenicke, A. Podelski. Software model checking for people who love automata. In CAV, 2013. 

% \bibitem{synquid}
% N. Polikarpova, I. Kuraj, A. Solar-Lezama. Program synthesis from polymorphic refinement types. In PLDI, 2016.

\end{thebibliography}


\newpage



\section{Ancillaries}
\label{sec:ancillaries}

\TODO{add collection concatentation definition (oplus)}

\TODO{read through definitions and update syntax}

\TODO{organize descriptions}

\TODO{describe the important properties in depth}

\begin{definition}
  \label{def:function_type_explosion}
  Function Type Explosion 
  \hfill 
  \small
  \boxed{\Theta, \Delta \entails \tau \subtypes \alpha \rightarrow \Pi}
  \\
  \begin{mathpar}
    \inferrule {
      % (\forall \Theta', \Delta' \qua 
      % \Theta' \backslash \Theta, 
      % \Delta' \backslash \Delta, 
      % \llbracket \textbf{ftv}(\Delta) \cup \Theta', \Delta' \entails \alpha_l \J{->} \alpha_r \rrbracket^+ 
      % \in \Pi
      % \implies
      % \Theta, \Delta \entails \tau \subtypes \alpha \J{->} \alpha_l \J{->} \alpha_r \given \Theta', \Delta' 
      % )
      % \\\\
      (\forall \Theta', \Delta' \qua 
      \Theta' \backslash \Theta, 
      \Delta' \backslash \Delta, 
      \alpha_l \J{->} \alpha_r 
      \in \Pi
      \implies
      \Theta, \Delta \entails \tau \subtypes \alpha \J{->} \alpha_l \J{->} \alpha_r \given \Theta', \Delta' 
      )
      \\\\
      \exists \Theta, \Delta, \tau \qua (\Theta, \Delta, \tau) \in \Pi
      \\
      \textbf{ftv}(\Delta) \entails \Pi \searrow \Pi'
    } {
      \Theta, \Delta \entails \tau \subtypes \alpha \rightarrow \Pi'
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{...}

\begin{definition} 
  \label{def:path_sequence_typing}
  Path Sequence Typing 
  \hfill
  \small
  \boxed{\Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta, \Delta, \Gamma \entails \epsilon \liftfun \epsilon \sim \epsilon 
    }

    \inferrule {
      \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
      \\
      p \hastype \rho \given \Gamma'
      \\
      \text{diff}(\rho, \Xi) = \tau_l
      \\
      \Theta \cup \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) = \dTheta
      \\\\
      (\forall \Theta', \Delta', \tau_r  \qua 
      \Theta' \backslash \Theta, 
      \Delta' \backslash \Delta, 
      \tau_l \J{->} \tau_r \in \Pi'
      \implies
      \Theta, \Delta, \Gamma \oplus \Gamma' \entails e \hastype \tau_r \given \Theta', \Delta' 
      )
      \\\\
      \exists \Theta, \Delta, \tau  \qua (\Theta, \Delta, \tau) \in \Pi'
      \\
      \text{capture}(\rho) = \eta
      \\
      \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) \entails \Pi' \searrow \Pi'' 
    } {
      \Theta, \Delta, \Gamma \entails f\ \J{?}p\J{=>}e \liftfun 
      \Pi \cup \Pi'' \sim \Xi\ \eta
    }
  \end{mathpar}
\end{definition}



\noindent
Path sequence typing $(\Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi)$
handles the details of constructing types for each path of a function.
Progression of application tries each path of the applied function is in order.
That is, the application will progress along the first path whose pattern
matches the argument.
To account for this ordering and short-circuiting of pattern matching,
the types for each path of the function must subtract the types of patterns
from earlier paths $\Xi$ when constructing antecedents of path types.  
Each path of the function could branch out,
represented by the typing $(\Gamma \oplus \Gamma' \entails e \hastype \tau_r \given ...)$, 
so each function path can produce multiple path types $(\tau_l \J{->} \tau_r)$, 
which are collected in $\pi'$.

\TODO{explain the tidy up relation}
Keeps things tidy by compacting the subtyping environments and making the path
types more readable.

\begin{property} 
  \label{prop:schema_sequence_duality_correspondence}
  Schema Sequence Duality Correspondence
  \\
  \begin{mathpar}
    \inferrule {
      \alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu
      \\
      \delta \satisfies \Delta
    } {
      (
      \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua
      (\Theta^\dagger,\Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
      \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \cong \Theta^\dagger \up
      \\\\
      (
      \forall \delta' \qua
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \epsilon \implies
      \\\\
      \delta\ \alpha_\nu \slash \J{BOT} \oplus \delta' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
      \delta\ \alpha_\nu \slash \J{BOT} \oplus \delta' \oplus \delta^\dagger \satisfies e_f \hastype \tau^\dagger
      )
      )
      \\\\
      \iff
      \\\\
      (\forall e_a, e_r \qua
      (
      \exists \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua
      (\Theta^\dagger,\Delta^\dagger, \tau^\dagger) \in \Pi_\mu \up
      (\forall \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \cong \Theta^\dagger \implies
      \\\\
      \exists \delta' \qua
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \epsilon \up
      \\\\
      \delta\ \alpha_\mu \slash \J{TOP} \oplus \delta' \oplus \delta^\dagger \satisfies \Delta^\dagger \up
      \delta\ \alpha_\mu \slash \J{TOP} \oplus \delta' \oplus \delta^\dagger \satisfies (e_a \J{,} e_r) \hastype \tau^\dagger 
      )
      )
      \implies
      e_r \cong e_f\J{(}e_a\J{)}
      )
    }
  \end{mathpar} 
\end{property} 

\noindent
Duality correspondence $\alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu$
rewrites schemas with path types $\Pi_\nu$ into schemas with pair types $\Pi_\nu$
such that for any interpretation $\delta$, a given function $e_f$ 
inhabits all interpretations of every path type schema
if and only if 
there's an argument $e_a$ paired with the function applied to it that inhabits 
at least one of the pair type schemas.

\begin{definition} 
  \label{def:schema_sequence_duality}
  Schema Sequence Duality 
  \hfill
  \small
  \boxed{\alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_{\nu} \downarrow \epsilon
      \fallingdotseq 
      \alpha_{\mu} \uparrow \epsilon 
    }

    \inferrule {
      \alpha_{\nu} \downarrow \Pi_\nu
      \fallingdotseq 
      \alpha_{\mu} \uparrow \Pi_\mu
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_{\nu} \downarrow \Pi_\nu\ (\Theta_c,\Delta_\nu, \tau_l \J{->} \tau_r)
      \fallingdotseq 
      \alpha_{\mu} \uparrow \Pi_\mu\ (\Theta_c,\Delta_\mu, \tau_l \J{*} \tau_r)
    }
  \end{mathpar}
\end{definition}

\noindent
The duality correspondence predicate unrolls the two sequences of schemas simultaneously.  
In the case where both sequence are empty
$
\alpha_{\nu} \downarrow \epsilon
\fallingdotseq 
\alpha_{\mu} \uparrow \epsilon 
$, duality correspondence simply holds.
Otherwise, duality correspondence requires that the left sequence's last schema 
has a path type  $(\Theta_c,\Delta_\nu, \tau_l \J{->} \tau_r)$
and the right sequence's last schema has a pair type 
$(\Theta_c,\Delta_\nu, \tau_l \J{*} \tau_r)$;
the subtyping environments correspond 
$\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu$;
and the earlier sequences of schemas correspond
$
\alpha_{\nu} \downarrow \Pi_\nu
\fallingdotseq 
\alpha_{\mu} \uparrow \Pi_\mu
$
.

\begin{property} 
  \label{prop:subtyping_environment_duality_correspondence}
  Subtyping Environment Duality Correspondence 
  \\
  \begin{mathpar}
    \inferrule {
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      (
      \forall \tau_\nu, \Delta_\nu  \qua
      \delta\ \alpha_\nu \slash \tau_\nu \satisfies \Delta_\nu \implies
      \delta\ \alpha_\nu \slash \tau_\nu 
      \satisfies e_f \hastype \tau_\nu
      )
      \\\\
      \iff
      \\\\
      (
      \exists \tau_\mu, \Delta_\mu, e_a \qua
      \delta\ \alpha_\mu \slash \tau_\mu \satisfies \Delta_\mu \land
      \delta\ \alpha_\mu \slash \tau_\mu 
      \satisfies (e_a \J{,} e_f\J{(} e_a \J{)}) \hastype \tau_\mu
      )
      )
    }
  \end{mathpar} 
\end{property} 

\noindent
Subtyping duality correspondence $
  \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
$ rewrites a subtyping environment $\Delta_\nu$ containing path type upper bounds
on variable $\alpha_\nu$ 
into a subtyping environment $\Delta_\mu$ containing pair type lower bounds 
on variable $\alpha_\mu$,
such that 
for any interpretation $\delta$, a given function $e_f$
inhabits all types $\tau_\nu$ constrained by the environment's path type upper bounds
if and only if 
there's an argument $e_a$ paired with the function applied to it that inhabits 
at least one type $\tau_\mu$ constrained by the environment's pair type lower bounds.

\begin{definition}
  \label{def:subtyping_environment_duality}
  Subtyping Environment Duality
  \hfill
  \small
  \boxed{\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu}
  \\
  \begin{mathpar}

    \inferrule {
    } {
      \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon 
    }

    % \inferrule {
    %   \alpha_\nu \notin \textbf{ftv}(\tau_l)
    %   \\
    %   \alpha_\nu \notin \textbf{ftv}(\tau_r)
    %   \\
    %   \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    % } {
    %   \alpha_\nu \downarrow \Delta_\nu \  \tau_l \J{<:} \tau_r 
    %   \fallingdotseq 
    %   \alpha_\mu \uparrow \Delta_\mu \  \tau_l \J{<:} \tau_r
    % }

    \inferrule {
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_\nu \downarrow \Delta_\nu \  \alpha_\nu \J{<:} \alpha_l \J{->} \alpha_r
      \fallingdotseq 
      \alpha_\mu \uparrow \Delta_\mu \  \alpha_l \J{*} \alpha_r \J{<:} \alpha_\mu 
    }
  \end{mathpar}
\end{definition}

\noindent
The subtyping duality correspondence predicate unrolls the two subtyping environments simultaneously.
In the case where both environments are empty 
$
  \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon 
$, subtyping duality correspondence simply holds.
In the case where the subtyping constraints are the same,
the upper bounded variable $\alpha_\nu$ must not appear in the subtype $\tau_l$;
the lower bounded variable $\alpha_\mu$ must not appear in the supertype $\tau_r$;
and the correspondence must hold for the previous constraints in the environment
$\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu$
.
Lastly, subtyping duality correspondence holds if
the last subtyping constraint of each subtyping environment contains
the path type upper bounds $\alpha_\nu \J{<:} \alpha_l \J{->} \alpha_r$
and pair type lower bounds $\alpha_l \J{*} \alpha_r \J{<:} \alpha_\mu$ on the specified variables,
and the the correspondence holds for the previous constraints in the environment

\begin{property}
  \label{prop:type_interpretation_soundness}
  Type Interpretation Soundness 
  \\
  \begin{mathpar}
    \inferrule { 
      \llbracket \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
      \\
      \Theta \subseteq \textbf{dom}(\delta')
    } {
      \exists \delta .\ 
      (
      \delta \oplus \delta' \satisfies \Delta
      \land
      \delta \oplus \delta' \satisfies e \hastype \tau
      )
      \iff
      (
      \delta' \satisfies \Delta'
      \land
      \delta' \satisfies e \hastype \tau'
      )
    } 
  \end{mathpar}
\end{property}

\noindent
Type interpretation $\llbracket \Theta_\ignore, \Theta \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')$
constructs a type $\tau'$, such that $\tau'$ is behaves like the input type $\tau$ for some interpretation $\delta$. 
The positive form $\llbracket ... \rrbracket^+$ constructs the strongest type or tries to get close to the strongest type possible.  
The negative form $\llbracket ... \rrbracket^-$ constructs the weakest type or tries to get close to the weakest type possible. 
The type variables $\Theta_\ignore$ and $\Theta$ must be irrelevant, meaning
the constructed type $\tau'$ must behave like $\tau$ 
for all interpretations over those variables $\delta'$.
Additionally, any interpretation $\delta'$ for the resulting subtyping environment $\Delta$' must
be part of some interpretation for the original subtyping environment $\Delta$.

The details of finding the type interpretation involves numerous tedious details, so we leave the definition
in the appendix (Section \ref{sect:appendix}).


\noindent
Packing ($\textbf{pack}^\pm(\Theta_\ignore \entails \Pi) = \tau'$)
constructs a type $\tau'$ from the schemas $\Pi$
such that for each schema $(\Theta, \Delta, \tau)$,
it binds the variables of the type $\tau$ within
some combination of 
indexed unions and/or indexed intersections,
where indexes are qualified by the constraints 
of the subtyping environment $\Delta$.
The choice of binding in an indexed union or indexed intersection is 
determined by whether the variable is open ($\alpha \not\in \Theta$)
or closed ($\alpha \in \Theta$)
and whether the interpretation is 
positive ($\textbf{pack}^+(...)$) or negative ($\textbf{pack}^-(...)$).
For the positive form, the construction (including how the closed variables are bound)
must result in a type $\tau'$ that is weaker than the type of every schema in every interpretation
of the closed variables $\delta'$, for some interpretation of the open variables $\delta$  
.
For the negative form, the construction must result in a type $\tau'$
that is stronger than the type of every schema in every interpretation
of the closed variables $\delta'$, for some interpretation of the open variables $\delta$  
.

The interested reader can find the actual the definition of packing in the appendix (Section \ref{sect:appendix}).

\begin{definition} 
  \label{def:type_interpretation}
  Type Interpretation 
  \hfill
  \small
  \boxed{
    \llbracket \Theta, \Delta \entails \tau \rrbracket^\pm = \tau'
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \llbracket \Theta, \Delta \entails \alpha \rrbracket^\pm 
      &\ =\ & 
      \llbracket \Delta \star  \alpha \rrbracket^\pm
      &\text{if}& 
      \alpha \notin \Theta

      \\

      &&
      \alpha
      &\text{if}&
      \alpha \in \Theta

      \\

      \llbracket \Theta, \Delta \entails \J{@} \rrbracket^\pm 
      &\ =\ & 
      \J{@}
      &&

      \\

      \llbracket \Theta, \Delta \entails \J{<}l\J{>}\tau \rrbracket^\pm
      &\ =\ & 
      \J{<}l\J{>}\llbracket \Theta, \Delta \entails \tau \rrbracket^\pm

      \\

      \llbracket \Theta, \Delta \entails \tau_l\J{->}\tau_r \rrbracket^\pm 
      &\ =\ & 
      \llbracket \Theta, \Delta \entails \tau_l \rrbracket^{\text{flip}(\pm)}
      \J{->}
      \llbracket \Theta, \Delta \entails \tau_r \rrbracket^\pm

      \\

      \llbracket \Theta, \Delta \entails \tau_l\J{|}\tau_r \rrbracket^\pm
      &\ =\ & 
      \llbracket \Theta, \Delta \entails \tau_l \rrbracket^\pm
      \J{|}
      \llbracket \Theta, \Delta \entails \tau_r \rrbracket^{\pm}

      \\

      \llbracket \Theta, \Delta \entails \tau_l\J{\&}\tau_r \rrbracket^\pm 
      &\ =\ & 
      \llbracket \Theta, \Delta \entails \tau_l \rrbracket^\pm
      \J{\&}
      \llbracket \Theta, \Delta \entails \tau_r \rrbracket^{\pm}

      \\

      \llbracket \Theta, \Delta \entails \J{EXI[}\Theta_q\J{]} \Delta_q\ \tau \rrbracket^\pm 
      &\ =\ & 
      \J{EXI[}\Theta_q\J{]} \llbracket \Theta \cup \Theta_q, \Delta \entails \Delta_q \rrbracket^\pm 
      \ \llbracket \Theta \cup \Theta_q, \Delta \entails \tau \rrbracket^{\pm}

      \\

      \llbracket \Theta, \Delta \entails \J{ALL[}\Theta_q\J{]} \Delta_q\ \tau \rrbracket^\pm 
      &\ =\ & 
      \J{ALL[} \Theta_q \J{]} \llbracket \Theta \cup \Theta_q, \Delta \entails \Delta_q \rrbracket^\pm
      \ \llbracket \Theta \cup \Theta_q, \Delta \entails \tau \rrbracket^{\pm}

      \\

      \llbracket \Theta, \Delta \entails \tau \typdiff \eta \rrbracket^\pm 
      &\ =\ & 
      \llbracket \Theta, \Delta \entails \tau \rrbracket^\pm \typdiff \eta

      \\

      \llbracket \Theta, \Delta \entails \J{LFP[}\alpha \J{]} \tau \rrbracket^\pm 
      &\ =\ & 
      \J{LFP[}\alpha \J{]}\llbracket \Theta\ \alpha, \Delta \entails \tau \rrbracket^{\pm}
      \\
  \end{array}
  \]
\end{definition}

\begin{definition} 
  \label{def:qualification_interpretation}
  Qualification Interpretation 
  \hfill
  \small
  \boxed{
    \llbracket \Theta, \Delta \entails \Delta_q \rrbracket^\pm = \Delta_q'
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \llbracket \Theta, \Delta \entails \epsilon \rrbracket^\pm
      &\ =\ & 
      \epsilon
      && 

      \\

      \llbracket \Theta, \Delta \entails \Delta_q \  \tau_l \J{<:} \tau_r \rrbracket^\pm
      &\ =\ & 
      \llbracket \Theta, \Delta \entails \Delta_q\rrbracket^\pm\  
      \llbracket \Theta, \Delta \entails \tau_l \rrbracket^{\text{flip}(\pm)} 
      \J{<:} 
      \llbracket \Theta, \Delta \entails \tau_r \rrbracket^\pm
  \end{array}
  \]
\end{definition} 

\TODO{...}


% \begin{definition} 
%   \label{def:pruning_interpretation}
%   Pruning Interpretation 
%   \hfill
%   \boxed{
%     \llbracket \Theta \star \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
%   }
%   \\
%   \[
%   \begin{array}[t]{r@{}c@{}lcl}
%       \llbracket \Theta \star \Delta, \alpha \rrbracket^\pm
%       &\ =\ & 
%       (\Delta', \tau)
%       &\text{if}& 
%       \begin{array}[t]{@{}l}
%         (\forall \tau_l\ \tau_r .\  \tau_l \J{<:} \tau_r \in \Delta' \iff \Theta, \Theta_\bullet, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r)
%         \\
%         \llbracket \Delta\backslash\Delta', \alpha \rrbracket^\pm = (\Delta', \tau)
%       \end{array}

%       \\
%   \end{array}
%   \]
% \end{definition}

% \TODO{...}

% \begin{definition} 
%   \label{def:indirection}
%   Indirection  
%   \hfill
%   \boxed{
%     \Theta, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r 
%   }
%   \\
%   \begin{mathpar}
%     \inferrule {
%       \ \alpha\J{<:}\tau \in \Delta 
%       \\\\
%       \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
%       \\
%       \ \alpha'\J{<:}\tau' \in \Delta 
%     } {
%       \Theta, \Delta, \alpha \looparrowright^- \alpha \subtypes \tau
%     }

%     \inferrule {
%       \ \alpha\J{<:}\tau \in \Delta 
%       \\\\
%       \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
%       \\
%       \ \alpha'\J{<:}\tau' \in \Delta 
%     } {
%       \Theta, \Delta, \alpha \looparrowright^- \alpha' \subtypes \tau'
%     }
%     \\
%     \inferrule {
%       \ \tau \J{<:} \alpha\in \Delta 
%       \\\\
%       \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
%       \\
%       \ \tau'\J{<:} \alpha' \in \Delta 
%     } {
%       \Theta, \Delta, \alpha \looparrowright^+ \tau \subtypes \alpha
%     }

%     \inferrule {
%       \ \tau \J{<:} \alpha\in \Delta 
%       \\\\
%       \alpha' \in \textbf{ftv}(\tau) \backslash \Theta
%       \\
%       \ \tau'\J{<:} \alpha' \in \Delta 
%     } {
%       \Theta, \Delta, \alpha \looparrowright^+ \tau' \subtypes \alpha'
%     }
%   \end{mathpar}
% \end{definition}

% \TODO{...}

\begin{definition} 
  \label{def:variable_interpretation}
  Variable Interpretation
  \hfill
  \small
  \boxed{
    \llbracket\Delta \star \alpha \rrbracket^\pm = \tau
  }
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}

      \llbracket \epsilon \star \alpha \rrbracket^-
      &\ =\ & 
      \J{TOP}

      \\

      \llbracket \Delta \ \alpha  \J{<:} \tau \star \alpha \rrbracket^- 
      &\ =\ & 
      \llbracket \Delta \star \alpha \rrbracket^- \J{\&} \tau

      \\

      \llbracket \Delta \ \tau_l \J{<:} \tau_r \star \alpha \rrbracket^- 
      &\ =\ & 
      \llbracket \Delta, \alpha \rrbracket^-
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \alpha \neq \tau_l
      \end{array}

      \\

      \llbracket \epsilon \star \alpha \rrbracket^+ 
      &\ =\ & 
      \J{BOT}

      \\

      \llbracket \Delta \  \tau \J{<:} \alpha \star \alpha \rrbracket^+ 
      &\ =\ & 
      \llbracket \Delta \star \alpha \rrbracket^+ \J{|} \tau

      \\

      \llbracket \Delta \ \tau_l \J{<:} \tau_r \star \alpha \rrbracket^+ 
      &\ =\ & 
      \llbracket \Delta \star \alpha \rrbracket^+
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \alpha \neq \tau_r
      \end{array}
  \end{array}
  \]
\end{definition}

\TODO{...}

\begin{definition}
  \label{def:type_packing}
  Type Packing 
  \hfill
  \small
  \boxed{\textbf{pack}^\pm(\dTheta \entails \Theta, \Delta, \tau) = \tau'} 
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \textbf{pack}^\pm(\dTheta \entails \Theta, \Delta, \tau) 
      &\ =\ & 
      \text{wrap}^{\pm}(\Theta_o, \Delta_o, \Theta_i, \Delta_i, \tau)
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \textbf{ftv}(\tau) = \Theta_p
        \\
        \dTheta, \Theta \entails \Delta \rightrightarrows \Delta_o, \Delta_i 
        \\
        (\textbf{ftv}(\Delta) \cup \Theta_p) \cap \Theta = \Theta_o 
        \\
        \textbf{ftv}(\Delta_i) \cup \Theta_p \backslash \Theta \backslash \dTheta = \Theta_i 
      \end{array}
  \end{array}
  \]
\end{definition}


\begin{definition}
  \label{def:multiple_type_packing}
  Multiple Type Packing 
  \hfill
  \boxed{\textbf{pack}^\pm(\Theta \entails \Pi) = \tau}\ 
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
      \textbf{pack}^+(\Theta_\ignore \entails \epsilon) 
      &\ =\ & 
      \J{TOP} 

      \\

      \textbf{pack}^+(\Theta_\ignore \entails \Pi\ (\Theta, \Delta, \tau)) 
      &\ =\ & 
      \tau_l \J{\&} \tau_r
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \textbf{pack}^+(\Theta_\ignore \entails \Pi) = \tau_l 
        \\
        \textbf{pack}^+(\Theta_\ignore \entails \Theta, \Delta, \tau) = \tau_r
      \end{array}

      \\

      \textbf{pack}^-(\Theta_\ignore \entails \epsilon) 
      &\ =\ & 
      \J{BOT} 

      \\

      \textbf{pack}^-(\Theta_\ignore \entails \Pi\ (\Theta, \Delta, \tau))
      &\ =\ & 
      \tau_l \J{|} \tau_r
      &\text{if}& 
      \begin{array}[t]{@{}l}
        \textbf{pack}^-(\Theta_\ignore \entails \Pi) = \tau_l
        \\
        \textbf{pack}^-(\Theta_\ignore \entails \Theta, \Delta, \tau) = \tau_r
      \end{array}
  \end{array}
  \]
\end{definition}


\begin{definition}
  \label{def:polar_subtyping_environment_substitution}
  Polar Subtyping Environment Substitution 
  \hfill
  \small
  \boxed{\Delta[\alpha\slash\tau]^\pm = \Delta}\ 
  \\
  \begin{mathpar}
    \TODO{...}
  \end{mathpar}
\end{definition}

\begin{definition}
  Subtyping Environment Filter 
  \hfill
  \small
  \boxed{\Theta \entails \Delta \dashrightarrow \Delta'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta \entails \epsilon \dashrightarrow \epsilon 
    }

    \inferrule {
      \exists \alpha .\ \alpha \in (\textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)) \cap \Theta
      \\
      \Theta \entails \Delta \dashrightarrow \Delta'
    } {
      \Theta \entails  \Delta \  \tau_l \J{<:} \tau_r\dashrightarrow \Delta' \  \tau_l \J{<:} \tau_r
    }

    \inferrule {
      \forall \alpha .\ \alpha \in \Theta \implies \alpha \notin \textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)
      \\
      \Theta \entails \Delta \dashrightarrow \Delta'
    } {
      \Theta \entails  \Delta \  \tau_l \J{<:} \tau_r\dashrightarrow \Delta'
    }
  \end{mathpar}
\end{definition}

\TODO{need lemma for correctness}

\begin{definition}
   Schema Sequence Compaction
  \hfill
  \small
  \boxed{\dTheta \entails \Pi \searrow \Pi'}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \dTheta \entails \epsilon \searrow \epsilon 
    }

    \inferrule {
      \dTheta \entails \Pi \searrow \Pi'
      \\
      \dTheta \cup \Theta \entails \Delta \dashrightarrow \Delta'
      \\
      \llbracket \dTheta \cup \Theta, \Delta \entails \tau \rrbracket^\pm = \tau'
    } {
      \dTheta \entails \Pi\ (\Theta, \Delta, \tau) \searrow \Pi'\ (\Theta, \Delta', \tau')
    }
  \end{mathpar}
\end{definition}

\TODO{need lemma for correctness}

\begin{definition}
  Outer
  \hfill
  \small
  \boxed{\text{outer}(\pm) = \J{ALL}|\J{EXI}}
  \\
  \[\begin{array}[t]{r@{}c@{}lcl}
    \\
    \text{outer}(+) 
    &\ =\ & 
    \J{EXI} 
    % & \C{positive} 
    \\
    \text{outer}(-) 
    &\ =\ & 
    \J{ALL} 
    % & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}
  Inner
  \hfill
  \small
  \boxed{\text{inner}(\pm) = \J{ALL}|\J{EXI}}
  \\
  \[\begin{array}[t]{r@{}c@{}lcl}
    \\
    \text{inner}(+) 
    &\ =\ & 
    \J{ALL} 
    % & \C{positive} 
    \\
    \text{inner}(-) 
    &\ =\ & 
    \J{EXI} 
    % & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}
  Wrap
  \hfill
  \small
  \boxed{\text{wrap}^{\pm}(\Theta, \Delta, \Theta, \Delta, \tau) = \tau}
  \\
  \[
  \begin{array}[t]{r@{}c@{}lcl}
    \text{wrap}^{\pm}(\epsilon, \epsilon, \epsilon, \epsilon, \tau) 
    &\ =\ & 
    \tau
    \\
    \text{wrap}^{\pm}(\epsilon, \epsilon, \Theta_i, \Delta_i, \tau) 
    &\ =\ & 
    \text{inner}(\pm)\J{[}\Theta_i\J{ }\Delta_i\J{]}\tau
    \\
    \text{wrap}^{\pm}(\Theta_o, \Delta_o, \epsilon, \epsilon, \tau) 
    &\ =\ & 
    \text{outer}(\pm)\J{[}\Theta_o\J{ }\Delta_o\J{]}\tau
    \\
    \text{wrap}^{\pm}(\Theta_o, \Delta_o, \Theta_i, \Delta_i, \tau) 
    &\ =\ & 
    \text{outer}(\pm)\J{[}\Theta_o\J{ }\Delta_o\J{]}
    \text{inner}(\pm)\J{[}\Theta_i\J{ }\Delta_i\J{]}
    \tau
  \end{array}\]
\end{definition}


\begin{definition}
  Partition
  \hfill
  \small
  \boxed{\Theta_\ignore , \Theta \entails \Delta \rightrightarrows \Delta_o , \Delta_i}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Theta_\ignore , \Theta \entails \epsilon \rightrightarrows \epsilon , \epsilon 
    }

    \inferrule {
      \Theta_\ignore , \Theta \entails \Delta \rightrightarrows \Delta_o , \Delta_i 
      \\\\
      \exists \alpha .\ \alpha \in (\textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)) \backslash \Theta_\ignore \backslash \Theta
    } {
      \Theta_\ignore , \Theta \entails \Delta \  \tau_l \J{<:}\tau_r \rightrightarrows \Delta_o , \Delta_i \  \tau_l \J{<:} \tau_r
    }

    \inferrule {
      \Theta_\ignore , \Theta \entails \Delta \rightrightarrows \Delta_o , \Delta_i 
      \\\\
      \exists \alpha .\ \alpha \in (\textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r)) \cap \Theta 
      \\
      \textbf{ftv}(\tau_l) \cup \textbf{ftv}(\tau_r) \subseteq \Theta_\ignore \cup \Theta
    } {
      \Theta_\ignore , \Theta \entails \Delta \  \tau_l \J{<:}\tau_r \rightrightarrows \Delta_o  \  \tau_l \J{<:} \tau_r , \Delta_i
    }
  \end{mathpar}

\end{definition}

\section{Model Theory}
\label{sec:model_theory}

\begin{theorem}
  \label{thm:record_extension_preservation}
  Record Extension Preservation 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies r \hastype \tau
      \\
      \nexists e' .\ \J{<} l \J{>} e' \in r
    } {
      \delta \satisfies r\ \J{<}l\J{>}e \hastype \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:entry_type_introduction}
  Entry Type Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \tau
      \\
      \nexists e' .\ \J{<} l \J{>} e' \in r
    } {
      \delta \satisfies r\ \J{<}l\J{>}e \hastype \J{<}l\J{>} \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_typing_entry_elimination}
  Model Typing Entry Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \J{<}l\J{>} \tau
    } {
      \delta \satisfies e \J{.} l \hastype \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:entry_type_preservation}
  Entry Type Preservation 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_l \subtypes \tau_r
    } {
      \delta \satisfies \J{<}l\J{>} \tau_l \subtypes \J{<}l\J{>} \tau_r
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_union_type_path_antecedent}
  Model Subtyping Union Type Path Antecedent 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies 
      (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r)
      \subtypes 
      (\tau_a\J{|}\tau_b)\J{->}\tau_r)
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_intersection_type_path_consequent}
  Model Subtyping Intersection Type Path Consequent 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies 
      (\tau_r\J{->}\tau_a)\J{\&}(\tau_r\J{->}\tau_b)
      \subtypes 
      \tau_r\J{->}(\tau_a\J{\&}\tau_b)
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_intersection_type_entry_consequent}
  Model Subtyping Intersection Type Entry Consequent 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies 
      (\J{<}l\J{>}\tau_a)\J{\&}(\J{<}l\J{>}\tau_b)
      \subtypes 
      \J{<}l\J{>}(\tau_a\J{\&}\tau_b)
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_transitivity}
  Model Subtyping Transitivity 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau \subtypes \tau'
      \\
      \delta \satisfies \tau' \subtypes \tau''
    } {
      \delta \satisfies \tau \subtypes \tau''
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_typing_path_elimination}
  Model Typing Path Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e_f \hastype \tau \J{->} \tau'
      \\
      \delta \satisfies e_a \hastype \tau
    } {
      \delta \satisfies e_f \J{(} e_a \J{)} \hastype \tau'
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:path_type_preservation}
  Path Type Preservation 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_x \subtypes \tau_p
      \\
      \delta \satisfies \tau_q \subtypes \tau_y 
    } {
      \delta \satisfies \tau_p \J{->} \tau_q \subtypes \tau_x \J{->} \tau_y
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:annotated_binding_introduction}
  Annotated Binding Introduction  
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \tau
      \\
      \delta \satisfies  e'[x \slash e]\hastype \tau'
    } {
      \delta \satisfies \J{let } x \J{:} \tau \J{ = } e \J{ in } e' \hastype \tau'
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_sequence_introduction}
  Model Subtyping Sequence Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \Delta
      \\
      \delta \satisfies \Delta'
    } {
      \delta \satisfies \Delta \cup \Delta'
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_sequence_elimination}
  Model Subtyping Sequence Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \Delta'
      \\
      \Delta \subseteq \Delta'
    } {
      \delta \satisfies \Delta
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_sequence_interpretation_independence}
  Model Subtyping Sequence Interpretation Independence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \emptyset
    } {
      \delta \satisfies \Delta
      \iff
      \delta \oplus \delta' \satisfies \Delta
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:model_typing_interpretation_independence}
  Model Typing Interpretation Independence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta') \cap \textbf{ftv}(\tau) = \emptyset
    } {
      \delta \satisfies e \hastype \tau 
      \iff
      \delta \oplus \delta' \satisfies e \hastype \tau 
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:subtyping_interpretation_independence}
  Subtyping Interpretation Independence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta') \cap \textbf{ftv}(\tau) = \emptyset
      \\
      \textbf{dom}(\delta') \cap \textbf{ftv}(\tau') = \emptyset
    } {
      \delta \satisfies \tau \subtypes \tau' 
      \iff
      \delta \oplus \delta' \satisfies \tau \subtypes \tau' 
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:subtyping_interpretation_reordering}
  Subtyping Interpretation Reordering 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta_1) \cap \textbf{dom}(\delta_2) = \emptyset
    } {
      \delta_0 \oplus \delta_1 \oplus \delta_2 \oplus \delta_3 \satisfies \tau \subtypes \tau' 
      \iff
      \delta_0 \oplus \delta_2 \oplus \delta_1 \oplus \delta_3 \satisfies \tau \subtypes \tau' 
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:submodel_typing_sequence_interpretation_reordering}
  Subtyping Environment Interpretation Reordering 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta_1) \cap \textbf{dom}(\delta_2) = \emptyset
    } {
      \delta_0 \oplus \delta_1 \oplus \delta_2 \oplus \delta_3 \satisfies \Delta 
      \iff
      \delta_0 \oplus \delta_2 \oplus \delta_1 \oplus \delta_3 \satisfies \Delta 
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_sequence_interpretation_independence}
  Subtyping Environment Interpretation Independence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \emptyset
    } {
      \delta \satisfies \Delta 
      \iff
      \delta \oplus \delta' \satisfies \Delta 
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_typing_sequence_interpretation_independence}
  Model Typing Sequence Interpretation Independence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Gamma) = \emptyset
    } {
      \delta, \sigma \satisfies \Gamma 
      \iff
      \delta \oplus \delta', \sigma \satisfies \Gamma
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:domain_extension}
  Domain Extension 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{dom}(\delta_l) = \Theta_l  
      \\
      \textbf{dom}(\delta_r) = \Theta_r  
    } {
      \textbf{dom}(\delta_l \oplus \delta_r) = \Theta_l \cup \Theta_r 
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_typing_subsumption}
  Subsumption 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau \subtypes \tau'
      \\
      \delta \satisfies e \hastype \tau
    } {
      \delta \satisfies e \hastype \tau'
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_union_type_elimination}
  Model Subtyping Union Type Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_l \subtypes \tau
      \\
      \delta \satisfies \tau_r \subtypes \tau
    } {
      \delta \satisfies \tau_l \J{|} \tau_r \subtypes \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_indexed_union_type_elimination}
  Model Subtyping Indexed Union Type Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      (
      \forall \delta' \qua 
      \textbf{dom}(\delta') \subseteq \Theta \implies
      \delta \oplus \delta' \satisfies \Delta \implies 
      \delta \oplus \delta' \satisfies \tau \subtypes \tau'
      )
      \\
      \Theta \cap \textbf{ftv}(\tau') = \emptyset
    } {
      \delta \satisfies \J{EXI[} \Theta \J{]}\Delta\ \tau \subtypes \tau'
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_intersection_type_introduction}
  Model Subtyping Union Type Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau \subtypes \tau_l
      \\
      \delta \satisfies \tau \subtypes \tau_r
    } {
      \delta \satisfies \tau \subtypes \tau_l \J{\&} \tau_r
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_indexed_intersection_type_introduction}
  Model Subtyping Indexed Intersection Type Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      (
      \forall \delta' \qua 
      \textbf{dom}(\delta') \subseteq \Theta \implies
      \delta \oplus \delta' \satisfies \Delta \implies 
      \delta \oplus \delta' \satisfies \tau \subtypes \tau'
      )
      \\
      \Theta \cap \textbf{ftv}(\tau') = \emptyset
    } {
      \delta \satisfies \tau \subtypes \J{ALL[} \Theta \J{]}\Delta\ \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:least_fixed_point_type_elimination}
  Least Fixed Point Type Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \J{LFP[}\alpha\J{]}\tau
    } {
      \delta\ \alpha \slash \J{TOP} \satisfies e \hastype \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_induction}
  Model Subtyping Induction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      (
      \forall \tau \qua
      \delta \satisfies \tau \subtypes \tau_r
      \implies
      \delta\ \alpha \slash \tau \satisfies \tau_l \subtypes \tau_r
      )
      \\
      \alpha \notin \textbf{ftv}(\tau_r)
    } {
      \delta \satisfies \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r
    }
  \end{mathpar}
\end{theorem}

\begin{theorem}
  \label{thm:left_congruence}
  Left Congruence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      (e_l\J{,}e_r)\J{.left} \cong e_l
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:right_congruence}
  Right Congruence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      (e_l\J{,}e_r)\J{.right} \cong e_r
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:model_typing_path_elimination_loop}
  Path Type Elimination Loop 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies e \hastype \alpha \J{->} \tau
    } {
      \delta \satisfies \J{loop(}e\J{)} \hastype \tau
    } {
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:path_type_introduction}
  Path Type Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \forall e_a \qua
      \delta \satisfies e_a \hastype \tau_l 
      \implies
      \delta \satisfies e_f \J{(} e_a \J{)} \hastype \tau_r
    } {
      \delta \satisfies e_f \hastype \tau_l \J{->} \tau_r
    } {
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_difference_introduction}
  Model Subtyping Difference Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_0 \subtypes \tau_1 \J{|} \tau_2
    } {
      \delta \satisfies \tau_0 \typdiff \tau_1 \subtypes \tau_2
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_union_right_introduction}
  Model Subtyping Union Right Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies \tau_l \subtypes \tau_l \J{|} \tau_r
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_union_left_introduction}
  Model Subtyping Union Left Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies \tau_r \subtypes \tau_l \J{|} \tau_r
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_intersection_left_elimination}
  Model Subtyping Intersection Left Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies \tau_l \J{\&} \tau_r \subtypes \tau_r
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_intersection_right_elimination}
  Model Subtyping Intersection Right Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies \tau_l \J{\&} \tau_r \subtypes \tau_l
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_typing_union_reorder}
  Model Typing Union Reorder 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies e \hastype \tau_a \J{|} \tau_b
      \iff
      \delta \satisfies e \hastype \tau_b \J{|} \tau_a
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_difference_elimination}
  Model Subtyping Difference Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_0 \subtypes \tau_1
      \\
      \neg (\delta \satisfies \tau_0 \subtypes \tau_2)
    } {
      \delta \satisfies \tau_0 \subtypes \tau_1 \typdiff \tau_2
    } {
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_indexed_union_introduction}
  Model Subtyping Indexed Union Introduction 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \delta \satisfies \Delta 
    } {
      \delta \satisfies \tau_l \subtypes \J{EXI[}\Theta\J{]}\Delta\ \tau_r
    } {
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:model_subtyping_indexed_intersection_elimination}
  Model Subtyping Indexed Intersection Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau_l \subtypes \tau_r
      \\
      \delta \satisfies \Delta 
    } {
      \delta \satisfies \J{ALL[}\Theta\J{]}\Delta\ \tau_l \subtypes \tau_r
    } {
    }
  \end{mathpar}
\end{theorem}
\hfill



\section{Proof Theory}
\label{sec:proof_theory}

\begin{theorem}
  \label{thm:type_substitution_correspondence}
  Type Substitution Correspondence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
    } {
      \delta \satisfies e \hastype \tau[\alpha \slash \tau'] 
      \iff  
      \delta\ \alpha \slash \tau' \satisfies e \hastype \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:proof_typing_containment}
  Proof Typing Containment 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \textbf{ftv}(\Gamma) \subseteq \textbf{ftv}(\Delta)
      \up
      \Delta \subseteq \Delta'
      \up
      \textbf{ftv}(\tau) \subseteq \textbf{ftv}(\Delta')
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:proof_subtyping_containment}
  Proof Subtyping Containment 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \tau' \given \Theta', \Delta'
    } {
      \Delta \subseteq \Delta'
      \up
      \textbf{ftv}(\tau) \subseteq \textbf{ftv}(\Delta')
      \up
      \textbf{ftv}(\tau') \subseteq \textbf{ftv}(\Delta')
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:proof_subtyping_environment_containment}
  Proof Subtyping Environment Containment 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \Delta_q \given \Theta', \Delta'
    } {
      \Delta \subseteq \Delta'
      \up
      \textbf{ftv}(\Delta_q) \subseteq \textbf{ftv}(\Delta')
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:proof_typing_skolem_freshness}
  Proof Typing Skolem Freshness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \Theta' \backslash \Theta \cap \textbf{ftv}(\Delta) = \emptyset
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:proof_subtyping_skolem_freshness}
  Proof Subtyping Skolem Freshness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \tau' \given \Theta', \Delta'
    } {
      \Theta' \backslash \Theta \cap \textbf{ftv}(\Delta) = \emptyset
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:proof_subtyping_sequence_skolem_freshness}
  Proof Subtyping Sequence Skolem Freshness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \Delta_q \given \Theta', \Delta'
    } {
      \Theta' \backslash \Theta \cap \textbf{ftv}(\Delta) = \emptyset
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:function_type_explosion_soundness}
  Function Type Explosion Soundness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \alpha \rightarrow \Pi 
    } {
      \forall  \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
      (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi \implies
      \\\\
      (
      \exists \delta \qua \textbf{dom}(\delta) \cong \Theta^\dagger \up 
      (
      \forall \delta' \qua 
      \delta' \oplus \delta \satisfies \Delta \cup \Delta^\dagger \implies
      \delta' \oplus \delta \satisfies \tau \subtypes \alpha \J{->} \tau^\dagger
      )
      )
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:function_type_explosion_skolem_freshness}
  Function Type Explosion Skolem Freshness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \alpha \rightarrow \Pi 
    } {
      \forall  \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
      (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi \implies
      \Theta^\dagger \cap \Theta = \emptyset 
      \up
      \Theta^\dagger \cap \textbf{ftv}(\Delta) = \emptyset
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:path_sequence_typing_soundness}
  Path Sequence Typing Soundness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
    } {
      \forall  \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
      (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi \implies
      \\\\
      (
      \exists \delta \qua \textbf{dom}(\delta) \cong \Theta^\dagger \up 
      (
      \forall \delta', \sigma \qua 
      \delta' \oplus \delta \satisfies \Delta \cup \Delta^\dagger \implies
      \delta', \sigma \satisfies \Gamma \implies
      \delta' \oplus \delta \satisfies f[\sigma] \hastype \tau^\dagger
      )
      )
    }

    \TODO{proof of this depends on consistency of subtyping environment when checking skolem variables}

    \TODO{to prevent a path expression from having an empty type}
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:function_lifting_skolem_freshness}
  Function Lifting Skolem Freshness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi 
    } {
      (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi 
      \implies
      % \Theta^\dagger \backslash \Theta \backslash \textbf{ftv}(\Delta) \backslash \textbf{ftv}(\Gamma) = \Theta^\dagger
      \Theta^\dagger \cap \Theta = \emptyset 
      \up
      \Theta^\dagger \cap \textbf{ftv}(\Delta) = \emptyset
      \up
      \Theta^\dagger \cap  \textbf{ftv}(\Gamma) = \emptyset
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem} 
  \label{thm:schema_sequence_duality_correspondence}
  Schema Sequence Duality Correspondence
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu
      \\
      \delta \satisfies \Delta
    } {
      (
      \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua
      (\Theta^\dagger,\Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
      \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \up
      \\\\
      (
      \forall \delta' \qua
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \epsilon \implies
      \\\\
      \delta\ \alpha_\nu \slash \J{BOT} \oplus \delta' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
      \delta\ \alpha_\nu \slash \J{BOT} \oplus \delta' \oplus \delta^\dagger \satisfies e_f \hastype \tau^\dagger
      )
      )
      \\\\
      \iff
      \\\\
      (\forall e_a, e_r \qua
      (
      \exists \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua
      (\Theta^\dagger,\Delta^\dagger, \tau^\dagger) \in \Pi_\mu \up
      (\forall \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \implies
      \\\\
      \exists \delta' \qua
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \epsilon \up
      \\\\
      \delta\ \alpha_\mu \slash \J{TOP} \oplus \delta' \oplus \delta^\dagger \satisfies \Delta^\dagger \up
      \delta\ \alpha_\mu \slash \J{TOP} \oplus \delta' \oplus \delta^\dagger \satisfies (e_a \J{,} e_r) \hastype \tau^\dagger 
      )
      )
      \implies
      e_r \cong e_f\J{(}e_a\J{)}
      )
    }
  \end{mathpar} 
\end{theorem} 
\hfill

\begin{theorem}
  \label{thm:packing_correspondence}
  Packing Correspondence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \textbf{pack}^+(\dTheta \entails \Pi) = \tau 
      \\
      \delta \satisfies \Delta
      \\
      \dTheta \subseteq \textbf{dom}(\delta)
    } {
      (\forall  \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
      (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi \implies
      \\\\
      (
      \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \backslash \dTheta \up 
      \\\\
      (
      \forall \delta' \qua 
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \emptyset \implies
      \delta \oplus \delta' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
      \delta \oplus \delta' \oplus \delta^\dagger \satisfies e \hastype \tau^\dagger
      )
      ) 
      \\\\
      \iff
      \\\\
      \delta \satisfies e \hastype \tau
    }

    \inferrule {
      \textbf{pack}^-(\dTheta \entails \Pi) = \tau 
      \\
      \delta \satisfies \Delta
      \\
      \dTheta \subseteq \textbf{dom}(\delta)
    } {
      (\exists  \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
      (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi \up
      \\\\
      (
      \forall \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \backslash \dTheta \implies
      \\\\
      (
      \exists \delta' \qua 
      \textbf{dom}(\delta') \cap \textbf{ftv}(\Delta) = \emptyset \up
      \delta \oplus \delta' \oplus \delta^\dagger \satisfies \Delta^\dagger \up
      \delta \oplus \delta' \oplus \delta^\dagger \satisfies e \hastype \tau^\dagger
      )
      ) 
      \\\\
      \iff
      \\\\
      \delta \satisfies e \hastype \tau
    }
  \end{mathpar}
\end{theorem}
\hfill

\begin{theorem}
  \label{thm:subtyping_factorization_correspondence}
  Subtyping Factorization Correspondence 
  \\
  \small
  \begin{mathpar}
    % \inferrule {
    %   \factorsinto \tau \subtypes \J{<}l\J{>} \tau'
    % } {
    %   \delta \satisfies \tau \subtypes \J{<}l\J{>} \tau'
    % }
    % 
    \inferrule {
      \factorsinto \tau \subtypes \J{<}l\J{>} \tau'
    } {
      \forall e' \qua \delta \satisfies e'  \hastype \tau'
      \iff
      (\exists e \qua e \J{.} l \cong e' \up \delta \satisfies e \hastype \tau)
    }
  \end{mathpar}
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:proof_subtyping_sequence_soundness}
  Proof Subtyping Sequence Soundness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \Delta_q \given \Theta', \Delta'
    } {
      \exists \delta \qua \textbf{dom}(\delta) \subseteq \Theta' \backslash \Theta \up 
      (
      \forall \delta' \qua 
      \delta' \oplus \delta \satisfies \Delta' \implies
      \delta' \oplus \delta \satisfies \Delta_q 
      )
    }
  \end{mathpar}
\end{theorem}

\begin{theorem}
  \label{thm:proof_decidable_subtyping_sequence_uniqueness}
  Proof Decidable Subtyping Sequence Uniqueness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \Omega \given \Theta', \Delta'
    } {
      \forall \Theta'', \Delta'' \qua
      \Theta, \Delta \entails \Omega \given \Theta'', \Delta''
      \implies
      (\Theta'', \Delta'') = (\Theta', \Delta')
    }
  \end{mathpar}
\end{theorem}

\begin{theorem}
  Proof Decidable Subtyping Sequence Completeness  
  \label{thm:proof_decidable_subtyping_sequence_completeness}
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \Omega \given \Theta', \Delta'
      \\
      \delta' \satisfies \Delta'
    } {
      \forall \delta^\dagger \qua
      \delta' \oplus \delta^\dagger \satisfies \Omega \implies
      \delta' \oplus \delta^\dagger \satisfies \Delta'
    }
    % \TODO{note that this is a sufficient form of completeness, derived from uniqueness}
    % \TODO{meaning any solution $\Delta'$ is complete wrt to $\Omega$}
  \end{mathpar}
\end{theorem}


\begin{theorem}
  Proof Decidable Subtyping Solution Completeness  
  \label{thm:proof_decidable_subtyping_solution_completeness}
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau \subtypes \eta \given \Theta', \Delta'
      \\
      \textbf{ftv}(\eta) \subseteq \emptyset
      \\
      \delta' \satisfies \Delta'
    } {
      \forall \delta^\dagger \qua
      \delta' \oplus \delta^\dagger \satisfies \tau \subtypes \eta \implies
      \delta' \oplus \delta^\dagger \satisfies \Delta'
    }
  \end{mathpar}
\end{theorem}

\begin{theorem}
  Proof Decidable Subtyping Existential Completeness
  \label{thm:proof_decidable_subtyping_strong_existential_completeness}
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \tau \subtypes \eta
      \\
      \delta \satisfies \Delta
    } {
      \exists \Theta', \Delta' \qua \Theta, \Delta \entails \tau \subtypes \eta \given \Theta', \Delta'
    }
  \end{mathpar}
\end{theorem}



\begin{theorem}
  \label{thm:proof_subtyping_interpretation_independence}
  Proof Subtyping Interpretation Independence 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
      \\
      \delta' \satisfies \Delta'
    } {
      \forall \delta^\dagger \qua
      \textbf{dom}(\delta^\dagger) \subseteq \textbf{ftv}(\Delta)
      \implies
      \delta' \oplus \delta^\dagger \satisfies \Delta
      \implies
      \delta' \oplus \delta^\dagger \satisfies \Delta'
    }
  \end{mathpar}
\end{theorem}



\begin{theorem}
  \label{thm:proof_typig_annotation_soundness}
  Proof Typing Annotation Soudness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails \J{let } x \J{:} \tau_a \J{ = } e \J{ in } e' \hastype \tau' \given \Theta', \Delta'
    } {
      \forall \delta, \sigma \qua 
      \delta, \sigma \satisfies \Gamma \implies
      \delta \satisfies e \hastype \tau_a
    }
  \end{mathpar}
\end{theorem}

\begin{theorem}
  \label{thm:proof_typing_substance}
  Proof Typing Substance 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \forall \delta \qua \textbf{dom}(\delta) \subseteq \Theta \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta
      \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta'
    }
  \end{mathpar}
\end{theorem}



\begin{theorem}
  \label{thm:proof_subtyping_substance}
  Proof Subtyping Substance 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
    } {
      \forall \delta \qua \textbf{dom}(\delta) \subseteq \Theta \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta
      \implies
      \exists \delta' \qua \delta \oplus \delta' \satisfies \Delta'
    }
  \end{mathpar}

  \TODO{note how this is necessary for safety of function type inference}

  \TODO{so that bottom can't be inferred for a function expression}
\end{theorem}

\begin{theorem}
  \label{thm:polar_substitution_consistency}
  Polar Substitution Consistency 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \delta \satisfies \Delta[\alpha \slash \tau]^+ 
    } {
      \exists \delta' \qua
      \delta' \satisfies \Delta\ \alpha \J{<:} \tau
    }

    \inferrule {
      \delta \satisfies \Delta[\alpha \slash \tau]^-
    } {
      \exists \delta' \qua
      \delta' \satisfies \Delta\ \tau \J{<:} \alpha
    }
  \end{mathpar}

  \TODO{note how this is necessary to prove subtyping consistency}

  \TODO{note how consitency is necessary to prove parts of subtyping soundness}

\end{theorem}

\begin{theorem}
  \label{thm:type_substitution_positive_elimination}
  Type Substitution (Positive) Elimination 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \tau_l[\alpha \slash \tau_r]^+ = \tau^\dagger
      \\
      \delta \satisfies  \tau^\dagger \subtypes \tau_r
      \\
      \alpha \notin \textbf{ftv}(\tau^\dagger)
      \\
      \alpha \notin \textbf{ftv}(\tau_r)
    } {
      \forall \tau \qua
      \delta \satisfies \tau \subtypes \tau_r
      \implies
      \delta\ \alpha \slash \tau \satisfies \tau_l \subtypes \tau_r
    }
  \end{mathpar}
\end{theorem}


\begin{theorem}
  \label{thm:proof_subtyping_skolem_variable_elimination_soundness}
  Proof Subtyping Skolem Variable Elimination Soundness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \alpha \J{<:} \tau \safe
    } {
      \forall \delta \qua \delta \satisfies \Delta \implies \delta \satisfies \alpha \subtypes \tau 
    }
  \end{mathpar}
\end{theorem}

\begin{theorem}
  \label{thm:proof_subtyping_soundness}
  Proof Subtyping Soundness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
    } {
      \exists \delta' \qua \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta \up 
      (
      \forall \delta \qua 
      \delta \oplus \delta' \satisfies \Delta' \implies
      \delta \oplus \delta' \satisfies \tau_l \subtypes \tau_r
      )
    }
  \end{mathpar}
  \\\\
  \noindent
  Induct over Definition \ref{def:proof_subtyping}.

  %%%%%%%%%%%%%%%%

  \item \N Assume $(\Theta, \Delta \entails \tau \subtypes \tau \given \Theta, \Delta)$
  \item \I \N Derive $(\textbf{dom}(\epsilon) \subseteq \Theta \backslash \Theta)$
  \item \I \N For $\delta$, assume $(\delta \oplus \epsilon \satisfies \Delta)$
  \item \I\I \N Derive $(\forall e \qua \delta \oplus \epsilon \satisfies e \hastype \tau \implies \delta \oplus \epsilon \satisfies e \hastype \tau)$
  \item \I\I \N Derive $(\delta \oplus \epsilon \satisfies \tau \subtypes \tau)$ 
    [Def. \ref{def:model_subtyping}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
      \Theta, \Delta \entails 
      \J{<}l \J{>} \tau_l \subtypes \J{<} l \J{>} \tau_r
      \given \Theta', \Delta'
  )$
  \item \I \N Derive $(
      \Theta, \Delta \entails 
      \tau_l \subtypes \tau_r
      \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_implication_preservation}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau_l \subtypes \tau_r 
  )$ [IH]
  \item \I \N For $\delta$, 
      assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(\delta \oplus \delta' \satisfies \tau_l \subtypes \tau_r)$ [P]
  \item \I\I \N Derive $(\delta \oplus \delta' \satisfies \J{<}l\J{>}\tau_l \subtypes \J{<}l\J{>}\tau_r)$ [Thm. \ref{thm:entry_type_preservation}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau_{p} \J{->} \tau_{q} 
    \subtypes 
    \tau_{x} \J{->} \tau_{y}
    \given \Theta'', \Delta'' 
  )$

  \item \I \N Derive $(
    \Theta, \Delta \entails \tau_{x} \subtypes \tau_{p} \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_implication_preservation}]

  \item \I \N And $(
    \Theta', \Delta' \entails \tau_{q} \subtypes \tau_{y} \given \Theta'', \Delta'' 
  )$ [Def. \ref{def:proof_subtyping_implication_preservation}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta \qua 
    \delta \oplus \delta_0 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_0 \satisfies \tau_x \subtypes \tau_p
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [IH]
  \item \I \N And P1: $(
    \forall \delta \qua 
    \delta \oplus \delta_1 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_1 \satisfies \tau_q \subtypes \tau_y
  )$ [IH]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$
  \item \I \N For $\delta$, assume $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'')$

  \item \I\I \N Derive $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta')$
    [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_introduction}]
  \item \I\I \N Derive $(\delta \oplus \delta_0 \satisfies \Delta')$
    [Thm. \ref{thm:proof_subtyping_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \tau_x \subtypes \tau_p
  )$ [P0]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_x \subtypes \tau_p
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:subtyping_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_q \subtypes \tau_y
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_p \J{->} \tau_q \subtypes \tau_x \J{->} \tau_y
  )$ [Thm \ref{thm:path_type_preservation}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
      \Theta, \Delta \entails 
      \tau_l \subtypes 
      (\tau_a\J{|}\tau_b)\J{->}\tau_r
      \given \Theta', \Delta' 
  )$ 
  \item \I \N Derive $(
    \Theta, \Delta \entails 
    \tau_l \subtypes
    (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r)
    \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_implication_rewriting}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau_l \subtypes (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r) 
  )$ [IH]
  \item \I \N For $\delta$, assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \subtypes (\tau_a\J{->}\tau_r)\J{\&}(\tau_b\J{->}\tau_r)
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \subtypes (\tau_a\J{|}\tau_b)\J{->}\tau_r)
  )$ [Thm. \ref{thm:model_subtyping_union_type_path_antecedent}, Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau_l \subtypes 
    \tau_r\J{->}(\tau_{a}\J{\&}\tau_{b})
    \given \Theta', \Delta'
  )$ 
  \item \I \N Derive $(
    \Theta, \Delta \entails 
    \tau_l
    \subtypes
    (\tau_r\J{->}\tau_a)
    \J{\&}
    (\tau_r\J{->}\tau_b)
    \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_implication_rewriting}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau_l \subtypes 
    (\tau_r\J{->}\tau_a) \J{\&} (\tau_r\J{->}\tau_b)
  )$ [IH]
  \item \I \N For $\delta$, assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \subtypes
    (\tau_r\J{->}\tau_a) \J{\&} (\tau_r\J{->}\tau_b)
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \subtypes \tau_r\J{->}(\tau_a\J{\&}\tau_b))
  )$ [Thm. \ref{thm:model_subtyping_intersection_type_path_consequent}, Thm. \ref{thm:model_subtyping_transitivity}]


  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau \subtypes 
    \J{<} l \J{>} (\tau_{a}\J{\&}\tau_{b})
    \given \Theta', \Delta'
  )$ 
  \item \I \N Derive $(
    \Theta, \Delta \entails 
    \tau
    \subtypes
    (\J{<} l \J{>} \tau_a)
    \J{\&}
    (\J{<} l \J{>} \tau_b)
    \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_implication_rewriting}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies 
    \tau
    \subtypes
    (\J{<} l \J{>} \tau_a)
    \J{\&}
    (\J{<} l \J{>} \tau_b)
  )$ [IH]
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies 
    \tau \subtypes
    (\J{<} l \J{>} \tau_a)
    \J{\&}
    (\J{<} l \J{>} \tau_b)
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \J{<} l \J{>}(\tau_a\J{\&}\tau_b))
  )$ [Thm. \ref{thm:model_subtyping_intersection_type_entry_consequent}, Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails
    \tau_a\J{|}\tau_b \subtypes \tau
    \given \Theta'', \Delta'' 
  )$

  \item \I \N Derive $(
    \Theta, \Delta \entails
    \tau_a \subtypes \tau
    \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]

  \item \I \N And $(
    \Theta', \Delta' \entails
    \tau_b \subtypes \tau
    \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta \qua 
    \delta \oplus \delta_0 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_0 \satisfies \tau_a \subtypes \tau
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [IH]
  \item \I \N And P1: $(
    \forall \delta \qua 
    \delta \oplus \delta_1 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_1 \satisfies \tau_b \subtypes \tau
  )$ [IH]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'')$

  \item \I\I \N Derive $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta')$
    [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_introduction}]
  \item \I\I \N Derive $(\delta \oplus \delta_0 \satisfies \Delta')$
    [Thm. \ref{thm:proof_subtyping_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \tau_a \subtypes \tau
  )$ [P0]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_a \subtypes \tau
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:subtyping_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_b \subtypes \tau
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_a \J{|} \tau_b \subtypes \tau
  )$ [Thm \ref{thm:model_subtyping_union_type_elimination}]

  %%%%%%%%%%%%%%%%

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails
    \J{EXI[}\Theta_l\J{]}\Omega \J{:} \tau_l \subtypes \tau_r
    \given \Theta'', \Delta'' 
  )$

  \item \I \N Derive $(
    \Theta_l \cap \textbf{ftv}(\Delta) \subseteq \emptyset 
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]
  \item \I \N And $(
    \Theta_l \cap \textbf{ftv}(\tau_r) \subseteq \emptyset
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]
  \item \I \N And $(
    \forall \tau, \eta \qua (\tau \J{<:} \eta) \in \Omega \implies \textbf{ftv}(\eta) \subseteq \emptyset
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]
  \item \I \N And $(
    \Theta, \Delta \entails \Omega \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]
  \item \I \N And $(
    \Theta' \cup \Theta_l, \Delta' \entails
    \tau_l \subtypes \tau_r \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_subtyping_expansion_elimination}]


  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta) \subseteq \Theta' \backslash \Theta
  )$ [Thm. \ref{thm:proof_subtyping_sequence_soundness}]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash (\Theta' \cup \Theta_l)
  )$ [IH]


  \item \I \N And P1: $(
    \forall \delta \qua
    \delta \oplus \delta_1 \satisfies \Delta''
    \implies
    \delta \oplus \delta_1 \satisfies \tau_l \subtypes \tau_r
  )$ [IH]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta \backslash \Theta_l
  )$

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$

  \item \I \N For $\delta$, assume $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta''
  )$ 

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:model_subtyping_sequence_introduction}]

  \item \I\I \N Derive $(
    \forall \delta_l \qua
    \textbf{dom}(\delta_l) \subseteq \textbf{ftv}(\Delta')
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Delta' 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Delta''
  )$ [Thm \ref{thm:proof_subtyping_interpretation_independence}]


  \item \I\I \N Derive $(
    \forall \delta_l \qua
    \textbf{dom}(\delta_l) \subseteq \textbf{ftv}(\Delta')
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Omega 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Delta''
  )$ [Thm \ref{thm:proof_decidable_subtyping_sequence_completeness}]

  \item \I\I \N Derive $(
    \Theta_l \subseteq \textbf{ftv}(\Delta')
  )$ [Thm. \ref{thm:proof_subtyping_environment_containment}]

  \item \I\I \N Derive $(
    \forall \delta_l \qua
    \textbf{dom}(\delta_l) \subseteq \Theta_l 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Delta''
  )$ 

  \item \I\I \N Derive $(
    \forall \delta_l \qua
    \textbf{dom}(\delta_l) \subseteq \Theta_l 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_l \oplus \delta_1 \satisfies \Delta''
  )$ [Thm. Thm. \ref{thm:subtyping_interpretation_reordering}]

  \item \I\I \N Derive $(
    \forall \delta_l \qua
    \textbf{dom}(\delta_l) \subseteq \Theta_l
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_l \oplus \delta_1 \satisfies \tau_l \subtypes \tau_r
  )$ [P1] 

  \item \I\I \N Derive $(
    \forall \delta_l \qua
    \textbf{dom}(\delta_l) \subseteq \Theta_l
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_l \satisfies \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:subtyping_interpretation_reordering}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \J{EXI[} \Theta_l \J{]} \Omega \J{:} \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:model_subtyping_indexed_union_type_elimination}]


  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails
    \tau \subtypes \tau_{a}\J{\&}\tau_{b} \given \Theta'', \Delta''
  )$

  \item \I \N Derive $(
    \Theta, \Delta \entails
    \tau \subtypes \tau_{a} \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]

  \item \I \N Derive $(
    \Theta', \Delta' \entails
    \tau \subtypes \tau_{b} \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta \qua 
    \delta \oplus \delta_0 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_0 \satisfies \tau \subtypes \tau_a
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [IH]
  \item \I \N And P1: $(
    \forall \delta \qua 
    \delta \oplus \delta_1 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_1 \satisfies \tau \subtypes \tau_b
  )$ [IH]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'')$

  \item \I\I \N Derive $(
    \delta' \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_introduction}]
  \item \I\I \N Derive $(
    \delta' \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \tau \subtypes \tau_a
  )$ [P0]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau \subtypes \tau_a
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:subtyping_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau \subtypes \tau_b
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau \subtypes \tau_a \J{\&} \tau_b
  )$ [Thm \ref{thm:model_subtyping_intersection_type_introduction}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails \tau_l \subtypes \J{ALL[}\Theta_r\J{]}\Omega \J{:} \tau_r \given \Theta'', \Delta''
  )$
  \item \I \N Derive $(
    \Theta_r \cap \textbf{ftv}(\Delta) \subseteq \emptyset
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]
  \item \I \N And $(
    \Theta_r \cap \textbf{ftv}(\tau_l) \subseteq \emptyset
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]
  \item \I \N And $(
    \forall \tau, \eta \qua (\tau \J{<:} \eta) \in \Omega \implies \textbf{ftv}(\eta) \subseteq \emptyset
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]
  \item \I \N And $(
    \Theta, \Delta \entails \Omega \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]
  \item \I \N And $(
    \Theta' \cup \Theta_r, \Delta' \entails
    \tau_l \subtypes \tau_r \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_subtyping_refinement_introduction}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta) \subseteq \Theta' \backslash \Theta
  )$ [Thm. \ref{thm:proof_subtyping_sequence_soundness}]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash (\Theta' \cup \Theta_r)
  )$ [IH]

  \item \I \N And P1: $(
    \forall \delta \qua
    \delta \oplus \delta_1 \satisfies \Delta''
    \implies
    \delta \oplus \delta_1 \satisfies \tau_l \subtypes \tau_r
  )$ [IH]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta \backslash \Theta_r
  )$

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$

  \item \I \N For $\delta$, assume $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta''
  )$ 

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:model_subtyping_sequence_introduction}]

  \item \I\I \N Derive $(
    \forall \delta_r \qua
    \textbf{dom}(\delta_r) \subseteq \textbf{ftv}(\Delta')
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Delta' 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Delta''
  )$ [Thm \ref{thm:proof_subtyping_interpretation_independence}]


  \item \I\I \N Derive $(
    \forall \delta_r \qua
    \textbf{dom}(\delta_r) \subseteq \textbf{ftv}(\Delta')
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Omega 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Delta''
  )$ [Thm \ref{thm:proof_decidable_subtyping_sequence_completeness}]

  \item \I\I \N Derive $(
    \Theta_r \subseteq \textbf{ftv}(\Delta')
  )$ [Thm. \ref{thm:proof_subtyping_environment_containment}]

  \item \I\I \N Derive $(
    \forall \delta_r \qua
    \textbf{dom}(\delta_r) \subseteq \Theta_r 
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Delta''
  )$ 

  \item \I\I \N Derive $(
    \forall \delta_r \qua
    \textbf{dom}(\delta_r) \subseteq \Theta_r
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_r \oplus \delta_1 \satisfies \Delta''
  )$ [Thm. Thm. \ref{thm:subtyping_interpretation_reordering}]

  \item \I\I \N Derive $(
    \forall \delta_r \qua
    \textbf{dom}(\delta_r) \subseteq \Theta_r
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_r \oplus \delta_1 \satisfies \tau_l \subtypes \tau_r
  )$ [P1] 

  \item \I\I \N Derive $(
    \forall \delta_r \qua
    \textbf{dom}(\delta_r) \subseteq \Theta_r
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \Omega
    \implies
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_r \satisfies \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:subtyping_interpretation_reordering}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_l \subtypes \J{ALL[} \Theta_r \J{]} \Omega \J{:} \tau_r
  )$ [Thm. \ref{thm:model_subtyping_indexed_intersection_type_introduction}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails \alpha \subtypes \tau \given \Theta', \Delta'\ \alpha\J{<:}\tau
  )$ and $(
    \alpha \notin \Theta
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \Delta[\alpha\slash\tau]^{+} \backslash \Delta \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_variable_elimination}]

  \item \I \N Let $\delta$ be, such that $(
    \textbf{dom}(\delta) \subseteq \Theta' \backslash \Theta
  )$ [Def. \ref{def:type_variable_assigment_sequence}]

  \item \I \N For $\delta'$, assume $(
    \delta \oplus \delta \satisfies \Delta'\ \alpha \J{<:} \tau
  )$ 
  \item \I\I \N Derive $(
    \delta \oplus \delta \satisfies \alpha \J{<:} \tau
  )$ [Thm. \ref{...}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \alpha \subtypes \tau
    \given \Theta, \Delta\ \alpha \J{<:} \tau
  )$ and $(
    \alpha \in \Theta 
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \alpha \subtypes \tau \safe
  )$ [Def. \ref{def:proof_subtyping_variable_elimination}]
  \item \I \N And $(
    \nexists \alpha'  \qua \tau = \alpha'
  )$ [Def. \ref{def:proof_subtyping_variable_elimination}]

  \item \I \N For $\delta'$, assume $(
    \delta \oplus \epsilon \satisfies \Delta\ \alpha \J{<:} \tau 
  )$ 
  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies \alpha \J{<:} \tau
  )$ [Def. \ref{def:model_subtyping_sequence}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau \subtypes \alpha \given \Theta', \Delta'\ \tau\J{<:}\alpha
  )$ and $(
    \alpha \notin \Theta
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails 
    \Delta[\alpha\slash\tau]^{-} \backslash \Delta \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_variable_introduction}]

  \item \I \N Let $\delta$ be, such that $(
    \textbf{dom}(\delta) \subseteq \Theta' \backslash \Theta
  )$ [Def. \ref{def:type_variable_assigment_sequence}]

  \item \I \N For $\delta'$, assume $(
    \delta \oplus \delta \satisfies \Delta'\ \tau \J{<:} \alpha
  )$ 
  \item \I\I \N Derive $(
    \delta \oplus \delta \satisfies \tau \J{<:} \alpha
  )$ [Thm. \ref{...}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau \subtypes \alpha \given \Theta, \Delta
  )$ and $(
    \alpha \in \Theta
  )$

  \item \I \N Derive $(
    \Theta, \Delta \entails \tau \subtypes \alpha \safe
  )$ [Def. \ref{def:proof_subtyping_variable_introduction}]

  \item \I \N And $(
    \nexists \alpha' \qua \tau = \alpha'
  )$ [Def. \ref{def:proof_subtyping_variable_introduction}]

  \item \I \N For $\delta'$, assume $(
    \delta \oplus \epsilon \satisfies \Delta\ \tau \J{<:} \alpha
  )$ 
  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies \tau \J{<:} \alpha
  )$ [Def. \ref{def:model_subtyping_sequence}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r 
    \given \Theta', \Delta' 
  )$
  \item \I \N Derive $(
    \tau_l[\alpha\slash\tau_r]^+ = \tau^\dagger 
  )$ [Def. \ref{def:proof_subtyping_lfp_elimination}]
  \item \I \N And $(
    \Theta, \Delta \entails 
    \tau_l[\alpha\slash\tau_r]^+ \subtypes \tau_r \given 
    \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_lfp_elimination}]
  \item \I \N And $(
    \alpha \not\in \textbf{ftv}(\tau^\dagger)
  )$ [Def. \ref{def:proof_subtyping_lfp_elimination}]
  \item \I \N And $(
    \alpha \not\in \textbf{ftv}(\tau_r)
  )$ [Def. \ref{def:proof_subtyping_lfp_elimination}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]

  \item \I \N And P: $(
    \forall \delta \qua
    \delta \oplus \delta \satisfies \Delta'
    \implies
    \delta \oplus \delta \satisfies \tau^\dagger \subtypes \tau_r
  )$ [IH]


  \item \I \N For $\delta$, Assume $(
    \delta \oplus \delta \satisfies \Delta'
  )$

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau^\dagger \subtypes \tau_r
  )$ [P]

  \item \I\I \N Derive $(
    \forall \tau \qua \delta \oplus \delta' \satisfies \tau \subtypes \tau_r \implies \delta' \oplus \delta\ \alpha \slash \tau \satisfies \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:type_substitution_positive_elimination}]

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \J{LFP[}\alpha\J{]}\tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:model_subtyping_induction}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau \subtypes \rho \typdiff \eta
    \given \Theta', \Delta'
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails 
    \tau \subtypes \rho \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_difference_intro}]
  \item \I \N And $(
    \textbf{ftv}(\eta) \subseteq \emptyset
  )$ [Def. \ref{def:proof_subtyping_difference_intro}]
  \item \I \N And $(
    \nexists \Theta', \Delta' \qua  
    \Theta, \Delta \entails 
    \tau \subtypes \eta \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_difference_intro}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]

  \item \I \N And P: $(
    \forall \delta \qua
    \delta \oplus \delta' \satisfies \Delta'
    \implies
    \delta \oplus \delta' \satisfies \tau \subtypes \rho
  )$ [IH]

  \item \I \N For $\delta$, Assume $(
    \delta \oplus \delta' \satisfies \Delta'
  )$

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \rho
  )$ [P]

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \Delta
  )$ [Thm. \ref{thm:proof_subtyping_containment}]

  \item \I\I \N Derive $(
    \neg (\delta \oplus \delta' \satisfies \tau \subtypes \eta)
  )$ [Thm \ref{thm:proof_decidable_subtyping_strong_existential_completeness}]

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \rho \typdiff \eta
  )$ [Thm \ref{thm:model_subtyping_difference_introduction}]


  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails
    \tau_l \subtypes \J{LFP[} \alpha \J{]}\tau_r \given \Theta', \Delta'
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau_l \circlearrowleft \J{LFP[} \alpha \J{]} \tau_r
  )$ [Def. \ref{def:proof_subtyping_lfp_intro}]
  \item \I \N And $(
    \Theta, \Delta \entails
    \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
    \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_lfp_intro}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies
    \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
  )$ [IH]

  \item \I \N For $\delta$, assume $(
    \delta \oplus \delta' \satisfies \Delta'
  )$

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies
    \tau_l \subtypes \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r]
  )$ [P]

  \item \I\I \N Derive $(
    \forall e \qua
    \delta \oplus \delta' \satisfies
    e \hastype \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r] 
    \implies 
    \delta \oplus \delta'\ \alpha \slash \J{LFP[} \alpha \J{]} \tau_r \satisfies
    e \hastype
    \tau_r
  )$ [Thm. \ref{thm:type_substitution_correspondence}]

  \item \I\I \N Derive $(
    \forall e \qua
    \delta \oplus \delta' \satisfies
    e \hastype \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r] 
    \implies 
    \delta \oplus \delta' \satisfies
    e \hastype
    \J{LFP[} \alpha \J{]} \tau_r
  )$ [Thm. \ref{def:model_typing}]

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies
    \tau_r[\alpha \slash \J{LFP[} \alpha \J{]} \tau_r] \subtypes \J{LFP[} \alpha \J{]} \tau_r
  )$ [Def. \ref{def:model_subtyping}]

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies
    \tau_l \subtypes \J{LFP[} \alpha \J{]} \tau_r
  )$ [Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \rho \typdiff \eta \subtypes \tau \given \Theta', \Delta'
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails 
    \rho \subtypes \eta \J{|} \tau \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_diff_elimination}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \rho \subtypes \eta \J{|} \tau
  )$ [IH]
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \rho \subtypes \eta \J{|} \tau
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \rho \typdiff \eta \subtypes \tau
  )$ [Thm. \ref{thm:model_subtyping_difference_elimination}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Theta', \Delta' 
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau \subtypes \tau_{l} \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_expansion_introduction}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau \subtypes \tau_{l}
  )$ [IH]
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \tau_{l}
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \tau_l \J{|} \tau_r
  )$ [Thm. \ref{thm:model_subtyping_union_right_introduction}, Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails \tau \subtypes \tau_{l}\J{|}\tau_{r} \given \Theta', \Delta' 
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau \subtypes \tau_{r} \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_expansion_introduction}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau \subtypes \tau_{r}
  )$ [IH]
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \tau_{r}
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau \subtypes \tau_l \J{|} \tau_r
  )$ [Thm. \ref{thm:model_subtyping_union_left_introduction}, Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \tau_l
    \subtypes 
    \J{EXI[}\Theta_r\J{]}\Delta_r\ \tau_r \given \Theta'', \Delta'' 
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_expansion_introduction}]
  \item \I \N And $(
    \Theta', \Delta' \entails \Delta_r \given \Theta'', \Delta'' 
  )$ [Def. \ref{def:proof_subtyping_expansion_introduction}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta' \qua 
    \delta \oplus \delta_0 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_0 \satisfies \tau_l \subtypes \tau_r
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [Inductive Thm. \ref{thm:proof_subtyping_sequence_soundness}]
  \item \I \N And P1: $(
    \forall \delta' \qua 
    \delta \oplus \delta_1 \satisfies \Delta'' 
    \implies 
    \delta \oplus \delta_1 \satisfies \Delta_r 
  )$ [Inductive Thm. \ref{thm:proof_subtyping_sequence_soundness}]


  \item \I \N For $\delta$, assume $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta''
  )$


  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_sequence_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \tau_l \subtypes \tau_r
  )$ [P0]


  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:subtyping_interpretation_independence}]


  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta_r
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_l \subtypes \J{EXI[}\Theta_r\J{]}\Delta_r\ \tau_r
  )$ [Thm \ref{thm:model_subtyping_indexed_union_introduction}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Theta', \Delta' 
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau_{l} \subtypes \tau \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_refinement_elimination}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau_l \subtypes \tau
  )$ [IH]
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \subtypes \tau
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \J{\&} \tau_r \subtypes \tau 
  )$ [Thm. \ref{thm:model_subtyping_intersection_right_elimination}, Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails \tau_{l}\J{\&}\tau_{r}  \subtypes \tau \given \Theta', \Delta'
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau_r \subtypes \tau \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_subtyping_refinement_elimination}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P: $(
    \forall \delta \qua 
    \delta \oplus \delta' \satisfies \Delta' 
    \implies 
    \delta \oplus \delta' \satisfies \tau_r \subtypes \tau
  )$ [IH]
  \item \I \N For $\delta$, 
    assume $(\delta \oplus \delta' \satisfies \Delta')$
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_r \subtypes \tau
  )$ [P]
  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies \tau_l \J{\&} \tau_r \subtypes \tau 
  )$ [Thm. \ref{thm:model_subtyping_intersection_left_elimination}, Thm. \ref{thm:model_subtyping_transitivity}]

  %%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta \entails 
    \J{ALL[}\Theta_l\J{]} \Delta_l\ \tau_l
    \subtypes 
    \tau_r
    \given \Theta'', \Delta'' 
  )$
  \item \I \N Derive $(
    \Theta, \Delta \entails \tau_l \subtypes \tau_r \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_subtyping_refinement_elimination}]
  \item \I \N And $(
    \Theta', \Delta' \entails \Delta_l \given \Theta'', \Delta'' 
  )$ [Def. \ref{def:proof_subtyping_refinement_elimination}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta \qua 
    \delta \oplus \delta_0 \satisfies \Delta' 
    \implies 
    \delta \oplus \delta_0 \satisfies \tau_l \subtypes \tau_r
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [Inductive Thm. \ref{thm:proof_subtyping_sequence_soundness}]
  \item \I \N And P1: $(
    \forall \delta \qua 
    \delta \oplus \delta_1 \satisfies \Delta'' 
    \implies 
    \delta \oplus \delta_1 \satisfies \Delta_l 
  )$ [Inductive Thm. \ref{thm:proof_subtyping_sequence_soundness}]


  \item \I \N For $\delta$, assume $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta''
  )$


  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_sequence_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \tau_l \subtypes \tau_r
  )$ [P0]


  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:subtyping_interpretation_independence}]


  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta_l
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \J{ALL[}\Theta_l\J{]}\Delta_l\ \tau_l \subtypes \tau_r
  )$ [Thm. \ref{thm:model_subtyping_indexed_intersection_elimination}]

  %%%%%%%%%%%%%%%%

  \noindent
  $\square$
\end{theorem}
\hfill


\begin{theorem}
  \label{thm:proof_typing_soundness}
  Proof Typing Soundness 
  \\
  \small
  \begin{mathpar}
    \inferrule {
      \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
    } {
      \exists \delta' \qua \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta \up 
      (
      \forall \delta, \sigma \qua 
      \delta \oplus \delta' \satisfies \Delta' \implies
      \delta, \sigma \satisfies \Gamma \implies
      \delta \oplus \delta' \satisfies e[\sigma] \hastype \tau
      )
    }
  \end{mathpar}
  \\\\
  \noindent
  Induct over Definition \ref{def:proof_typing}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
      \Theta, \Delta, \Gamma \entails \J{@} \hastype \J{@} 
      \given \Theta, \Delta
  )$

  \item \I \N Derive $(
    \textbf{dom}(\epsilon) \subseteq \Theta \backslash \Theta
  )$

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \epsilon \satisfies \Delta')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies \J{@} \hastype \J{@}
  )$ [Def. \ref{def:model_typing}]

  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies \J{@}[\sigma] \hastype \J{@}
  )$ [Def. \ref{def:expr_substitution}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta, \Gamma \entails x \hastype \tau \given \Theta, \Delta
  )$

  \item \I \N Derive $(
    x \hastype \tau \in \Gamma 
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Derive $(
    \textbf{dom}(\epsilon) \subseteq \Theta \backslash \Theta
  )$

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \epsilon \satisfies \Delta')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies x[\sigma] \hastype \tau
  )$ [Def. \ref{def:model_typing_sequence}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta, \Gamma \entails \epsilon \hastype \J{TOP} \given \Theta, \Delta
  )$

  \item \I \N Derive $(
    \textbf{dom}(\epsilon) \subseteq \Theta \backslash \Theta
  )$

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \epsilon \satisfies \Delta')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies \epsilon \hastype \J{TOP}
  )$ [Def. \ref{def:model_typing}]

  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies \epsilon[\sigma] \hastype \J{TOP}
  )$ [Def. \ref{def:expr_substitution}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
    r\ \J{<}l \J{>} e \hastype (\tau\ \J{\&}\ \J{<} l \J{>} \tau') \given \Theta'', \Delta''
  )$

  \item \I \N Derive $(
    \Theta, \Delta, \Gamma \entails r \hastype \tau \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Derive $(
    \Theta', \Delta', \Gamma \entails e \hastype \tau' \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]

  \item \I \N And P0: $(
    \forall \delta \qua 
    \delta \oplus \delta_0 \satisfies \Delta'
    \implies 
    \delta, \sigma \satisfies \Gamma
    \implies 
    \delta \oplus \delta_0 \satisfies r \hastype \tau 
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [IH]

  \item \I \N And P1: $(
    \forall \delta \qua 
    \delta \oplus \delta_1 \satisfies \Delta'
    \implies 
    \delta, \sigma \satisfies \Gamma
    \implies 
    \delta \oplus \delta_1 \satisfies e \hastype \tau'
  )$ [IH]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$ 

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_typing_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies r \hastype \tau
  )$ [P0]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies r[\sigma] \hastype \tau
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness}, 
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Gamma
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness},
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_sequence_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e[\sigma] \hastype \tau'
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies r[\sigma]\J{<}l\J{>}e[\sigma] \hastype \tau
  )$ [Thm. \ref{thm:record_extension_preservation}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies r[\sigma]\J{<}l\J{>}e[\sigma] \hastype \J{<}l\J{>}\tau'
  )$ [Thm. \ref{thm:entry_type_introduction}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies r[\sigma]\J{<}l\J{>}e[\sigma] \hastype \tau \J{\&} \J{<}l\J{>}\tau'
  )$ [Def. \ref{def:model_typing}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies (r\J{<}l\J{>}e)[\sigma] \hastype \tau \J{\&} \J{<}l\J{>}\tau'
  )$ [Def. \ref{def:expr_substitution}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta, \Gamma \entails f \hastype \tau \given \Theta, \Delta
  )$

  \item \I \N Derive $(
    \exists \Xi \qua \Theta, \Delta, \Gamma \entails f \liftfun \Pi \sim \Xi
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Derive $(
    \Theta \cup \textbf{ftv}(\Delta) \cup \textbf{ftv}(\Gamma) = \dTheta
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Derive $(
    \textbf{pack}^+(\dTheta \entails \Pi) = \tau
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Derive $(
    \textbf{dom}(\epsilon) \subseteq \Theta \backslash \Theta
  )$

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \epsilon \satisfies \Delta)$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \satisfies \Delta'
  )$

  \item \I\I \N Derive $(
    \delta \satisfies f[\sigma] \hastype \tau
  )$ [Ind. Thm. \ref{thm:path_sequence_typing_soundness}, Thm. \ref{thm:function_lifting_skolem_freshness},
      Thm. \ref{thm:packing_correspondence}]

  \item \I\I \N Derive $(
    \delta \oplus \epsilon \satisfies f[\sigma] \hastype \tau
  )$ 

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta, \Gamma \entails e \J{.} l \hastype \alpha \given \Theta'', \Delta''
  )$

  \item \I \N Derive $(
    \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Derive $(
    \Theta', \Delta' \entails \tau \subtypes  \J{<} l \J{>} \alpha \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_typing}]


  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_a) \subseteq \Theta' \backslash \Theta
  )$ [IH]

  \item \I \N And P0: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_0 \satisfies \Delta' \implies
    \delta, \sigma \satisfies \Gamma \implies
    \delta \oplus \delta_0 \satisfies e[\sigma] \hastype \tau
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_a) \subseteq \Theta'' \backslash \Theta'
  )$ [Ind. Thm. \ref{thm:proof_subtyping_soundness}]

  \item \I \N And P1: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_1 \satisfies \Delta'' \implies
    \delta \oplus \delta_1 \satisfies \tau \subtypes \J{<}l\J{>}\alpha
  )$ [Ind. Thm. \ref{thm:proof_subtyping_soundness}]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$ [Thm. \ref{thm:domain_extension}]

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies e[\sigma] \hastype \tau
  )$ [P0]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e[\sigma] \hastype \tau
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, 
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \tau \subtypes \J{<} l \J{>} \alpha
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e[\sigma] \hastype \J{<}l\J{>}\alpha
  )$ [Thm. \ref{thm:model_typing_subsumption}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies (e[\sigma])\J{.}l
  )$ [Thm. \ref{thm:model_typing_entry_elimination}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies (e\J{.}l)[\sigma]
  )$ [Def. \ref{def:expr_substitution}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item \N Assume $(
    \Theta, \Delta, \Gamma \entails e_f \J{(} e_a \J{)} \hastype \alpha \given \Theta''', \Delta'''
  )$
  \item \I \N Derive $(
    \Theta, \Delta, \Gamma \entails e_f \hastype \tau_f \given \Theta', \Delta'
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \Theta', \Delta', \Gamma \entails e_a \hastype \tau_a \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \Theta'', \Delta'', \tau_f \subtypes \tau_a\J{->}\alpha \given \Theta''', \Delta'''
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_0 \satisfies \Delta' \implies
    \delta, \sigma \satisfies \Gamma \implies
    \delta \oplus \delta_0 \satisfies e_f[\sigma] \hastype \tau_f
  )$ [IH]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [IH]
  \item \I \N And P1: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_1 \satisfies \Delta' \implies
    \delta, \sigma \satisfies \Gamma \implies
    \delta \oplus \delta_1 \satisfies e_a[\sigma] \hastype \tau_a
  )$ [IH]

  \item \I \N Let $\delta_2$ be, such that $(
    \textbf{dom}(\delta_2) \subseteq \Theta''' \backslash \Theta''
  )$ [Ind. Thm. \ref{thm:proof_subtyping_soundness}]
  \item \I \N And P2: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_2 \satisfies \Delta' \implies
    \delta \oplus \delta_2 \satisfies \tau_f \subtypes \tau_a \J{->} \alpha
  )$ [Ind. Thm. \ref{thm:proof_subtyping_soundness}]

  \item \I \N Derive $(
    \text{dom}(\delta_0 \oplus \delta_1 \oplus \delta_2) \subseteq \Theta''' \backslash \Theta
  )$ [Thm. \ref{thm:domain_extension}]


  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies \Delta''')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies \Delta''
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta''
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_typing_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies e_f[\sigma] \hastype \tau_f
  )$ [P0]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e_f[\sigma] \hastype \tau_f
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness}, 
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies e_f[\sigma] \hastype \tau_f
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, 
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Gamma
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness},
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_sequence_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e_a[\sigma] \hastype \tau_a
  )$ [P1]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies e_a[\sigma] \hastype \tau_a
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, 
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2  \satisfies \tau_f \subtypes \tau_a \J{->} \alpha
  )$ [P2]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies e_f[\sigma] \hastype \tau_a \J{->} \alpha
  )$ [Thm. \ref{thm:model_typing_subsumption}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies e_f[\sigma]\J{(}e_a[\sigma]\J{)} \hastype \alpha
  )$ [Thm \ref{thm:model_typing_path_elimination}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \oplus \delta_2 \satisfies (e_f\J{(}e_a\J{)})[\sigma] \hastype \alpha
  )$ [Def. \ref{def:expr_substitution}]


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item \N Assume $(
    (\Theta, \Delta, \Gamma \entails \J{let } x \J{:} \tau_a \J{ = } e \J{ in } e' \hastype \tau' \given \Theta'', \Delta'')
  )$
  \item \I \N Derive $(
    \Theta, \Delta, \Gamma \entails e \hastype \tau \given \Theta', \Delta' 
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \textbf{ftv}(\tau_a) \subseteq \emptyset
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \exists \Theta^\dagger, \Delta^\dagger \qua \Theta', \Delta' \entails \tau \subtypes \tau_a \given \Theta^\dagger, \Delta^\dagger
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \Theta', \Delta', \Gamma, x:\tau_a \entails e' \hastype \tau' \given \Theta'', \Delta''
  )$ [Def. \ref{def:proof_typing}]


  \item \I \N Let $\delta_0$ be, such that $(
    \textbf{dom}(\delta_0) \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_0 \satisfies \Delta' \implies
    \delta, \sigma \satisfies \Gamma \implies
    \delta \oplus \delta_0 \satisfies e[\sigma] \hastype \tau
  )$ [IH]

  \item \I \N Let $\Theta^\dagger$, $\Delta^\dagger$ be, such that $(
    \Theta', \Delta' \entails \tau \subtypes \tau_a \given \Theta^\dagger, \Delta^\dagger
  )$

  \item \I \N Let $\delta^\dagger$ be, such that $(
    \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \backslash \Theta'
  )$ [Ind. Thm. \ref{thm:proof_subtyping_soundness}]
  \item \I \N And P$\dagger$: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
    \delta \oplus \delta^\dagger \satisfies \tau \subtypes \tau_a
  )$ [Ind. Thm. \ref{thm:proof_subtyping_soundness}]

  \item \I \N Let $\delta_1$ be, such that $(
    \textbf{dom}(\delta_1) \subseteq \Theta'' \backslash \Theta'
  )$ [IH]
  \item \I \N And P1: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta_1 \satisfies \Delta'' \implies
    \delta, \sigma \satisfies \Gamma\ x \hastype \tau_a \implies
    \delta \oplus \delta_1 \satisfies e'[\sigma] \hastype \tau'
  )$ [IH]


  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta^\dagger) \subseteq \Theta^\dagger \backslash \Theta
  )$ [Thm. \ref{thm:domain_extension}]

  \item \I \N Derive $(
    \textbf{dom}(\delta_0 \oplus \delta_1) \subseteq \Theta'' \backslash \Theta
  )$ [Thm. \ref{thm:domain_extension}]


  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_containment}, Thm. \ref{thm:model_subtyping_sequence_elimination}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Delta'
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies e[\sigma] \hastype \tau
  )$ [P0]
  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e[\sigma] \hastype \tau
  )$ [Thm. \ref{thm:proof_subtyping_skolem_freshness}, 
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta^\dagger \satisfies \Delta^\dagger
  )$ [Ind. Thm. NonVac \TODO{...}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta^\dagger \satisfies \tau \subtypes \tau_a
  )$ [P$\dagger$]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \tau \subtypes \tau_a
  )$ [Because ftv is empty]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies e[\sigma] \hastype \tau_a
  )$ [Thm. \ref{thm:model_typing_subsumption}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \satisfies \Gamma
  )$ [Thm. \ref{thm:proof_typing_skolem_freshness},
      Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_sequence_interpretation_independence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0\ x \slash e[\sigma] \satisfies \Gamma\ x \slash \tau_a
  )$ [Def. \ref{def:model_typing_sequence}]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e'[\sigma\ x\slash[\sigma]] \hastype \tau'
  )$ [P2]

  \item \I\I \N Derive $(
    \delta \oplus \delta_0 \oplus \delta_1 \satisfies e'[\sigma][x\slash[\sigma]] \hastype \tau'
  )$ [Def. \ref{def:expr_substitution}]

  \item \I\I \N Derive $(
    \delta \oplus \delta \entails \J{let } x \J{:} \tau_a \J{ = } e[\sigma] \J{ in } e'[\sigma] \hastype \tau'
  )$ [Thm. \ref{thm:annotated_binding_introduction}]

  \item \I\I \N Derive $(
    \delta \oplus \delta \entails (\J{let } x \J{:} \tau_a \J{ = } e \J{ in } e')[\sigma] \hastype \tau'
  )$ [Def. \ref{def:expr_substitution}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \item \N Assume $(
    \Theta, \Delta, \Gamma \entails \J{loop(}e\J{)} \hastype 
    \tau_l \J{->} \tau_r \given \Theta', \Delta'
  )$
  \item \I \N Derive $(
    \Theta, \Delta, \Gamma \entails e \hastype \tau \given  \Theta', \Delta'
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \Theta', \Delta' \entails \tau \subtypes \alpha_\nu \rightarrow \Pi_\nu
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \alpha_\nu \downarrow \Pi_\nu \fallingdotseq \alpha_\mu \uparrow \Pi_\mu
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \textbf{pack}^-(\textbf{ftv}(\Delta)\ \alpha_\mu \entails \Pi_\mu) = \tau_\mu
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<left>}\ \tau_l
  )$ [Def. \ref{def:proof_typing}]
  \item \I \N Derive $(
    \factorsinto \J{LFP[} \alpha_\mu \J{]}\tau_\mu \subtypes \J{<right>}\ \tau_r
  )$ [Def. \ref{def:proof_typing}]

  \item \I \N Let $\delta'$ be, such that $(
    \textbf{dom}(\delta') \subseteq \Theta' \backslash \Theta
  )$ [IH]
  \item \I \N And P0: $(
    \forall \delta, \sigma \qua 
    \delta \oplus \delta' \satisfies \Delta' \implies
    \delta, \sigma \satisfies \Gamma \implies
    \delta \oplus \delta' \satisfies e[\sigma] \hastype \tau
  )$ [P0]

  \item \I \N For $\delta$, $\sigma$,
    assume $(\delta \oplus \delta' \satisfies \Delta')$
    and $(\delta, \sigma \satisfies \Gamma)$

  \item \I\I \N Derive $(
    \delta \oplus \delta' \satisfies e[\sigma] \hastype \tau
  )$ [P0]

  \item \I\I \N Derive P1: $(
    \forall \delta'' \qua \textbf{dom}(\delta'') \cap \textbf{ftv}(\Delta') = \emptyset \implies \delta \oplus \delta' \oplus \delta'' \satisfies \Delta'
  )$ [Thm. \ref{thm:model_subtyping_sequence_interpretation_independence}]

  \item \I\I \N Derive P2: $(
    \forall \delta'' \qua \textbf{dom}(\delta'') \cap \textbf{ftv}(\Delta') = \emptyset \implies \delta \oplus \delta' \oplus \delta'' \satisfies e[\sigma] \hastype \tau
  )$ [Thm. \ref{thm:proof_typing_containment},
      Thm. \ref{thm:model_typing_interpretation_independence}]

  \item \I\I \N Derive P3: $(
    \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
    (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
    \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \up 
    (
    \forall \delta \qua
    \delta \oplus \delta^\dagger \satisfies \Delta' \implies
    \delta \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
    \delta \oplus \delta^\dagger \satisfies \tau \subtypes \alpha \J{->} \tau^\dagger
    )
  )$ [Thm. \ref{thm:function_type_explosion_soundness}, Thm. \ref{thm:model_subtyping_sequence_introduction}]

  \item \I\I \N Derive $(
    \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
    (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
    \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \up 
    (
    \forall \delta'' \qua
    \delta \oplus \delta' \oplus \delta'' \oplus \delta^\dagger \satisfies \Delta' \implies
    \delta \oplus \delta' \oplus \delta'' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
    \delta \oplus \delta' \oplus \delta'' \oplus \delta^\dagger \satisfies \tau \subtypes \alpha \J{->} \tau^\dagger
    )
  )$ [P3]

  \item \I\I \N Derive $(
    \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
    (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
    \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \up 
    (
    \forall \delta'' \qua
    \textbf{dom}(\delta'') \cap \textbf{ftv}(\Delta') = \emptyset \implies
    \delta' \oplus \delta \oplus \delta'' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
    \delta' \oplus \delta \oplus \delta'' \oplus \delta^\dagger \satisfies e[\sigma] \hastype \alpha \J{->} \tau^\dagger
    )
  )$ [P1, P2, Thm. \ref{thm:model_typing_subsumption}]

  \item \I\I \N Derive $(
    \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
    (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
    \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \up 
    (
    \forall \delta'' \qua
    \textbf{dom}(\delta'') \cap \textbf{ftv}(\Delta') = \emptyset \implies
    \delta \oplus \delta'\ \alpha \slash \J{BOT} \oplus \delta'' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
    \delta \oplus \delta'\ \alpha \slash \J{BOT} \oplus \delta'' \oplus \delta^\dagger \satisfies e[\sigma] \hastype \alpha \J{->} \tau^\dagger
    )
  )$ [Thm. \ref{...} \TODO{weakest interpretation of alpha}]

  \item \I\I \N Derive $(
    \forall \Theta^\dagger, \Delta^\dagger, \tau^\dagger \qua 
    (\Theta^\dagger, \Delta^\dagger, \tau^\dagger) \in \Pi_\nu \implies
    \exists \delta^\dagger \qua \textbf{dom}(\delta^\dagger) \subseteq \Theta^\dagger \up 
    (
    \forall \delta'' \qua
    \textbf{dom}(\delta'') \cap \textbf{ftv}(\Delta') = \emptyset \implies
    \delta \oplus \delta' \oplus \delta'' \oplus \delta^\dagger \satisfies \Delta^\dagger \implies
    \delta \oplus \delta' \oplus \delta'' \oplus \delta^\dagger \satisfies \J{loop(}e[\sigma]\J{)} \hastype \tau^\dagger
    )
  )$ [Thm. \ref{thm:model_typing_path_elimination_loop}]

  \item \I\I \N Derive $(
    \forall e_a, e_r \qua 
    \delta \oplus \delta'\ \alpha_\mu \slash \J{TOP} \satisfies (e_a\J{,}e_r) \hastype \tau_\mu
    \implies 
    e_r \cong \J{loop(}e[\sigma]\J{)(} e_a \J{)}
  )$ [Thm. \ref{thm:packing_correspondence}]

  \item \I\I \N Derive $(
    \forall e_a, e_r \qua 
    \delta \oplus \delta' \satisfies (e_a\J{,}e_r) \hastype \J{LFP[}\alpha_\mu\J{]}\tau_\mu
    \implies 
    e_r \cong \J{loop(}e[\sigma]\J{)(} e_a \J{)}
  )$ [Thm. \ref{thm:least_fixed_point_type_elimination}]

  \item \I\I \N Derive $(
    \forall e_a, e_r \qua 
    \delta \oplus \delta' \satisfies (e_a\J{,}e_r) \hastype \J{LFP[}\alpha_\mu\J{]}\tau_\mu
    \implies 
    \delta \oplus \delta' \satisfies e_r \hastype \tau_r 
    \up
    e_r \cong \J{loop(}e[\sigma]\J{)(} e_a \J{)}
  )$ [Thm. \ref{thm:subtyping_factorization_correspondence},
      Thm. \ref{thm:model_typing_subsumption},
      Thm. \ref{thm:model_typing_entry_elimination},
      Thm. \ref{thm:right_congruence}]

  \item \I\I \N Derive $(
    \forall e_a, e_r \qua 
    \delta \oplus \delta' \satisfies e_a \hastype \tau_l 
    \implies 
    \delta \oplus \delta' \satisfies e_r \hastype \tau_r 
    \up
    e_r \cong \J{loop(}e[\sigma]\J{)(} e_a \J{)}
  )$ [Thm. \ref{thm:left_congruence}, Thm. \ref{thm:subtyping_factorization_correspondence}]

  \item \I\I \N Derive $(
    \forall e_a \qua 
    \delta \oplus \delta' \satisfies e_a \hastype \tau_l 
    \implies 
    \delta \oplus \delta' \satisfies \J{loop(}e[\sigma]\J{)(} e_a \J{)} \hastype \tau_r 
  )$ [Thm. \ref{thm:expression_congruence_typing} \TODO{...}]

  \item \I\I \N Derive $(
    \delta \oplus \delta'  \satisfies \J{loop(}e[\sigma]\J{)} \hastype \tau_l \J{->}\tau_r 
  )$ [Thm. \ref{thm:model_typing_path_elimination_loop}]

  \item \I\I \N Derive $(
    \delta \oplus \delta'  \satisfies \J{loop(}e\J{)}[\sigma] \hastype \tau_l \J{->}\tau_r 
  )$ [Thm. \ref{def:expr_substitution}]

  \noindent
  $\square$

\end{theorem}


\TODO{update implementation to be consistent with paper}.



% \begin{definition}\boxed{\VDash e}
%   \label{def:expression_good_formation}
%   \begin{mathpar}
%     \inferrule {
%       e = v
%     } {
%       \VDash e
%     } 

%     \inferrule { 
%       e \rightsquigarrow e' 
%       \\
%       \VDash e'
%     } {
%       \VDash e
%     } 
%   \end{mathpar}
% \end{definition}

% \begin{theorem}(Typing Soundness)
%   \label{thm:typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \entails e \hastype \tau \given Z
%     } {
%       \VDash e
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{assume } \entails e \hastype \tau \given Z$
%     \item \Z $\B{let } \delta\ \Gamma' \ \tau' \B{ s.t. } \delta, \Gamma' \satisfies e \hastype \tau'$ by \D{Lemma \ref{thm:proof_typing_soundness}}
%     \item \Z $\delta, \sigma \satisfies \Gamma'$ by ...
%     \item \Z $\VDash e[\sigma]$ by theorem \ref{thm:model_typing_soundness}
%     \item \Z $e[\sigma] = e$ by ...
%     \item \Z $\VDash e$ by substitution 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Proof typing consistency)
%   \label{thm:proof_typing_consistency}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       \exists \delta .\ \delta \satisfies Z
%     } 
%   \end{mathpar}
%   \TODO{...}
% \end{theorem}

% \begin{theorem}(Proof typing soundness)
%   \label{thm:proof_typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau
%     } 
%   \end{mathpar}
%   \TODO{...}
% \end{theorem}


% \begin{theorem}(Proof typing weak soundness)
%   \label{thm:proof_typing_weak_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       \forall \delta .\ \delta \satisfies Z \implies \delta, \Gamma \satisfies e \hastype \tau
%     } 
%   \end{mathpar}

%   \TODO{rewrite inductive hypotheses with just the conclusion implied by the case conditions}

%   \TODO{rewrite cases with universal/implication in conclusion/hypotheses}

%   Proof: 
%   \item $
%     \B{assume } 
%     \Gamma \entails e \hastype \tau \given Z 
%   $ 
%     \item \Z $\B{induct on } \Gamma \entails e \hastype \tau \given Z$ 
% \end{theorem}

%     \item \Z $\B{case } e = \J{@} \I \tau = \J{@}$ 
%       \item \Z\Z $\B{let } \delta$ by definition
%       \item \Z\Z $\delta, \Gamma \satisfies \J{@} \hastype \J{@}$ by definition
%       \item \Z\Z $\delta, \Gamma \satisfies e \hastype \tau$ by substitution
%       \item \Z\Z $\exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau$ by witness 

%     \item \Z $\B{case } e = x \I \J{$x$:$\tau$} \in \Gamma$ 
%     \item \Z $\B{wrt } x$ 
%       \item \Z\Z $\B{let } \delta$ by definition
%       \item \Z\Z $\delta, \Gamma \satisfies x \hastype \tau$  by definition
%       \item \Z\Z $\delta, \Gamma \satisfies e \hastype \tau$ by substitution
%       \item \Z\Z $\exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau$ by witness 

%   \item \Z $\B{case } 
%     \Gamma \entails e' \hastype \tau' \given Z
%     \I
%     \tau = \J{<$l$>$\tau'$}
%     \I
%     e = \J{<$l$>$e'$} 
%   $ 
%   \item \Z $\B{hypo } 
%       \Gamma \entails e' \hastype \tau' \given Z  
%       \implies
%       \delta, \Gamma \satisfies e' \hastype \tau'
%   $ 
%   \item \Z $\B{wrt } e' \ \tau'$ 
%     \item \Z\Z $\B{let } \delta $ by definition
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e' \hastype \tau'
%     $ by application
%     \item \Z\Z $
%       \delta, \Gamma \satisfies \J{<$l$>$e'$} \hastype \J{<$l$>$\tau'$}
%     $ by definition
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e \hastype \tau 
%     $ by substitution
%     \item \Z\Z $
%       \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau 
%     $ by witness 

%   \item \Z \TODO{remaining trivial introduction cases} 
%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   \item \Z $\B{case } $ 
%   \item \Z $\B{hypo } $ 
%   \item \Z $\B{wrt } $ 
%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   %   \inferrule {
%   %     \Gamma \entails R \hastype \tau_0 \given Z_0
%   %     \\
%   %     Z_0 \looparrowright Z_1
%   %     \\
%   %     \Gamma \entails e \hastype \tau_1 \given Z_1
%   %   } {
%   %     \Gamma \entails R\ \J{*$l$=$e$} \hastype \tau_0\ \J{\&}\ \J{$l$:$\tau_1$} \given Z_1
%   %   }

%   %   \inferrule {
%   %     Z, \Gamma \entails F \liftfun \Pi, \Tau_n 
%   %     \\
%   %     \Gamma \entails \Pi \equiv \Tau 
%   %   } {
%   %     \Gamma \entails F \hastype \J{\&}(\Tau) \given Z
%   %   }
%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%   \item \Z $\B{case } 
%     \Gamma \entails e_0 \hastype \tau_0 \given Z_0
%     \I
%     Z_0 \looparrowright Z_1
%     \I
%     \tau_0 \subtypes \J{$l$->$\alpha$} \given Z_1
%     \I
%     e = \J{$e_0$.$l$} \I \tau = \alpha \I Z = Z_1
%   $
   
%   \item \Z $\B{hypo } 
%     \Gamma \entails e_0 \hastype \tau_0 \given Z_0 
%     \implies 
%     \delta, \Gamma \satisfies e_0 \hastype \tau_0
%   $ 
%   \item \Z $\B{wrt } \delta\ e' \ l \ \alpha \ \tau_0 \ Z_0 \ Z_1$ 

%     \item \Z\Z $
%       \delta, \Gamma \satisfies e_0 \hastype \tau_0
%     $ by application

%     \item \Z\Z $
%       \B{let }
%       M\ \Delta
%       \B{ s.t. }
%       \tau_0 \subtypes \J{$l$->$\alpha$} \given M, \Delta
%     $ by theorem \ref{thm:proof_subtyping_choice}


%     \item \Z\Z $
%       \delta \satisfies \tau_0  \subtypes \J{$l$->$\alpha$}
%     $ by theorem \ref{thm:proof_subtyping_weak_soundness}
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e_0 \hastype \J{$l$->$\alpha$}
%     $ by theorem \ref{thm:model_subtyping_elimination} 
%     \item \Z\Z $
%       \delta, \Gamma \satisfies \J{$e_0$.$l$} \hastype \alpha 
%     $ by theorem \ref{thm:model_subtyping_record_elimination} 
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e \hastype \tau
%     $ by substitution 
%     \item \Z\Z $
%       \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau
%     $ by witness 


%   \item \Z $\B{case } 
%     \Gamma \entails e_0 \hastype \tau_0 \given Z_0
%     \I
%     Z_0 \looparrowright Z_1
%     \I
%     \Gamma \entails e_1 \hastype \tau_1 \given Z_1
%     \I
%     e = \J{$e_0$($e_1$)} 
%     \I 
%     \tau = \alpha 
%     \I
%     Z = Z_2
%   $ 
%   \item \Z $ 
%     Z_1 \looparrowright Z_2
%     \I
%     \tau_0 \subtypes \J{$\tau_1$->$\alpha$} \given Z_2
%   $ 
%   \item \Z $\B{hypo } 
%     \Gamma \entails e_0 \hastype \tau_0 \given Z_0
%     \implies 
%     \delta, \Gamma \satisfies e_0 \hastype \tau_0
%     \I
%     \Gamma \entails e_1 \hastype \tau_1 \given Z_1
%     \implies 
%     \delta, \Gamma \satisfies e_1 \hastype \tau_1
%   $ 
%   \item \Z $\B{wrt } e_0\ e_1\ \alpha\ \tau_0\ \tau_1\ Z_0\ Z_1\ Z_2 $ 
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e_0 \hastype \tau_0
%     $ by application
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e_1 \hastype \tau_1
%     $ by application

%     \item \Z\Z $
%       \B{let } M\ \Delta
%       \B{ s.t. }
%       \tau_0 \subtypes \J{$\tau_1$->$\alpha$} \given \left<M, \Delta \right>
%     $ by theorem \ref{thm:proof_subtyping_choice} 
%     \item \Z\Z $
%       \delta, \Gamma \satisfies \tau_0 \subtypes \J{$\tau_1$->$\alpha$} 
%     $ by theorem \ref{thm:proof_subtyping_weak_soundness} 
%     \item \Z\Z $
%       \delta \satisfies e_0 \hastype \J{$\tau_1$->$\alpha$} 
%     $ by theorem \ref{thm:model_subtyping_elimination} 
%     \item \Z\Z $
%       \delta, \Gamma \satisfies \J{$e_0$($e_1$)} \hastype \alpha
%     $ by theorem \ref{thm:model_typing_implication_elimination} 
%     \item \Z\Z $
%       \delta, \Gamma \satisfies e \hastype \tau
%     $ by substitution 
%     \item \Z\Z $
%       \exists \delta .\ \delta, \Gamma \satisfies e \hastype \tau
%     $ by substitution 

%   \item \Z $\B{case } 
%     e = \J{loop($e'$)} 
%   $ 
%   \item \Z $\contin  
%     \tau = \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFLFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$} 
%   $
%   \item \Z $\contin 
%     Z = Z_0 
%   $
%   \item \Z $\contin  
%     \Gamma \entails e' \hastype \J{$\alpha_{h^+}$->$\tau'$} \given Z_0
%     \I
%     Z_0 \looparrowright Z_1
%     \I
%     \tau' \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%   $ 
%   \item \Z $\contin  
%     \textbf{ftv}(\Gamma) \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
%   $
%   \item \Z $\B{hypo } 
%     \forall \delta .\ \delta \satisfies Z_0 \implies
%     \delta, \Gamma \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau'$}
%   $ 
%   \item \Z $\B{wrt } e'\ \tau'\ \alpha_{h^+}\ \alpha_l\ \alpha_r\ \alpha_{h^-}\ \alpha_l'\ \alpha_r'\ \Tau\ Z_0\ Z_1 $ 
%     \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies Z$
%       \item \Z\Z\Z $\delta \satisfies Z_0$ by substitution
%       \item \Z\Z\Z $
%         \delta, \Gamma \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau'$}
%       $ by instantiation and application
%       \item \Z\Z\Z $
%         \delta \satisfies \tau' \subtypes 
%         \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$}
%       $ by theorem \ref{thm:fixpoint_duality_correspondence}

%       \item \Z\Z\Z $
%         \delta \satisfies \tau' \subtypes \tau
%       $ by substitution  

%       \item \Z\Z\Z $
%         \delta \satisfies e' \hastype \J{$\alpha_{h^+}$->$\tau$}
%       $ by theorem \ref{thm:model_subtyping_elimination} 

%       \item \Z\Z\Z $
%         \delta \satisfies \J{loop($e'$)} \hastype \tau 
%       $ by theorem \ref{thm:model_typing_implication_independence}

%       \item \Z\Z\Z $
%         \delta \satisfies e \hastype \tau 
%       $ by substitution 

%     \item \Z\Z $
%       \forall \delta .\ \delta \satisfies Z \implies \delta \satisfies e \hastype \tau 
%     $ by implication and generalization 

%   \item \Z $\delta, \Gamma \satisfies e \hastype \tau$
%     by induction
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Fixpoint duality soundness (new))
%   \label{thm:fixpoint_duality_correspondence}
%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%       \\
%       \textbf{ftv}(\tau) \subseteq N
%       \\
%       \alpha_l \notin N
%       \\
%       \alpha_r \notin N
%       \\
%       N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
%     } {
%       \delta \satisfies 
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
%     } 
%   \end{mathpar}
%   \TODO{...}
% \end{theorem}

% \TODO{Cretin's corresponding theorem is Theorem 101 on p. 134}

% \TODO{See how Cretin proves this without using subject reduction}

% \begin{theorem}(Fixpoint duality soundness old)
%   \label{thm:fixpoint_duality_correspondence_old}
%   \begin{mathpar}
%     \inferrule { 
%       Z_0 \looparrowright Z_1
%       \\
%       N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
%     } {
%       \forall \tau .\ 
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%       \implies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
%       \given Z_0
%     } 
%   \end{mathpar}
%   Proof: 
%   \item $\B{assume }
%     Z_0 \looparrowright Z_1
%     \I
%     N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
%   $ 
%   \item \Z $\B{induct on }
%     N \entails \alpha_{h^+} \cdot Z_1 \cdot \J{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
%   $
%   \item \Z $\B{case }
%     Z_1 = \epsilon \I \Tau = \epsilon
%   $
%     \item \Z\Z $\B{for } \tau$
%       \item \Z\Z\Z $\B{assume }
%         \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%       $
%         \item \Z\Z\Z\Z $
%           \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given \epsilon 
%         $ by substitution

%         \item \Z\Z\Z\Z $
%           \B{let } M\ \Delta\ \B{ s.t. } \left<M, \Delta\right> \in \epsilon 
%         $ by theorem \ref{thm:universe_proof_typing_worldly}  

%         \item \Z\Z\Z\Z $\bot$ by theorem \ref{thm:empty_containment_absurd}
%       \item \Z\Z\Z $
%         \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%         \implies
%         \tau
%         \subtypes
%         \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
%         \given Z_0
%       $ by implication
%     \item \Z\Z $
%       \forall \tau .\ 
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%       \implies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
%       \given Z_0
%     $ by generalization 
%   \item \Z $\B{case }
%     Z_1 = Z\ \left<M, \Delta \right> \I \Tau = \Tau_i\ \tau_i
%   $
%   \item \Z $\contin
%     N \entails 
%     \alpha_{h^+} \cdot Z \cdot \J{$\alpha_l$->$\alpha_r$} 
%     \fallingdotseq 
%     \alpha_{h^-} \cdot \Tau_i
%   $
%   \item \Z $\contin
%     M, \Delta, \Delta \entails \alpha_{h^+} \subtypes \Tau_h
%     \I
%     M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
%     \I
%     M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
%   $
%   \item \Z $\contin
%     \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\ \tau_r .\ \tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
%   $
%   \item \Z $\contin
%     N \cup M \cup \textbf{ftv}(\Tau_l) \cup \textbf{ftv}(\Tau_r)\ \alpha_{h^-} = \Alpha 
%     \I
%     \Delta \entails \Alpha \pitchfork \Delta_i  
%   $
%   \item \Z $\contin
%     N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
%   $
%   \item \Z $\B{hypo }
%     N \entails 
%     \alpha_{h^+} \cdot Z \cdot \J{$\alpha_l$->$\alpha_r$} 
%     \fallingdotseq 
%     \alpha_{h^-} \cdot \Tau_i
%     \implies
%     \\
%     \forall \tau .\ 
%     \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z
%     \implies
%     \tau
%     \subtypes
%     \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
%     \given Z_0
%   $
%   \item \Z $\B{wrt }
%     Z\ M\ \Delta\ \Tau_i\ \tau_i
%   $

%     \item \Z\Z $\B{for } \tau \B{ assume }
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%     $
%       \item \Z\Z\Z $
%         \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z\ \left<M, \Delta\right>
%       $ by substitution

%       \item \Z\Z\Z $
%         \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
%       $ by theorem \ref{thm:proof_subtyping_decomposition}

%       \item \Z\Z\Z $
%         \tau
%         \subtypes
%         \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
%         \given Z_0
%       $ by instantiation and application 
%       \item \Z\Z\Z $
%         \tau
%         \subtypes
%         \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r'$} 
%         \given Z_0
%       $ by theorem \ref{thm:universe_proof_typing_fixpoint_extension}
%     \item \Z\Z $
%       \forall \tau .\ 
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%       \implies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
%       \given Z_0
%     $ by implication and generalization 


%   \item \Z $
%     \forall \tau .\ 
%     \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given Z_1
%     \implies
%     \tau
%     \subtypes
%     \J{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
%     \given Z_0
%   $ by induction
%   \item $\square$ by implication
% \end{theorem}

% \begin{theorem}(Universe Proof Typing fixpoint extension)
%   \label{thm:universe_proof_typing_fixpoint_extension}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r$} 
%       \\\\
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
%       \\\\
%       \Delta \entails \alpha_{h^+} \subtypes \Tau_h
%       \\
%       \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       \Delta \entails \Tau_r \subtypes \alpha_r
%       \\\\
%       \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
%       \\
%       N \cup M \cup \textbf{ftv}(\Tau_l) \cup \textbf{ftv}(\Tau_r)\ \alpha_{h^-} = \Alpha 
%       \\ 
%       \Delta \entails \Alpha \pitchfork \Delta_i  
%       \\
%       N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
%     } {
%       \delta \satisfies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r$} 
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Universe Proof Typing case soundness)
%   \label{thm:universe_proof_typing_case_soundnes}
%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
%       \\\\
%       \Delta \entails \alpha_{h^+} \subtypes \Tau_h
%       \\
%       \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       \Delta \entails \Tau_r \subtypes \alpha_r
%       \\\\
%       \widebar{\J{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\J{->}\tau_r \in \Tau_h} = \Delta_h
%       \\
%       N \cup M \cup \textbf{ftv}(\Tau_l) \cup \textbf{ftv}(\Tau_r)\ \alpha_{h^-} = \Alpha 
%       \\ 
%       \Delta \entails \Alpha \pitchfork \Delta_i  
%       \\
%       N\ \alpha_{h^-}, M, \Delta_i \cup \Delta_h \entails \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
%     } {
%       \delta \satisfies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau_i$]$\alpha_r$} 
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Universe Proof Typing fixpoint union)
%   \label{thm:universe_proof_typing_fixpoint_union}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau$)]$\alpha_r$} 
%       \\
%       \delta \satisfies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau$]$\alpha_r$} 
%     } {
%       \delta \satisfies
%       \tau
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau\ \tau$)]$\alpha_r$} 
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}\ Influential soundness 
%   \label{thm:influential_soundness}

%   \TODO{Prove that any constraints on non-influential variables with have been transitively applied to the influential variables}

%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \J{$\alpha_l$->$\alpha_r$} \given M, \Delta
%       \\
%       \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       \Delta \entails \Tau_r \subtypes \alpha_r
%       \\\\
%       \Delta \entails \Alpha \pitchfork \Delta_i  
%       \\
%       \textbf{ftv}(\tau) \subseteq \Alpha
%       \\\\
%       N, M, \Delta \cup \Delta' \given \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau
%       \\
%       N, M, \Delta_i \cup \Delta' \given \J{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau_i
%     } {
%       \delta \satisfies \tau \subtypes \tau_i 
%       \land
%       \delta \satisfies \tau_i \subtypes \tau
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% % \begin{theorem}(Universe Proof Typing implication expansion)
% %   \label{thm:universe_proof_typing_implication}
% %   \begin{mathpar}
% %     \inferrule { 
% %       M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
% %       \\
% %       M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
% %       \\
% %     } {
% %       \J{\&$(\Tau_l)$->|$(\Tau_r)$}
% %       \subtypes
% %       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:(\&$(\Tau_l)$,|$(\Tau_r)$)]$\alpha_r$} 
% %       \given M, \Delta
% %     } 
% %   \end{mathpar}
% %   Proof: 
% %   \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
% %   \item $\square$
% % \end{theorem}

% \begin{theorem}(Universe Proof Typing implication expansion)
%   \label{thm:universe_proof_typing_implication_expansion}
%   \begin{mathpar}
%     \inferrule { 
%     } {
%       \J{$\tau_l$->$\tau_r$}
%       \subtypes
%       \J{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:($\tau_l$,$\tau_r$)]$\alpha_r$} 
%       \given M, \Delta
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
%   \item \TODO{$X \rightarrow Y$ is equivalent to $\forall x \in X .\ \exists y .\ (x,y) \in (X \times Y)$} 
%   \item \TODO{$X \rightarrow Y$ is equivalent to $\neg (\exists x \in X \land \nexists y \in Y)$} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Upper bound interpretation sound)
%   \label{thm:upper_bound_interpretation_sound}
%   \begin{mathpar}
%     \inferrule { 
%       M, \Delta, \Delta \entails \alpha \subtypes \Tau 
%     } {
%      \alpha \subtypes \J{\&$(\Tau)$} \given \left<M, \Delta\right>
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Lower bound interpretation sound)
%   \label{thm:lower_bound_interpretation_sound}
%   \begin{mathpar}
%     \inferrule { 
%       M, \Delta, \Delta \entails \Tau \subtypes \alpha
%       \\
%     } {
%      \J{|$(\Tau)$} \subtypes \alpha \given \left<M, \Delta\right>
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}


% \begin{theorem}(Universe Proof Typing worldly)
%   \label{thm:universe_proof_typing_worldly}
%   \begin{mathpar}
%     \inferrule { 
%       \tau_l \subtypes \tau_r \given Z 
%     } {
%       \exists M\ \Delta\ .\ \left<M, \Delta\right> \in Z
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Empty containment absurd)
%   \label{thm:empty_containment_absurd}
%   \begin{mathpar}
%     \inferrule { 
%       \left<M, \Delta\right> \in \epsilon 
%     } {
%       \bot
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}


% \begin{theorem}(Model typing implication independence)
%   \label{thm:model_typing_implication_independence}
%   \begin{mathpar}
%     \inferrule { 
%       \delta, \Gamma \satisfies e \hastype \J{$\tau_l$->$\tau_r$} 
%       \\
%       \delta \satisfies \tau_r
%     } {
%       \delta, \Gamma \satisfies \J{loop($e$)} \hastype \tau_r
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}


% % \begin{theorem}(Proof typing fix interpolation weakest pre-condition)
% %   \label{thm:fix_duality}
% %   \begin{mathpar}
% %     \inferrule { 
% %       \tau \subtypes \J{$\alpha_0$->$\alpha_1$->$\alpha_2$} \given Z_1
% %       \\\\
% %       \textbf{ftv}(\Gamma) \entails \alpha_0 \cdot Z_1 \cdot \J{$\alpha_1$->$\alpha_2$} \fallingdotseq \alpha_3 \circlearrowright \Tau_{rel}
% %     } {
% %       \J{ALL[$\alpha_4$]$\alpha_4$->EXI[$\alpha_5$.($\alpha_4$,$\alpha_5$)<:LFP[$\alpha_3$.|$(\Tau_{rel})$]]$\alpha_5$} 
% %       \subtypes
% %       \J{$\alpha_1$->$\alpha_2$}
% %       \given Z_1
% %     } 
% %   \end{mathpar}
% %   Proof: 
% %   \item \TODO{...} 
% %   \item $\square$
% % \end{theorem}

% \begin{theorem}(Proof subtyping decomposition)
%   \label{thm:proof_subtyping_decomposition}
%   \begin{mathpar}
%     \inferrule { 
%       \tau_l \subtypes \tau_r \given Z\ \left<M, \Delta\right>
%     } {
%       \tau_l \subtypes \tau_r \given \left<M, \Delta\right>
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}


% \begin{theorem}(Proof subtyping choice)
%   \label{thm:proof_subtyping_choice}
%   \begin{mathpar}
%     \inferrule { 
%       \tau_l \subtypes \tau_r \given Z 
%     } {
%       \exists M\ \Delta .\ \tau_l \subtypes \tau_r \given M, \Delta
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Model subtyping elimination)
%   \label{thm:model_subtyping_elimination}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \tau_l \subtypes \tau_r
%       \\
%       \delta, \Gamma \satisfies e \hastype  \tau_l  
%     } {
%       \delta, \Gamma \satisfies e \hastype \tau_r 
%     } 
%   \end{mathpar}
%   Proof: 
%   \item $\B{assume } 
%     \delta \satisfies \tau_l \subtypes \tau_r
%     \I
%     \delta, \Gamma \satisfies e \hastype  \tau_l  
%   $
%   \item \Z $\B{invert on } \delta \satisfies \tau_l \subtypes \tau_r$
%   \item \Z $\B{case } \forall e'\ \Gamma' .\ \delta, \Gamma' \satisfies e' \hastype  \tau_l  \implies \delta, \Gamma' \satisfies e' \hastype \tau_r$
%   \item \Z\Z $\delta, \Gamma \satisfies e \hastype  \tau_l  \implies \delta, \Gamma \satisfies e \hastype \tau_r$ by instantiation
%   \item \Z\Z $\delta, \Gamma \satisfies e \hastype \tau_r$ by application 
%   \item \Z $\delta, \Gamma \satisfies e \hastype \tau_r$ by inversion
%   \item $\square$ by implication
% \end{theorem}


% \begin{theorem}(Model typing record elimination)
%   \label{thm:model_subtyping_record_elimination}
%   \begin{mathpar}
%     \inferrule { 
%       \delta, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
%     } {
%       \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
%     } 
%   \end{mathpar}
%   Proof: 
%   \item $\B{assume } 
%     \delta, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
%   $ 
%     \item \Z $\B{induct on } 
%       \delta, \Gamma \satisfies e \hastype \J{$l$->$\tau$}
%     $ 
%     \item \Z $\B{case }
%       e = G
%       \I
%       \J{?$l$=>$v$} \in G
%       \I
%       \delta, \Gamma \satisfies v \hastype \tau
%       \I
%       \forall v' .\ \J{?$l$=>$v'$} \in G \implies v' = v 
%     $ 
%     \item \Z $\B{wrt }
%       G\ v 
%     $
  
%       \item \Z\Z $
%         \delta, \Gamma \satisfies G \hastype \J{$l$->$\tau$}
%       $ by substitution

%       \item \Z\Z $
%         \J{$G$.$l$} \rightsquigarrow v
%       $ by definition 

%       \item \Z\Z $
%         \B{let } \sigma \B{ s.t. } \delta, \Gamma \satisfies \sigma 
%       $ by theorem \ref{...} 
%       \item \Z\Z $
%         \J{$G$.$l$}[\sigma] \rightsquigarrow v
%       $ by definition 
%       \item \Z\Z $
%         v = v[\sigma \cup \epsilon] 
%       $ by definition 
%       \item \Z\Z $
%         \J{$G$.$l$}[\sigma] \rightsquigarrow v[\sigma \cup \epsilon] 
%       $ by substitution 
%       \item \Z\Z $
%         \delta, \epsilon \satisfies \epsilon 
%       $ by definition 

%       \item \Z\Z $
%         \delta, \Gamma \cup \epsilon \satisfies v \hastype \tau
%       $ by definition 
%       \item \Z\Z $
%         \delta, \Gamma \satisfies \J{$G$.$l$} \hastype \tau 
%       $ by definition 
%       \item \Z\Z $
%         \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
%       $ by substitution


%     \item \Z $\B{case }
%       \delta, \sigma \satisfies \Gamma
%       \I
%       e[\sigma] \rightsquigarrow e'[\sigma \cup \sigma']
%       \I
%       \delta, \sigma' \satisfies \Gamma'
%       \I
%       \delta, \Gamma \cup \Gamma' \satisfies e' \hastype \J{$l$->$\tau$}
%     $
%     \item \Z $\B{hypo }
%       \delta, \Gamma \cup \Gamma' \satisfies e' \hastype \J{$l$->$\tau$}
%       \implies
%       \delta, \Gamma \cup \Gamma' \satisfies \J{$e'$.$l$} \hastype \tau
%     $
%     \item \Z $\B{wrt }
%       \sigma\ e'\ \sigma'\ \Gamma'
%     $
%       \item \Z\Z $
%         \delta, \Gamma \cup \Gamma' \satisfies \J{$e'$.$l$} \hastype \tau
%       $ by application
%       \item \Z\Z $
%         \J{$e[\sigma]$.$l$} \rightsquigarrow \J{$e'[\sigma \cup \sigma']$.$l$}
%       $ by definition 
%       \item \Z\Z $
%         \J{$e[\sigma]$.$l$} = \J{$e$.$l$}[\sigma]
%       $ by definition 
%       \item \Z\Z $
%         \J{$e'[\sigma \cup \sigma']$.$l$} = \J{$e'$.$l$}[\sigma \cup \sigma']
%       $ by definition 
%       \item \Z\Z $
%         \J{$e$.$l$}[\sigma] \rightsquigarrow \J{$e'$.$l$}[\sigma \cup \sigma']
%       $ by substitution 
%       \item \Z\Z $
%         \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
%       $ by definition 

%     \item \Z $
%       \delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau 
%     $ by induction 
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Proof subtyping consistency)
%   \label{thm:proof_subtypig_substance}
%   \begin{mathpar}
%     \inferrule { 
%       \tau_l \subtypes \tau_r \given M, \Delta 
%     } {
%       \exists \delta .\ 
%       \delta \satisfies \Delta
%     } 
%   \end{mathpar}
% \end{theorem}

% \begin{theorem}(Proof subtyping soundness)
%   \label{thm:proof_subtyping_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \tau_l \subtypes \tau_r \given M, \Delta 
%     } {
%       \exists \delta .\ 
%       \delta \satisfies \tau_l \subtypes \tau_r
%     } 
%   \end{mathpar}
% \end{theorem}


% \begin{theorem}(Proof subtyping weak soundness)
%   \label{thm:proof_subtyping_weak_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \tau_l \subtypes \tau_r \given M, \Delta 
%     } {
%       \forall \delta .\ 
%       \delta \satisfies \Delta
%       \implies
%       \delta \satisfies \tau_l \subtypes \tau_r
%     } 
%   \end{mathpar}

% \TODO{closed variabless simply remove variables from soundness consideration}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % (EXI[X . 1 <: X, X <: 3] X) <: 2  -| 1 <: X, X <: 3, ..., X <: 2  
% % FAILS, not considered for soundness
% % (EXI[X . 1 <: X, X <: 2] X) <: 2  -| 1 <: X, X <: 2, ..., X <: 2  
% % PASSES, is considered for soundness
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % 2 <: (EXI[X . 1 <: X, X <: 3] X)  -| 2 <: X, ..., 1 <: X, X <: 3 
% % PASSES, is considered for soundness
% % 2 <: (EXI[X . X <: 1 ] X)  -| 2 <: X, ..., X <: 1
% % FAILS, not considered for soundness
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Proof: 
%   \item \TODO{think about how to handle the mutually recursive definition} 
%   \item $\B{assume } 
%     \tau_l \subtypes \tau_r \given M, \Delta 
%   $
%     \item \Z $\B{induct on } \tau_l \subtypes \tau_r \given M, \Delta$

%     \item \Z $\B{case } \tau_l = \tau \I \tau_r = \tau$
%     \item \Z $\B{wrt } \tau $
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \tau \subtypes \tau$
%         by theorem \ref{thm:model_typing_reflexivity}
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization 

%     \item \Z $\B{case } \tau_l = \J{BOT}$
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \J{BOT} \subtypes \tau_r$ by definition
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization 

%     \item \Z $\B{case } \tau_r = \J{TOP}$
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \J{TOP}$ by definition
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization 

%     \item \Z $\B{case } 
%       \tau_r = \J{$l$->($\tau_{rl}$\&$\tau_{rr}$)}
%       \I
%       \tau_l
%       \subtypes
%       \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
%       \given M, \Delta
%     $
%     \item \Z $\B{hypo }
%       \forall \delta .\ 
%       \delta \satisfies \Delta
%       \implies
%       \delta \satisfies \tau_l \subtypes \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
%     $ 
%     \item \Z $\B{wrt } l\ \tau_{rl}\ \tau_{rr}$ 
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
%         by application
%         \item \Z\Z\Z $\B{for } e\ \Gamma \B{ assume } \delta, \Gamma \satisfies e \hastype \tau_l$ 
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
%           by theorem \ref{thm:model_typing_subsumption} 
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{$l$->$\tau_{rl}$}$ by theorem \ref{thm:model_typing_intersection_elimination}
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{$l$->$\tau_{rr}$}$ by theorem \ref{thm:model_typing_intersection_elimination}
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau_{rl}$ by theorem \ref{thm:model_subtyping_record_elimination}
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies \J{$e$.$l$} \hastype \tau_{rr}$ by theorem \ref{thm:model_subtyping_record_elimination}
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies \J{$e$.$l$} \hastype \J{$\tau_{rl}$\&$\tau_{rr}$}$ by definition
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \J{$l$->($\tau_{rl}$\&$\tau_{rr}$)}$ by theorem \ref{thm:model_typing_record_introduction} 
%           \item \Z\Z\Z\Z $\delta, \Gamma \satisfies e \hastype \tau_r$ by substitution 
%         \item \Z\Z\Z $\forall e\ \Gamma .\ \delta, \Gamma \satisfies e \hastype \tau_l \implies 
%           \delta, \Gamma \satisfies e \hastype \tau_r
%         $ by implication and generalization
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$
%         by definition 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization 


%     \item \Z $\B{case } 
%       \tau_l = \J{$\tau_{ll}$|$\tau_{lr}$}
%       \I
%       M = M_1
%       \I
%       \Delta = \Delta_1
%     $
%     \item \Z $\contin
%       \tau_{ll} \subtypes \tau_r
%       \given M_0, \Delta_0
%       \I
%       M_0 \preceq M_1
%       \I
%       \Delta_0 \preceq \Delta_1
%       \I
%       \tau_{lr} \subtypes \tau_r
%       \given M_1, \Delta_1
%     $

%     \item \Z $\B{hypo } 
%       \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies \tau_{ll} \subtypes \tau_r
%       \I
%       \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies \tau_{lr} \subtypes \tau_r
%     $
%     \item \Z $\B{wrt } \tau_{ll}\ \tau_{lr}$

%       \item \Z\Z $\B{for } \delta \B{ assume } M, \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \Delta_1$ by substitution 
%         \item \Z\Z\Z $\delta \satisfies \tau_{lr} \subtypes \tau_r$ by application 
%         \item \Z\Z\Z $\delta \satisfies \Delta_0$ by theorem \ref{...} \TODO{...} 
%         \item \Z\Z\Z $\delta \satisfies \tau_{ll} \subtypes \tau_r$ by application 
%         \item \Z\Z\Z $\delta \satisfies \J{$\tau_{ll}$|$\tau_{lr}$} \subtypes \tau_r$ 
%         by definition
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ 
%         by substitution 

%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization

%     \item \Z $\B{case } 
%       \tau_r = \J{$\tau_{rl}$\&$\tau_{rr}$}
%       \I
%       M = M_1
%       \I
%       \Delta = \Delta_1
%     $
%     \item \Z $\contin 
%       \tau_l \subtypes \tau_{rl} \given M_0, \Delta_0
%       \I
%       M_0 \preceq M_1
%       \I
%       \Delta_0 \preceq \Delta_1
%       \I
%       \tau_l \subtypes \tau_{rr} \given M_1, \Delta_1
%     $
%     \item \Z $\B{hypo } 
%       \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies \tau_l \subtypes \tau_{rl} 
%       \I
%       \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies \tau_l \subtypes \tau_{rr} 
%     $
%     \item \Z $\B{wrt } $
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \Delta_1 $ by substitution
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_{rr}$ by instantiation and application 
%         \item \Z\Z\Z $\delta \satisfies \Delta_0 $ by theorem \ref{...} \TODO{...} 
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_{rl}$ by instantiation and application 
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \J{$\tau_{rl}$\&$\tau_{rr}$}$ by definition 
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by substitution
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization


%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_l \subtypes
%     %   \J{($\tau_{ra}$->$\tau_{rc}$)\&($\tau_{rb}$->$\tau_{rc}$)}
%     %   \given M, \Delta
%     % } {
%     %   \tau_l \subtypes 
%     %   \J{$\tau_{ra}$|$\tau_{rb}$->$\tau_{rc}$}
%     %   \given M, \Delta
%     % }
%       \item \Z\Z \TODO{...} 

%     %%% TEMPLATE
%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_l \subtypes
%     %   \J{($\tau_{ra}$->$\tau_{rb}$)\&($\tau_{ra}$->$\tau_{rc}$)}
%     %   \given M, \Delta
%     % } {
%     %   \tau_l \subtypes \J{$\tau_{ra}$->$\tau_{rb}$\&$\tau_{rc}$}
%     %   \given M, \Delta
%     % }
%       \item \Z\Z \TODO{...} 

%     %%% TEMPLATE
%     \item \Z $\B{case } 
%       \tau_l = \J{EXI[$\Alpha$ $Q$]$\tau_b$}
%       \I
%       M = M_1
%       \I
%       \Delta = \Delta_1
%     $
%     \item \Z $\contin
%       Q \given M_0, \Delta_0
%       \I
%       A \notfree \tau_r
%       \I
%       M_0 \cup \Alpha \preceq M_1
%       \I
%       \Delta_0 \preceq \Delta_1
%       \I
%       \tau_b \subtypes \tau_r
%       \given M_1, \Delta_1
%     $
%     \item \Z $\B{hypo } 
%       \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies M_1, \tau_b \subtypes \tau_r 
%     $
%     \item \Z $\B{mutu } 
%       \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies Q 
%     $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
%     \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \Delta_1 $ by substitution
%         \item \Z\Z\Z $\delta \satisfies \tau_b \subtypes \tau_r$ by application
%         \item \Z\Z\Z $\delta \satisfies \Delta_0 $ by theorem \ref{thm:model_subtyping_sequence_prefix}
%         \item \Z\Z\Z $\delta \satisfies Q$ by application
%         \item \Z\Z\Z $\B{for } e \B{ assume } \delta \satisfies e \hastype \tau_l$ 
%           \item \Z\Z\Z\Z $\delta \satisfies e \hastype \J{EXI[$\Alpha$ $Q$]$\tau_b$}$ by substitution
%           \item \Z\Z\Z\Z $\delta \satisfies e \hastype \tau_r$ by theorem \ref{thm:model_typing_existential_elimination} 
%         \item \Z\Z\Z $\forall e .\ \delta \satisfies e \hastype \tau_l 
%           \implies \delta \satisfies e \hastype \tau_r
%         $ 
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by definition 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization

%     \item \Z $\B{case } 
%       \tau_r = \J{ALL[$\Alpha$ $Q$]$\tau_b$}
%       \I
%       M = M_1
%       \I
%       \Delta = \Delta_1
%     $
%     \item \Z $\contin
%       Q \given M_0, \Delta_0
%       \I
%       A \notfree \tau_l
%       \I
%       M_0 \cup \Alpha \preceq M_1
%       \I
%       \Delta_0 \preceq \Delta_1
%       \I
%       \tau_l \subtypes \tau_b
%       \given M_1, \Delta_1
%     $
%     \item \Z $\B{hypo } 
%       \forall \delta .\ \delta \satisfies \Delta_1 \implies \delta \satisfies \tau_l \subtypes \tau_b 
%     $
%     \item \Z $\B{mutu } 
%       \forall \delta .\ \delta \satisfies \Delta_0 \implies \delta \satisfies Q 
%     $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
%     \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \Delta_1$ by substitution 
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_b$ by application 
%         \item \Z\Z\Z $\delta \satisfies \Delta_0$ by theorem \ref{thm:model_subtyping_sequence_prefix} 
%         \item \Z\Z\Z $\delta \satisfies Q$ by application 
%         \item \Z\Z\Z $\B{for } e \B{ assume } \delta \satisfies e \hastype \tau_l$ 
%           \item \Z\Z\Z\Z $\delta \satisfies e \hastype \J{ALL[$\Alpha$ $Q$]$\tau_b$}$ by theorem \ref{thm:model_typing_universal_introduction} 
%           \item \Z\Z\Z\Z $\delta \satisfies e \hastype \tau_r$ by substitution 
%         \item \Z\Z\Z $\forall e .\ \delta \satisfies e \hastype \tau_l 
%           \implies \delta \satisfies e \hastype \tau_r
%         $ 
%         \item \Z\Z\Z $\delta \satisfies \tau_l \subtypes \tau_r$ by definition 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization
%       \item \Z\Z \TODO{...} 

% % e :  ALL[a b . 3 <: a ] (a,b) \implies e : (a,b)
%     \item \Z $\B{case } 
%       \tau_l = \alpha
%       \I
%       M = M_1
%       \I
%       \Delta = \Delta_1\ \alpha <: \tau_r
%     $
%     \item \Z $\contin
%       \alpha \notin M_0
%       \I
%       M_0, \Delta_0 \entails \Delta_m <:^\sharp \alpha \slash \tau_r
%       \I
%       M_0, \Delta_0 \entails \Tau <:^\dagger \alpha
%       \I
%       M_0 \preceq M_1
%     $
%     \item \Z $\contin
%       \Delta_0 \cup \Delta_m \preceq \Delta_1
%       \I
%       \J{|$(\Tau)$} <: \tau_r \given M_1, \Delta_1
%     $
%     \item \Z $\B{hypo } \forall \delta .\ \delta \satisfies \Delta_1 \implies
%       \delta \satisfies \J{|$(\Tau)$} <: \tau_r
%     $
%     \item \Z $\B{wrt } \alpha\ M_1\ \Delta_1\ M_0\ \Delta_0\ \Delta_m\ \Tau$
%       \item \Z\Z $\B{for } \delta \B{ assume } \delta \satisfies \Delta$
%         \item \Z\Z\Z $\delta \satisfies \Delta_1 \J{($\alpha$<:$\tau_r$)}$ by substitution
%         \item \Z\Z\Z $\delta \satisfies \alpha <: \tau_r$ by theorem \ref{thm:model_subtyping_sequence_last} 
%         \item \Z\Z\Z $\delta \satisfies \tau_l <: \tau_r$ by substitution 
%       \item \Z\Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%       by implication and generalization 
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \alpha \notin M_0
%     %   \\
%     %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot M
%     %   \\
%     %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot \Delta_{skol}
%     %   \\
%     %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Tau 
%     %   \\
%     %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Delta_{rel}
%     %   \\
%     %   M_0 \preceq M_1
%     %   \\
%     %   \Delta_0 \preceq \Delta_1
%     %   \\
%     %   \widebar{\J{.$\tau_0[\alpha\slash\tau_l]$<:$\tau_1$}}^{\tau_0<:\tau_1 \in \Delta_{rel}} \cup \widebar{\J{.$\tau_l$<:$\tau$}}^{\tau \in \Tau}
%     %   \given M_1, \Delta_1
%     % } {
%     %   \tau_l \subtypes \alpha
%     %   \given M_1, \Delta_1
%     %   \cup \widebar{\tau_l<:z}^{z \in M}
%     %   \cup \widebar{\tau[\alpha\slash\tau_l]<:z}^{\tau<:z \in \Delta_{skol}} \ \tau_l<:\alpha 
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \alpha \in M_0
%     %   \\
%     %   \alpha <: \tau \in (\Delta_0 \cup \text{factor}(\Delta_0, \alpha))
%     %   \\\\
%     %   M_0 \preceq M_1
%     %   \\
%     %   \Delta_0 \preceq \Delta_1
%     %   \\
%     %   \tau \subtypes \tau_r
%     %   \given M_1, \Delta_1
%     % } {
%     %   \alpha \subtypes \tau_r
%     %   \given M_1, \Delta_1
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \alpha \in M_0
%     %   \\
%     %   \tau <: \alpha \in \Delta_0
%     %   \\\\
%     %   M_0 \preceq M_1
%     %   \\
%     %   \Delta_0 \preceq \Delta_1
%     %   \\
%     %   \tau_l \subtypes \tau
%     %   \given M_1, \Delta_1
%     % } {
%     %   \tau_l \subtypes \alpha
%     %   \given M_1, \Delta_1
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_l \subtypes \tau_r \given M_0, \Delta_0
%     %   \\\\
%     %   M_0 \preceq M_1
%     %   \\
%     %   \Delta_0 \preceq \Delta_1
%     %   \\
%     %   Q
%     %   \given M_1, \Delta_1
%     % } {
%     %   \J{ALL[$\Alpha$ $Q$]$\tau_l$}
%     %   \subtypes 
%     %   \tau_r
%     %   \given M_1, \Delta_1 
%     % }

%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_l \subtypes \tau_r
%     %   \given M_0, \Delta_0
%     %   \\\\
%     %   M_0 \preceq M_1
%     %   \\
%     %   \Delta_0 \preceq \Delta_1
%     %   \\
%     %   Q \given M_1, \Delta_1
%     % } {
%     %   \tau_l
%     %   \subtypes 
%     %   \J{EXI[$\Alpha$ $Q$]$\tau_r$}
%     %   \given M_1, \Delta_1
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_{ll} \subtypes \tau_r
%     %   \given M, \Delta
%     % } {
%     %   \J{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
%     %   \given M, \Delta
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_{lr} \subtypes \tau_r
%     %   \given M, \Delta
%     % } {
%     %   \J{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
%     %   \given M, \Delta
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_l \subtypes \tau_{rl}
%     %   \given M, \Delta
%     % } {
%     %   \tau_l \subtypes \J{$\tau_{rl}$|$\tau_{rr}$}
%     %   \given M, \Delta
%     % }

%       \item \Z\Z \TODO{...} 

%     \item \Z $\B{case } $
%     \item \Z $\B{hypo } $
%     \item \Z $\B{wrt } $
%     % \inferrule {
%     %   \tau_l \subtypes \tau_{rr}
%     %   \given M, \Delta
%     % } {
%     %   \tau_l \subtypes \J{$\tau_{rl}$|$\tau_{rr}$}
%     %   \given M, \Delta
%     % }
%       \item \Z\Z \TODO{...} 

%     \item \Z $\forall \delta .\ \delta \satisfies \Delta \implies \delta \satisfies \tau_l \subtypes \tau_r$ 
%     by induction
%   \item $\square$ by implication
% \end{theorem}

% \begin{theorem} Model typing existential elimination 
%   \label{thm:model_typing_existential_elimination}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies e \hastype \J{EXI[$\Alpha$ $Q$]$\tau_l$}
%       \\
%       \delta \satisfies Q
%       \\
%       \delta \satisfies \tau_l \subtypes \tau_r
%       \\
%       \Alpha \notfree \tau_r
%     } {
%       \delta \satisfies e \hastype \tau_r
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{depends on Proof Subtyping. can we abstract away Proof Subtyping?}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % TODO: 
% % depends on Proof Subtyping 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % ... |= 2 : (EXI[X . 1 <: X, X <: 3] X)
% % X/1 |= 1 <: X, X <: 3
% % -------------------------
% % X/1 |= 2 : 1 (FAIL) 
% % -------------------------
% % X/1 |= 2 : 4  (PASS)
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % X <: 4  -| X, 1 <: X, X <: 3

% \end{theorem}

% \begin{theorem} Model typing universal introduction 
%   \label{thm:model_typing_universal_introduction}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies e \hastype \tau_l
%       \\
%       \delta \satisfies Q
%       \\
%       \delta \satisfies \tau_l \subtypes \tau_r
%       \\
%       \Alpha \notfree \tau_l
%     } {
%       \delta \satisfies e \hastype \J{ALL[$\Alpha$ $Q$]$\tau_r$}
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{depends on Proof Subtyping. can we abstract away Proof Subtyping?}
% \end{theorem}





% \begin{theorem} Model subtyping sequence last 
%   \label{thm:model_subtyping_sequence_last}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \Delta\ \J{($\tau_l$<:$\tau_r$)}
%     } {
%       \delta \satisfies \tau_l \subtypes \tau_r 
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model subtyping sequence reduction 
%   \label{thm:model_subtyping_sequence_reduction}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \Delta\ \delta
%     } {
%       \delta \satisfies \Delta
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model subtyping sequence prefix  
%   \label{thm:model_subtyping_sequence_prefix}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \Delta'
%       \\
%       \Delta \preceq \Delta'
%     } {
%       \delta \satisfies \Delta
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model subtyping sequence uncat 
%   \label{thm:model_subtyping_sequence_uncat}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \Delta \cup \Delta'
%     } {
%       \delta \satisfies \Delta
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} concatenation prefix 
%   \label{thm:concatenation prefix}
%   \begin{mathpar}
%     \inferrule { 
%     } {
%       \Delta \preceq \Delta \cup \Delta'
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}



% \begin{theorem} Model subtyping unsub left 
%   \label{thm:Modle_subtyping_unsub_left}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \tau_l \subtypes \tau_r
%       \\
%       \alpha\slash\tau_l \in \delta
%     } {
%       \delta \satisfies \alpha \subtypes \tau_r
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model subtyping unsub right 
%   \label{thm:Modle_subtyping_unsub_right}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \tau_l \subtypes \tau_r
%       \\
%       \alpha\slash\tau_r \in \delta
%     } {
%       \delta \satisfies \tau_l \subtypes \alpha
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model subtyping something 
%   \label{thm:Modle_subtyping_something}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \Delta 
%       \\
%       M, \Delta \entails \Tau \subtypes^\sharp \alpha  
%     } {
%       \alpha\slash\J{|$(\Tau)$} \in \delta
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}


% \begin{theorem} Model typing record introduction 
%   \label{thm:model_typing_record_introduction}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \J{$e$.$l$} \hastype \tau
%     } {
%       \delta \satisfies e \hastype \J{$l$->$\tau$}
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model typing implication introduction 
%   \label{thm:model_typing_implication_introduction}
%   \TODO{this is really messed up}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies \J{$e_0$($e_1$)} \hastype \tau_r
%       \\
%       \delta \satisfies e_1 \hastype \tau_l
%       \\
%       \forall \tau .\ \delta \satisfies e_1 \hastype \tau \implies \tau_l \subtypes \tau
%     } {
%       \delta \satisfies e_0 \hastype \J{$\tau_l$->$\tau_r$}
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}

% \begin{theorem} Model typing intersection elimination 
%   \label{thm:model_typing_intersection_elimination}
%   \begin{mathpar}
%     \inferrule { 
%       \delta \satisfies e \hastype \tau_l \& \tau_r
%     } {
%       \delta \satisfies e \hastype \tau_l 
%       \land
%       \delta \satisfies e \hastype \tau_r
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}



% \begin{theorem} Model typing reflexivity
%   \label{thm:model_typing_reflexivity}
%   \begin{mathpar}
%     \inferrule { 
%     } {
%       \delta \satisfies \tau \subtypes \tau
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{for } e\ \Gamma \B{ assume } \delta, \Gamma \satisfies e \hastype \tau$
%     \item \Z $\delta, \Gamma \satisfies e \hastype \tau$ by identity
%   \item $\forall e\ \Gamma .\ \delta, \Gamma \satisfies e \hastype \tau \implies \delta, \Gamma \satisfies e \hastype \tau$
%   by implication and generalization
%   \item $\square$ by definition
% \end{theorem}


% \begin{theorem}(Model typing subsumption)
%   \label{thm:model_typing_subsumption}
%   \begin{mathpar}
%     \inferrule { 
%       \delta, \Gamma \satisfies e \hastype \tau_l 
%       \\
%       \delta, \Gamma \satisfies \tau_l <: \tau_r
%     } {
%       \delta, \Gamma \satisfies e \hastype \tau_r
%     } 
%   \end{mathpar}
%   Proof: 
%   \item $\B{assume } \delta, \Gamma \satisfies e \hastype \tau_l 
%   \I \delta, \Gamma \satisfies \tau_l <: \tau_r
%   $
%     \item \Z $\B{invert on}\ \delta, \Gamma \satisfies \tau_l <: \tau_r$
%     \item \Z $\B{case}\ \forall e' .\ \delta, \Gamma \satisfies e' : \tau_l \implies \delta, \Gamma \satisfies e' : \tau_r$
%       \item \Z\Z $\forall e' .\ \delta, \Gamma \satisfies e' : \tau_l \implies \delta, \Gamma \satisfies e' : \tau_r$ by identity
%     \item \Z $\forall e' .\ \delta, \Gamma \satisfies e' : \tau_l \implies \delta, \Gamma \satisfies e' : \tau_r$ by inversion
%     \item \Z $\delta, \Gamma \satisfies e : \tau_l \implies \delta, \Gamma \satisfies e : \tau_r$ by instantiation 
%     \item \Z $\delta, \Gamma \satisfies e : \tau_r$ by application
%   \item $\square$ by implication 
% \end{theorem}

% \begin{theorem}(Model typing implication elimination)
%   \label{thm:model_typing_implication_elimination}
%   \begin{mathpar}
%     \inferrule { 
%       \delta, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r
%       \\
%       \delta, \Gamma \satisfies e_1 \hastype \tau_l
%     } {
%       \delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r
%     } 
%   \end{mathpar}

%   \item $\B{assume }
%     \delta, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r
%     \I 
%     \delta, \Gamma \satisfies e_1 \hastype \tau_l
%   $ 

%     \item \Z $\B{let } \sigma \B{ s.t. } \delta, \sigma \satisfies \Gamma$ by theorem \ref{...}
%     \item \Z $\B{induct on } \delta, \Gamma \satisfies e_0 \hastype \tau_l \J{->} \tau_r$

%     \item \Z $\B{case }$ \TODO{...}

%     % \inferrule { 
%     %   \delta, \Gamma \cup \Gamma' \satisfies p \pattype \tau_p
%     %   \\
%     %   \delta, \Gamma \cup \Gamma'  \satisfies e \hastype \tau_r
%     %   \\\\
%     %   \forall e .\ 
%     %     \delta, \Gamma \satisfies e \hastype \tau_l 
%     %     \implies
%     %     \delta, \Gamma \satisfies e \hastype \tau_p 
%     %     \land
%     %     (\forall \tau_n\ \tau .\ \delta, \Gamma \satisfies F \hastype \J{$\tau_n$->$\tau$} \implies \neg (\delta, \Gamma \satisfies e \hastype \tau_n))
%     % } {
%     %   \delta, \Gamma \satisfies \J{$F$*$p$=>$e$} \hastype \J{$\tau_l$->$\tau_r$}
%     % }

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%     % \inferrule { 
%     %   \delta, \Gamma \satisfies F \hastype \J{$\tau_l$->$\tau_r$}
%     % } {
%     %   \delta, \Gamma \satisfies \J{$F$*$p$=>$e$} \hastype \J{$\tau_l$->$\tau_r$}
%     % } 
%     \item \Z $\B{case }
%       e_0 = \J{$F$?$p$=>$e_2$}
%       \I
%       \delta, \Gamma \satisfies F \hastype \J{$\tau_l$->$\tau_r$}
%     $ 
%     \item \Z $\B{hypo }
%       \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
%     $
%     \item \Z $\B{wrt }
%       F\ p\ e_2 
%     $
%       \item \Z\Z $\VDash \J{$F$($e_1$)}[\sigma] $
%       by theorem \ref{thm:model_typing_soundness}
%       \item \Z\Z $\B{invert on } \VDash \J{$F$($e_1$)}[\sigma]$
%       \item \Z\Z $\B{case } \J{$F$($e_1$)}[\sigma] = v$
%       \item \Z\Z $\B{wrt } v$
%         \item \Z\Z\Z $\J{$F$($e_1$)}[\sigma] \neq v$ by definition 
%         \item \Z\Z\Z $\bot$ by application
%       \item \Z\Z $\B{case } 
%         (\J{$F$($e_1$)})[\sigma] \rightsquigarrow e_3
%         \I
%         \delta, \Gamma \satisfies e_3 \hastype \tau_r
%       $
%       \item \Z\Z $\B{wrt } e_3$
%         \item \Z\Z\Z $(\J{$F$($e_1$)})[\sigma] = \J{$F[\sigma]$($e_1[\sigma]$)}$ by definition
%         \item \Z\Z\Z $\J{$F[\sigma]$($e_1[\sigma]$)} \rightsquigarrow e_3$ by substitution 

%         \item \Z\Z\Z $\B{let } F' \B{ s.t. } F[\sigma] = F'$ by theorem \ref{...} \TODO{...}
%         \item \Z\Z\Z $\B{let } e_1' \B{ s.t. } e_1[\sigma] = e_1'$ by theorem \ref{...} \TODO{...}

%         \item \Z\Z\Z $\text{FV}(e_2[\sigma\backslash\text{FV}(p)]) \subseteq \text{FV}(p)$ 
%         by theorem \ref{...} \TODO{...}

%         \item \Z\Z\Z $\J{$F'$($e_1'$)} \rightsquigarrow e_3$ by substitution 
%         \item \Z\Z\Z $\J{($F'$?$p$=>$e_2[\sigma\backslash\text{FV}(p)]$)($e_1'$)} \rightsquigarrow e_3$ by definition 
%         \item \Z\Z\Z $(\J{$F[\sigma]$?$p$=>$e_2[\sigma\backslash\text{FV}(p)]$)($e_1[\sigma]$)} \rightsquigarrow e_3$ by substitution 

%         \item \Z\Z\Z $(\J{($F$?$p$=>$e_2$)($e_1$)})[\sigma] = \J{($F[\sigma]$?$p$=>$e[\sigma\backslash\text{FV}(p)]$)($e_1[\sigma]$)}
%         $ by definition
%         \item \Z\Z\Z $(\J{($F$?$p$=>$e_2$)($e_1$)})[\sigma] \rightsquigarrow e_3$ by substitution 

%         \item \Z\Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
%       \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
%     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     %%% OLD 
%     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     % \item \Z $\B{case }
%     %   \delta, \Gamma \cup \Gamma' \satisfies p \hastype \tau_l
%     %   \I
%     %   \delta, \Gamma \cup \Gamma'  \satisfies e \hastype \tau_r
%     % $
%     % \item \Z $ 
%     %   \contin
%     %   F = \epsilon \lor \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r
%     %   \I
%     %   e_0 = \J{($F$?$p$=>$e$)} 
%     % $
%     % \item \Z $
%     %   \B{hypo} \  \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r \implies \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
%     % $
%     % \item \Z $
%     %   \B{wrt} \ F \ p \ e \ \Gamma' \  
%     % $
%     %   \item \Z\Z $F = \epsilon \lor \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r$ by application
%     %   \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r$ by substitution 
%     %   \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by theorem \ref{thm:model_typing_reduced_implication_elimination}
%     %   \item \Z\Z $\delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ by substitution 
%     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%     \item \Z $\B{case }
%       \delta, \sigma \satisfies \Gamma
%       \I
%       e_0[\sigma] \rightsquigarrow e_0'
%       \I
%       \delta, \Gamma \satisfies e_0' \hastype \tau_l \J{->} \tau_r
%     $
%     \item \Z $\B{hypo}\ 
%       \delta, \Gamma \satisfies e_0' \hastype \tau_l \J{->} \tau_r
%       \implies
%       \delta, \Gamma \satisfies \J{$e_0'$($e_1$)} \hastype \tau_r
%     $
%     \item \Z $ 
%     \B{wrt}\ \sigma\ e_0' 
%     $
%       \item \Z\Z $\delta, \Gamma \satisfies e_0'\J{(}e_1\J{)} \hastype \tau_r$ by application 
%       \item \Z\Z $e_0[\sigma]\J{(}e_1\J{)} \rightsquigarrow e_0'\J{(}e_1\J{)}$
%       \item \Z\Z ($e_0\J{(}e_1\J{)})[\sigma] \rightsquigarrow e_0'\J{(}e_1\J{)}$
%       \item \Z\Z $\delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ 

%     \item \Z $\delta, \Gamma \satisfies e_0\J{(}e_1\J{)} \hastype \tau_r$ by induction
%   \item $\square$
% \end{theorem}

% \begin{theorem}\ Model typing reduced implication elimination  

%   \label{thm:model_typing_reduced_implication_elimination}
%   \begin{mathpar}
%     \inferrule {
%       \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r
%       \\
%       \delta, \Gamma \satisfies e_1 \hastype \tau_l
%       \\
%       F = \epsilon \lor \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
%     } {
%       \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r
%     } 
%   \end{mathpar}

%   \item $\B{assume } \VDash e_1[\sigma]$


%     \item \Z $\B{let } \sigma \B{ s.t. } \delta, \sigma \satisfies \Gamma $ by theorem \ref{thm:model_typing_assignability} 
%     \item \Z $\VDash e_1[\sigma]$ by theorem \ref{thm:model_typing_soundness}
%     \item \Z $\B{induct on } \VDash e_1[\sigma]$

%     \item \Z $\B{case } e_1[\sigma] = v_1 $
%     \item \Z $\B{wrt } v_1$  
%       \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by theorem \ref{thm:model_typing_fully_reduced_implication_elimination}

%     \item \Z $\B{case}\ e_1[\sigma] \rightsquigarrow e_1' \I \VDash e_1'$
%     \item \Z $\B{hypo}\ \VDash e_1' \implies \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$
%     \item \Z $\B{wrt}\ e_1' $

%       \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$ by application
%       \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} \rightsquigarrow \J{($F$?$p$=>$e$)$[\sigma]$($e_1'$)}$ by definition 
%       \item \Z\Z $\forall x .\ x \notin \B{FV}(e_1')$ by theorem \ref{thm:reduction_closed} 
%       \item \Z\Z $e_1' = e_1'[\sigma]$ by by theorem \ref{thm:closed_substitution} 
%       \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} \rightsquigarrow \J{($F$?$p$=>$e$)$[\sigma]$($e_1'[\sigma]$)}$ by substitution 
%       \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow (\J{($F$?$p$=>$e$)($e_1'$)})[\sigma]$ by definition 
%       \item \Z\Z $\sigma \cup \epsilon = \sigma$ by definition 
%       \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow (\J{($F$?$p$=>$e$)($e_1'$)})[\sigma \cup \epsilon]$ by substitution 
%       \item \Z\Z $\Gamma \cup \epsilon = \Gamma$ by definition
%       \item \Z\Z $\delta, \epsilon \satisfies \epsilon$ by definition
%       \item \Z\Z $\delta, \Gamma \cup \epsilon \satisfies \J{($F$?$p$=>$e$)($e_1'$)}$ by substitution 
%       \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by definition
%     \item \Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)}\J{(}e_1\J{)} \hastype \tau_r$ by induction
%   \item $\square$ by implication 
% \end{theorem}

% \begin{theorem}\ Model typing fully reduced implication elimination 
%   \label{thm:model_typing_fully_reduced_implication_elimination}
%   \begin{mathpar}
%     \inferrule {
%       \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)} \hastype \tau_l \J{->} \tau_r
%       \\
%       F = \epsilon \lor \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r
%       \\
%       \delta \satisfies e_1 \hastype \tau_l
%       \\
%       \delta, \sigma \satisfies \Gamma 
%       \\
%       e_1[\sigma] = v_1
%       \\
%     } {
%       \delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{assume}\ F = \epsilon \lor \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r$
%     \TODO{add more assumptions}
%     \item \Z $\delta \satisfies e_1[\sigma] \hastype \tau_l$ by theorem \ref{thm:model_typing_valuation} 
%     \item \Z $\delta \satisfies v_1 \hastype \tau_l$ by substitution 
%     \item \Z $\B{invert on}\ F = \epsilon \lor \delta, \Gamma \satisfies F \hastype \tau_l \J{->} \tau_r$
%     \item \Z $\B{case } F = \epsilon$ 
%       \item \Z\Z $\delta, \Gamma \satisfies \J{$F$?$p$=>$e$} \hastype \tau_l \J{->} \tau_r$ by theorem \ref{thm:model_typing_unwrapping} 
%       \item \Z\Z $\delta, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r$ by substitution 

%       \item \Z\Z $\B{let}\ \sigma' \B{ s.t. } p \equiv v_1 \given \sigma'$ 
%       by theorem \ref{thm:model_typing_pattern_matching} 

%       \item \Z\Z $\B{for } e'$ 
%         \item \Z\Z\Z $\neg \epsilon[\sigma]\J{($v_1$)} \rightsquigarrow e'$ by definition
%         \item \Z\Z\Z $\neg F[\sigma]\J{($v_1$)} \rightsquigarrow e'$ by substitution 
%       \item \Z\Z $\forall e' .\ \neg F[\sigma]\J{($v_1$)} \rightsquigarrow e'$ by generalization 

%       \item \Z\Z $\J{($F[\sigma]$?$p$=>$e[\sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\sigma\backslash\B{FV}(p)][\sigma]$ by definition 

%       \item \Z\Z $\forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\sigma')$ 
%       by theorem \ref{thm:pattern_matching_consistency}
%       \item \Z\Z $\sigma\backslash\B{FV}(p) = \sigma\backslash\B{dom}(\sigma')$ 
%       by theorem \ref{thm:consistency_diffing}
%       \item \Z\Z $e[\sigma\backslash\B{dom}(\sigma')][\sigma'] = e[\sigma \cup \sigma']$ 
%       by theorem \ref{thm:concatenation_substitution}

%       \item \Z\Z $\J{($F[\sigma]$?$p$=>$e[\sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\sigma\backslash\B{dom}(\sigma')][\sigma]$ 
%         by substitution
%       \item \Z\Z $\J{($F[\sigma]$?$p$=>$e[\sigma\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\sigma \cup \sigma']$ 
%         by substitution 
%       \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($v_1$)} \rightsquigarrow e[\sigma \cup \sigma']$ by definition 
%       \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} \rightsquigarrow e[\sigma \cup \sigma']$ by substitution  

%       \item \Z\Z $\J{($F$?$p$=>$e$)$[\sigma]$($e_1[\sigma]$)} = (\J{($F$?$p$=>$e$)($e_1$)})[\sigma]$ by definition  
%       \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow e[\sigma \cup \sigma']$ by substitution  

%       \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition

%     \item \Z $\B{case } \delta, \Gamma \satisfies \J{$F$($e_1$)} \hastype \tau_r$ 
%       \item \Z\Z $\B{let } e' \B{ s.t. } (\J{$F$($e_1$}))[\sigma] \rightsquigarrow e' \land \delta, \Gamma \satisfies e' \hastype \tau_r$ by theorem \ref{thm:model_typing_function_progress}
%       \item \Z\Z $(\J{($F$?$p$=>$e$)($e_1$)})[\sigma] \rightsquigarrow e'$ by definition 
%       \item \Z\Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
%     \item \Z $\delta, \Gamma \satisfies \J{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
%   \item $\square$ by implication
% \end{theorem}


% \begin{theorem}\ (Pattern matching consistency)
%   \label{thm:pattern_matching_consistency}
%   \begin{mathpar}
%     \inferrule {
%       p \equiv v \given \sigma
%     } {
%       \forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\sigma)
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}



% \begin{theorem}\ (Consistency diffing)
%   \label{thm:consistency_diffing}
%   \begin{mathpar}
%     \inferrule {
%       \forall x .\ x \in X_l \iff x \in X_r 
%     } {
%       \sigma\backslash X_l = \sigma\backslash X_r
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Concatenation Substitution )
%   \label{thm:concatenation_substitution}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       e[\sigma\backslash\B{dom}(\sigma')][\sigma'] = e[\sigma \cup \sigma']
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}



% \begin{theorem}(Model typing valuation)
%   \label{thm:model_typing_valuation}
%   \begin{mathpar}
%     \inferrule {
%       \delta, \Gamma \satisfies e \hastype \tau 
%       \\
%       \delta, \sigma \satisfies \Gamma
%     } {
%       \delta \satisfies e[\sigma] \hastype \tau 
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{assume } 
%     \delta, \Gamma \satisfies e \hastype \tau 
%     \I
%     \delta, \sigma \satisfies \Gamma
%   $
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}


% \begin{theorem}(Model typing pattern matching)
%   \label{thm:model_typing_pattern_matching}
%   \begin{mathpar}
%     \inferrule {
%       \delta, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r
%       \\
%       \delta \satisfies v \hastype \tau_l 
%     } {
%       \exists \sigma .\  p \equiv v \given \sigma
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{assume } 
%     \delta, \Gamma \satisfies \J{?$p$=>$e$} \hastype \tau_l \J{->} \tau_r
%     \I
%     \delta \satisfies v \hastype \tau_l 
%   $
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}


% \begin{theorem}(Well-formed function valuation)
%   \label{thm:wellformed_function_valuation}
%   \begin{mathpar}
%     \inferrule {
%       \VDash F
%     } {
%       \exists v .\ v = F 
%     } 
%   \end{mathpar}
% \end{theorem}
% \begin{proof}
%   \item $\B{assume } \VDash F$ 
%     \item \Z $\B{invert on } \VDash F$
%     \item \Z $\B{case } v = F$
%       \item \Z\Z $v = F$ by identity
%     \item \Z $\B{case } F \rightsquigarrow e$
%     \item \Z $\B{wrt } e$
%       \item \Z\Z $\neg F \rightsquigarrow e$ by definition
%       \item \Z\Z $\bot$ by application 
%     \item \Z $v = F$ by inversion 
%   \item $\square$
% \end{proof}


% \begin{theorem}(Reduction closed)
%   \label{thm:reduction_closed}
%   \begin{mathpar}
%     \inferrule {
%       e \rightsquigarrow e'
%     } {
%       \forall x .\ x \notin \B{FV}(e')
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{assume } 
%     e \rightsquigarrow e'
%   $
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}

% \begin{theorem}(Closed substitution)
%   \label{thm:closed_substitution}
%   \begin{mathpar}
%     \inferrule {
%       \forall x .\ x \notin \B{FV}(e)
%     } {
%       e = e[\sigma]
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{assume } 
%     \forall x .\ x \notin \B{FV}(e)
%   $
%   \item \TODO{...}
%   \item $\square$
% \end{theorem}



% % \begin{theorem}(Progress of pattern matching)
% %   \label{thm:pattern_matching_progress}
% %   \begin{mathpar}
% %     \inferrule {
% %       \J{*$p$=>$e$} \in F 
% %       \\
% %       p \equiv v \given \sigma 
% %       \\
% %       \forall e' .\ \J{*$p$=>$e'$} \in F \implies e' = e 
% %     } {
% %       \exists e' .\ F\J{(}v\J{)} \rightsquigarrow e'
% %     } 
% %   \end{mathpar}
% %   Proof:
% %   \item $\B{for } p\ e\ F\ v\ \sigma\ \B{assume }
% %       \J{*$p$=>$e$} \in F 
% %       \I
% %       p \equiv v \given \sigma 
% %       \I
% %       \forall e' .\ \J{*$p$=>$e'$} \in F \implies e' = e 
% %   $

% %   \item \Z $\B{case }
% %     F = F'\ \J{*$p$=>$e$} 
% %     \I
% %     \J{*$p$=>$e$} \notin F'
% %   $

% %   \item \Z\Z $\B{for } e'$
% %   \item \Z\Z\Z $\B{case}\ F'\J{($v$)} \rightsquigarrow e'$
% %   \item \Z\Z\Z\Z $\J{(}F'\ \J{*}p\J{=>}e\J{)(} v \J{)} \rightsquigarrow e'$ by definition
% %   \item \Z\Z\Z\Z $F\J{(}v\J{)} \rightsquigarrow e'$ by substitution 
% %   \item \Z\Z\Z $\B{case}\ \neg F'\J{($v$)} \rightsquigarrow e'$
% %   \item \Z\Z\Z\Z $\J{(}F'\ \J{*}p\J{=>}e\J{)(} v \J{)} \rightsquigarrow e[\sigma]$ by definition
% %   \item \Z\Z\Z\Z $F\J{(}v\J{)} \rightsquigarrow e[\sigma]$ by substitution 
% %   \item \Z\Z\Z $\exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by decidability of $F'\J{($v$)} \rightsquigarrow e'$
% %   \item \Z\Z $\forall e' .\ \exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by summarization
% %   \item \Z\Z $\exists e'' .\ F\J{(}v\J{)} \rightsquigarrow e''$ by independence 

% %   \item \Z $\B{case }
% %     F = F'\ f 
% %     \I
% %     \J{*$p$=>$e$} \in F' 
% %   $
% %   \item \Z\Z $\B{let } e' \B{ s.t. } F'\J{(}v\J{)} \rightsquigarrow e'$ by induction hypothesis
% %   \item \Z\Z $F'\ f\J{(}v\J{)} \rightsquigarrow e'$ by definition
% %   \item \Z\Z $F\J{(}v\J{)} \rightsquigarrow e'$ by definition
% %   \item \Z $\exists e' .\ F\J{(}v\J{)} \rightsquigarrow e'$ by induction on $\J{*$p$=>$e$} \in F$
% %   \item $\square$
% % \end{theorem}

% \begin{theorem}(Model typing assignability)
%   \label{thm:model_typing_assignability}
%   \begin{mathpar}
%     \inferrule { 
%       \delta, \Gamma \satisfies e \hastype \tau
%     } {
%       \exists \sigma .\ \delta, \sigma \satisfies \Gamma 
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{...}
% \end{theorem}


% \begin{theorem}(Model typing soundness)
%   \label{thm:model_typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \delta, \Gamma \satisfies e \hastype \tau
%     } {
%       \forall \sigma .\ 
%       \delta, \sigma \satisfies \Gamma
%       \implies
%       \VDash e[\sigma]
%     } 
%   \end{mathpar}
%   Proof:
%   \item \TODO{redo using universal/implication}
%   \item $\B{assume }
%         \delta, \sigma \satisfies \Gamma 
%         \I \delta, \Gamma \satisfies e \hastype \tau
%   $
%     \item \Z $\B{case } e = \J{@}$
%       \item \Z\Z $\B{let } v \B{ s.t. } \J{@} = v$
%       \item \Z\Z $e[\sigma] = v$
%       \item \Z\Z $ \VDash e[\sigma]$


%     \item \Z $\B{case } 
%       \delta, \Gamma \satisfies e' \hastype \tau'
%       \I 
%       e = \J{<}l\J{>}e' 
%       \I 
%       \tau = \J{<}l\J{>}\tau'
%     $
%       \item \Z\Z $\Vdash e'$ by induction hypothesis
%       \item \Z\Z $\B{case } e'[\sigma] = v$
%         \item \Z\Z\Z $\B{let } v' \B{ s.t. } \J{<}l\J{>}v = v'$
%         \item \Z\Z\Z $\J{<}l\J{>}e'[\sigma] = v'$
%         \item \Z\Z\Z $(\J{<}l\J{>}e')[\sigma] = v'$
%         \item \Z\Z\Z $e[\sigma] = v'$
%         \item \Z\Z\Z $\VDash e[\sigma] $

%       \item \Z\Z $\B{case } e'[\sigma] \rightsquigarrow e'' \I \VDash e''$
%         \item \Z\Z\Z $\J{<}l\J{>}e'[\sigma] \rightsquigarrow \J{<}l\J{>} e''$
%         \item \Z\Z\Z $\VDash \J{<}l\J{>}e'' $
%         \item \Z\Z\Z $\VDash \J{<}l\J{>}e'[\sigma] $
%         \item \Z\Z\Z $\VDash (\J{<}l\J{>}e')[\sigma] $
%         \item \Z\Z\Z $\VDash e[\sigma] $

%       \item \Z\Z $\VDash e[\sigma] $ by cases on $\VDash e' $

%     \item \Z \TODO{remaining introduction cases}

%     \item \Z $\B{case } 
%       x \hastype \tau \in \Gamma
%       \I 
%       x \slash v \in \sigma
%       \I 
%       e = x
%     $
%       \item \Z\Z $x[\sigma] = v$
%       \item \Z\Z $e[\sigma] = v$
%       \item \Z\Z $\VDash e[\sigma] $

%     \item \Z $\B{case } 
%       e[\sigma] \rightsquigarrow e' 
%       \I 
%       \delta, \Gamma \satisfies e' \hastype \tau
%     $ 
%       \item \Z\Z $\VDash e'[\sigma] $ by induction hypothesis
%       \item \Z\Z $\VDash e[\sigma] $

%     \item \Z $\VDash e[\sigma] $ by induction on $\delta, \Gamma \satisfies e \hastype \tau$
%   \item $\square$
%   \item \TODO{Cretin's corresponding theorem is by definition of pretypes on p. 125}
% \end{theorem}

% \noindent
% \B{NOTE: } The induction hypothesis includes the generalized assumption, e.g. $\forall e' .\ e' < e \implies Q(e')$ if inducting on $e$ or $\forall e' .\ (P(e') \implies P(e)), P(e') \implies Q(e')$ if inducting on predicate $P$

% \noindent
% \B{NOTE: } we induct on $\delta, \Gamma \satisfies e \hastype \tau$ instead of $e$, as the predicate acts as a guard/ordering in lieu of a decreasing e.
% This allows us to use the induction hypothesis on the reduction step result in the elimination case.

% \noindent
% \B{NOTE: } Kozen says, "Intuitively, one can appeal to the coinductive hypothesis as long as there
% has been progress in observing the elements of the stream (guardedness) and there is no
% further analysis of the tails (opacity)".  Kozen demonstrates a legal proof by induction on infinite streams too

% % \begin{theorem}(Progress of Proof Typing)
% %   \label{thm:proof_typing_soundness}
% %   \begin{mathpar}
% %     \inferrule { 
% %       \Gamma \entails e \hastype \tau \given Z  
% %     } {
% %       e \B{ progressive}
% %     } 
% %   \end{mathpar}
% %   Proof ... 
% % \end{theorem}

% % \begin{theorem}(Preservation of Proof Typing)
% %   \begin{mathpar}
% %     \inferrule { 
% %       \Gamma \entails e \hastype \tau \given Z  
% %       \\
% %       e \rightsquigarrow e'
% %     } {
% %       \Gamma \entails e' \hastype \tau \given Z  
% %     } 
% %   \end{mathpar}
% %   Proof ... 
% % \end{theorem}


% \begin{definition}\boxed{\delta, \sigma \satisfies \Gamma}
%   \label{def:model_typing_sequence}
%   \begin{mathpar}
%     \inferrule { 
%     } {
%       \delta, \sigma \satisfies \epsilon  
%     } 

%     \inferrule { 
%       \delta, \sigma \satisfies \Gamma 
%       \\
%       \delta \satisfies v \hastype \tau 
%     } {
%       \delta, \sigma \ x \slash v \satisfies \Gamma \ x:\tau 
%     } 
%   \end{mathpar}
% \end{definition}


\end{document}