\documentclass[acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage[dvipsnames]{xcolor}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={let, fix, in}
}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
% \newtheorem{proof}{Proof}[section]


\title{Extrinsic Type Inference}
% \author{}
% \date{}

\begin{document}

% \newcommand{\obj}[1]{\texttt{\small #1}}
\newcommand{\obj}[1]{\texttt{\color{RoyalBlue} #1}}
\newcommand{\lab}[1]{\small \text{\color{Gray}\ [#1]}}
% \newcommand{\obj}[1]{\texttt{#1}}
% \newcommand{\obj}[1]{\textbf{\texttt{#1}}}
\newcommand{\entails}{\vdash}
\newcommand{\satisfies}{\vDash}
\newcommand{\given}{\dashv}
\newcommand{\with}{\ \diamond\ }
\newcommand{\notfree}{\ \#\ }
\newcommand{\consis}{\ \star}
\newcommand{\safe}{\ \checkmark}
\newcommand{\relational}{\ \Re}

\newcommand{\factorsinto}{\Vvdash}


\newcommand{\allsafe}{\ \Re\checkmark}



\newcommand{\foreign}{\varnothing}
\newcommand{\closed}{\bullet}
\newcommand{\local}{\blacktriangle}
\newcommand{\open}{\circ}


% \newcommand{\tl}{\textasciitilde{}}

\newcommand{\multi}[1]{\widebar{\ #1\ }}
\newcommand{\hastype}{:}
\newcommand{\pattype}{\ \lozenge\ }
\newcommand{\liftfun}{:}
 
\newcommand{\subtypes}{<:}
\newcommand{\supertypes}{:>}
\newcommand{\I}{\hspace{4mm}}
\newcommand{\Z}{.\hspace{4mm}}
\newcommand{\Alpha}{\mathrm{A}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\F}[1]{\text{#1}}
\newcommand{\bigand}{\bigwedge\nolimits}
\newcommand{\bigor}{\bigvee\nolimits}
\newcommand{\C}[1]{\color{teal} \rhd\ \emph{#1}}
\newcommand{\com}[1]{\color{Gray} \emph{#1}}
\newcommand{\D}[1]{\small \textsc{#1}}
% \newcommand{\fig}[1]{Fig. {\color{red} \fig{#1}}}
\newcommand{\FIG}[1]{Fig. {\color{red} \ref{#1}}}
\newcommand{\TODO}[1]{\noindent \B{\color{red} TODO: #1}}

\newcommand{\is}{\ ::=\ }
\newcommand{\sep}{\ \ |\ \ }
\newcommand{\nonterm}[1]{#1\ }
\newcommand{\contin}{|\ \ \ \ \ \ \ }
\newcommand{\case}{\B{case }}
\newcommand{\wrt}{\B{wrt }}
% \newcommand{\let}{\B{let }}
% \newcommand{\for}{\B{for }}
     


\newcommand{\tl}{\textasciitilde{}}
\newcommand{\fieldmap}{\obj{\tl>}}
\newcommand{\typdiff}{\obj{\textbackslash}}

\maketitle


\section{Introduction}

\paragraph{Context.} 

%%%%%%%%%%%%%
Automatically catching errors in programs is a hard enough problem
that many languages require users to provide simple specifications to limit that space of correctness.
Languages, such as Java and ML, are \textit{intrinsically typed}, 
requiring nearly all terms to be associated with some type specified by the user. 
The clever design of ML allows annotations to be fairly sparse by 
having types specified at constructor definitions and relying on type inference elsewhere.
However, one of the drawbacks of intrinsically typed languages is that they prevent reusing of
constructors in contexts that are less precise than their intrinsic specifications. For instance,
a \emph{cons} constructor belonging to a list datatype could not be considered amongst a \emph{leaf} constructor
defined as belong to a tree datatype. The user would have to define a new datatype that includes both isomorphs of both \emph{cons}
and \emph{leaf} and also write functions that translate between the isomorphs and the list and tree constructors. 
This not only bloats the codebase, but hurts either the runtime or compiler performance.

For various reasons that may include the reusability drawbacks, intrinsically typed languages have lost favor,
and untyped or \textit{extrinsically typed} languages, 
such as Javascript and Python, have increased in popularity. 
Untyped languages place less initial burden on the programmer to define the upper bounds
on specific combinations of constructors.
The flexibility and reusability of writing code that doesn't have to fit some predefined restriction 
may be seen as one of the benefits of these extrinsically typed languages over the well-studied intrinsically-typed languages.
Unfortunately, this freedom makes static analysis or type inference much more challenging. 

Despite the ever increasing use of untyped languages in production systems, 
the need to automatically verify precise and expressive properties of systems has never been greater.
To this end, researchers have extended the simple types (such as those found in ML) into 
\textit{refinement types}, \textit{predicate subtyping}, and \textit{dependent types}. 

Refinement types offer greater precision than simple types, but still rely on intrinsic type specifications.
Dependent types can express detailed relations, but may require users to provide proofs along with detailed annotations.
Predicate subtyping offers some of the expressivity of dependent types, but with the automatic subtyping of refinement types.
All of these techniques are based on intrinsic typing and therefore require users to provide additional annotations
beyond the runtime behavior of their programs.

The challenge with extrinsically typed languages is that they allow using constructors
in any possible combination, rather than prescribing the upper bound of combinations as in
the datatype mechanism of ML languages. Thus, the crux of typing extrinsically typed programs is
to determine a precise type based on how constructors are used. 
Since the way constructors are use may overlap is various ways, this form of reasoning about types
requires a notion of subtyping.
Type systems for extrinsically typed languages have relied on unions and intersections between types to 
represent precise types based on how expressions are used in combination. 

\paragraph{Gap.} 
Because extrinsically typed languages do not require users to specify the upper bounds of program expressions,
there are many untyped programs that cannot benefit from the typing techniques of 
intrinsically typed languages. Furthermore, extrinsically typed languages do not require users to provide proofs,
that have no runtime behavior, as is sometimes necessary in dependently typed systems to verify more expressive types.   
For instance, the liquid type system \cite{} can verify and infer some relational properties, 
but it requires users to specify ML-style base types and a set of logical qualifiers to draw from.
On the other hand, existing extrinsically typed techniques can not represent richer notions of relations 
beyond the mere shapes of expressions.
Thus, the challenge is to bring rich expressive types to extrinsically typed languages.

\paragraph{Innovation.} 
To overcome the limitations of intrinsic type systems and expand the kinds of programs and types that can be type checked, we introduce \textit{extrinsic relational type inference}: 
a novel system that automatically infers expressive properties from untyped functional programs. 

The main idea behind relational typing is to leverage subtyping as a means to express relations
between objects. This completely obviates the need for the two-level type language
used in liquid types or predicate subtyping. There is no special first-order predicate language. 
In relational typing, a relation is just a type in a subtyping lattice, just as a shape is just  
a type in a subtyping lattice. A subtyping judgment can degenerate into a typing judgment
when the left side or strong side of subtyping is a singleton type (type with a single inhabitant).
\TODO{insert example of (succ zero, cons nil) subs nat list}
Additionally, two separate relations may be compared via subtyping to say that one relation may hold true for a superset of inhabitants 
of another.
\TODO{insert example of even list subs nat list}
By embedding the notion of relations into subtyping the system can reuse techniques for inferring unions and
intersections over simple types, which are necessary in an extrinsic setting. 

In addition to checking that subtyping holds, the system is able to infer weak 
parameter types and strong return types of functions, which then serve as constraints
to be checked according to the applications of functions.

For comparison, the meaning of subtyping relations in relational types corresponds 
to the meaning of implication between qualifiers in liquid types.

While the purely functional setting presented in this work is not suitable for practical programming,
future work could extend it to incorporate side-effects to make it practical.
Alternatively, the purely functional setting could be viewed as an alternative formal foundation more
mathematics, allowing for greater proof automation by allowing reuse of proofs across the transitive closure of 
proposition subtyping.


\TODO{Describe the difference between extrinsic and intrinsic, in terms of descriptive and prescriptive}

\TODO{Describe the gap between refinement types (Pfenning) and full extrinsic types (using expansion types)}

\TODO{Mention the gap between SuperF and its principal types and full extrinsic type inference}

\TODO{mention how future work handles inductive relations represented as types}

\TODO{mention how inductive relational extrinsic type inference is an extrinsic alternative to CHC solving or liquid types}

\section{Overview}


\TODO{mention somwhere that the second order quantification serves two distinct purposes; 1. polymorphism as in System-F. 2. refinement as in first-order quantification of liquid types.
Relational types is able to leverage second-order quantification for refinement, eschewing the first-order quantification used in other systems.
}

% \paragraph{Parametric types}
% Universal types. Existential type. System F-style. Parameterization of types indexed by types (i.e. second order).

% \paragraph{Combination types.}
% One of the advantages of untyped programs is that they may be written in a flexible manner.
% Subtyping is necessary safely reflect the flexibility of compositions in programs, without too many false failures.
% Another main advantage of untyped programs is that users don't have to provide type specifications.
% Thus, a general way of constructing types from compositions encountered in the the program is necessary.
% Some compositions indicate that a type should strengthen, and some compositions indicate that a type should weaken.
% To this end, the type language uses intersection and union combinators, 
% whose semantics are degenerate versions of those in set-theory.

% For instance, when inferring the type of a function, 
% the system's goal is to infer the weakest valid parameter type and the strongest valid return type for a function definition.
% It strengthens the parameter type with intersection and weakens the return type with union according to the function body,
% to arrive at a valid type for the function.  

% By contrast, the liquid type language relies on the less flexible tagged unions of ML datatypes, 
% which is sufficient in its setting since those types are specified by the user. 
% Likewise, it does not rely on union to weaken to a valid return type. 
% Instead, it weakens to the strongest valid return type by dropping conjunctions from 
% the return type's qualifiers until a valid return type is found.

% \paragraph{Inductive types.} Similar to ML datatypes.

% \paragraph{Constraint types.}
% In addition to expressing the shapes of terms, the system should be able express relations between terms,
% such as "a list has the length of some natural number".
% Rather than using a distinct syntax for relational predicates, 
% the type language treats relations as just another type thereby reusing machinery already 
% available for types, such as existential types, union types, and inductive types.
% Since parametric types are second order, constraining relations requires subtyping.
% Thus, parametric types are extended with constraints in the form of subtyping.

For a given program, type inference constructs a very precise type. Some programs are simple enough
such that type inference generates singleton types. 

\TODO{example of a inference of intersection of function param applied to multiple arguments (not novel)}

\TODO{example of a inference of intersection of param with multiple functions applied to it (not novel)}

\TODO{example of a inference of union type of branching (not novel)}

\TODO{break example program into parts; inline instead of using figure}

We illustrate the syntax and semantics of programs and types with the example program shown in \FIG{fig:program}.

\paragraph{Finite Paths Preservation.}
Consider the function $\obj{talky}$, which completes a simple English phrase:

\[
  \begin{array}[t]{@{} l}
    \obj{let talky = (}
      \\
      \I \obj{? <hello> @ => <world> @}
      \\
      \I \obj{? <good> @ => <morning> @} 
      \\
      \I \obj{? <thank> @ => <you> @} 
      \\
    \obj{)}
  \end{array}
\]

This program is defined by paths over hardcoded tags.
The system infers the type to be an intersection of implication types:
\[
  \begin{array}[t]{@{} l}
    \obj{TOP}
    \\
    \obj{\& (<hello> @ -> <world> @)}
    \\
    \obj{\& (<good> @ -> <morning> @)} 
    \\
    \obj{\& (<thank> @ -> <you> @)}
  \end{array}
\]

Essentially, the program is so simple, that its type has the exact same meaning merely dressed in a different syntax.

\paragraph{Finite Paths Separation.}
Consider the application \obj{talky(x)} where \obj{x} has the type \obj{(<hello> @)|(<thank> @)}. 
Type inference breaks apart the function type's intersection into paths and 
constructs the strongest output type possible by expanding the output type
for each viable path. Since only two of the three paths 
match the type of the argument, type inference determines the type of the application to be the type 
\obj{(<world> @)|(<you> @)}.
Broadening from the bottom up contrasts with refinement type systems, which start from
the weakest type intrinsic to the constructors and refines down to a stronger type
through intersections of types or conjunctions of qualifiers.



\paragraph{Scalar Induction.} 
Now consider a function \obj{boo} whose input type is the natural numbers. 
Suppose we have the application \obj{boo(n)} where n guaranteed to be an even number.
\[
  \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT} 
      \\
      \I \obj{| <zero> @}
      \\
      \I \obj{| <succ> <succ> R}
      \\
      \obj{)} 
  \end{array}
\]
The application requires that type inference check that the nat type is weaker than the even type. 
Type inference sees that if both types were to unroll into an infinite sequence of values
every value in nat would also be in even, therefore the application type checks. 
In particular, type inference leverages the inductive hypothesis, by learning that weaker 
types hold for all the recursive constraints of the stronger type. 
In the case simple recursive types as shown above, the inductive hypothesis is merely a subtyping constraint
on a single variable.
In the case of comparing two relations such as \text{natList}(\obj{T}) and a corresponding even version, 
the inductive hypothesis would be a subtyping constraint on a pair of variables, which may not be decomposable into
constraints on single variables, so type inference must learn relational constraints, in addition to simple constraints. 


\paragraph{Finite Paths Integration.}
Consider two functions: \obj{uno} of type \obj{U->V} and \obj{dos} of type \obj{D->E}. 
Now suppose these two functions are called on the same variable, e.g. \obj{(uno(x),dos(x))}.
Type inference learns that the type of \obj{x} can be no weaker than the intersection
of the functions' input types: \obj{U\&D}. 

\TODO{note the connection to principal type}

\TODO{consinder using functional example from SuperF: \obj{foo f = (f 123, f True)}}



\TODO{Move following to inductive relational types paper}

\paragraph{Infinite Path Preservation} 
Consider the function \obj{repeat} that takes a natural number and returns a list of whose length is that number. 

\[
  \begin{array}[t]{@{} l}
      \obj{let repeat = ? x => loop(? self =>}
      \\
      \I \obj{? <zero> @ => <nil> @}
      \\
      \I \obj{? <succ> n => <cons>(x,self(n))}
      \\
      \obj{)}
  \end{array}
\]


Without specifying any requirements besides the function definition, type inference lifts 
the function into the definitional property as a type. 
To construct the type, type inference constructs a relation between nats and lists.
The type of \obj{repeat} depends on a least fixed point relation between nats and lists 
(parametrically named here for readability).

\[
  \text{natList}(\alpha) = \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT} 
      \\
      \I \obj{| (<zero> @)*(<nil> @)}
      \\
      \I \obj{| (EXI[N L ; N*L <: R](<succ> N)*(<cons> (}\alpha\obj{*L))}
      \\
      \obj{)} 
  \end{array}
\]

Using the \text{natList} relation, type inference then lifts the function repeat into its precise type form.

\[
  \obj{ALL[T] T -> ALL[X] X -> EXI[Y ; X*Y <: }\text{natList}(\obj{T}) \obj{] Y}
\]

It may be worth noting that there could be semantically equivalent recursive type in terms of intersections instead of unions. 

\TODO{forward reference to correctness/model semantics}

\[
  \begin{array}[t]{@{} l}
      \obj{ALL[T] GFP[R]( TOP} 
      \\
      \I \obj{\& (<zero> @)->(<nil> @)}
      \\
      \I \obj{\& (ALL[N L ; R <: N->L](<succ> N)->(<cons> T*L)}
      \\
      \obj{)} 
  \end{array}
\]


Type inference reasons in terms least fixed points, but the greatest fixed point form could
be handled with syntactic sugar and rewriting.  

Using the precise type form, type inference can leverage solving and checking subtyping constraints 
to reason in a number ways: it can reason forward from inputs to outputs (just like the runtime semantics), 
reason backwards from outputs to inputs (like Prolog), and check against weaker specifications. 


\paragraph{Infinite Path Separation.} Consider the application \obj{repeat(<succ> <succ> <zero> @)(x)} where \obj{x}
has type \obj{T}. Type inference
constructs a singleton type, mirroring the results achieved by simply running the program.  
\[
  \obj{<cons> T * <cons> T * <nil> @}
\]

Now suppose we have a function \obj{foo} whose input
type is inferred to be an empty list or a singleton list, \obj{<nil> @ |  <cons> T * <nil> @}.
Given the application \obj{foo(repeat(n)(x))} where \obj{x} has type \obj{T}, type inference can reason backwards to learn
that the type of \obj{n} must be either zero or one. 
\[
  \obj{<zero> @ | <succ> <zero> @}
\]



\paragraph{Infinite Path Factorization.} 
Now suppose we have a function \obj{woo} whose input
type is inferred to be a list over elements of type \obj{T}.
\[
  \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT}
      \\
      \I \obj{| <nil> @ }
      \\
      \I \obj{| <cons> T*R}
      \\
      \obj{)}
  \end{array}
\]

Given the application \obj{woo(repeat(n)(x))} where \obj{x} has type \obj{T}, type 
inference discovers that the argument type depends on the relation \text{natList}(\obj{T}), 
and the relation can be factored into a weaker cross product of nats and lists. 
Therefore, the argument meets the requirements
of \obj{woo} and the type of \obj{n} must be the natural numbers.

\[
  \begin{array}[t]{@{} l}
      \obj{LFP[R]( BOT} 
      \\
      \I \obj{| <zero> @}
      \\
      \I \obj{| <succ> R}
      \\
      \obj{)} 
  \end{array}
\]



\paragraph{Relational Induction.} 
\TODO{...}
\paragraph{Path Sensitivity.} Consider the function \obj{max} that chooses the maximum of two natural numbers. 



\[
  \begin{array}[t]{@{} l}
      \obj{let lessOrEq = loop(? self =>}
      \\
      \I \obj{? (<zero> @),y => <true> @}
      \\
      \I \obj{? (<succ> x),(<succ> y) => self(x,y)}
      \\
      \I \obj{? (<succ> x),(<zero> @) => <false> @}
      \\
      \obj{) in}
      \\
      \obj{let max = ? (x,y) => }
      \\
      \I \obj{if lessOrEq(x,y) then y else x}
  \end{array}
\]


The function \obj{max} must satisfy the property that the result is greater or equal to each of the inputs. 
Type inference must learn constraints on the inputs to \obj{max}: \obj{x} and \obj{y}, which 
depends on the output of \obj{lessOrEq(x,y)}. The application \obj{lessOrEq(x,y)} can evaluate to either \obj{<true>@}
or \obj{<false>@}, which result from different paths taken in \obj{lessOrEq}. 
Type inference considers both cases and maintains the learned constraints
exist in different possible worlds, since they are learned from different paths. Finally, type inference
connects the inputs to the outputs by considering the two possible paths of the \obj{if-then-else}.
It first lifts the function \obj{lessOrEq} into a relational type. For readability, we name the relational type \text{LED} (as in "less than or equal decision"). 

\[
  \text{LED} = 
  \begin{array}[t]{@{} l}
      \obj{LFP[R] ( BOT}
      \\
      \I \obj{| (EXI [Y] ((<zero> @)*Y)*(<true> @))}
      \\
      \I \obj{| (EXI [X Y D ; ((X*Y)*Z) <: R] ((<succ> X)*(<succ> Y))*D)}
      \\
      \I \obj{| (EXI [X] ((<succ> X)*(<zero> @))*(<false> @))}
      \\
      \obj{)}
  \end{array}
\]

using the \text{LED} relation, type inference combines the constraints learned
for each possible world and combines them into a function type with multiple paths. 

\[
  \begin{array}[t]{@{} l}
    \obj{TOP}
    \\
    \obj{\& (EXI [D ; D <: (<true> @)]}
    \\
    \I \obj{(ALL [X Y Z ; Y <: Z ; ((X*Y)*D) <:}\text{LED}\obj{] (X,Y) -> Z))}
    \\
    \obj{\& (EXI [D ; D <: (<false> @)]}
    \\
    \I \obj{(ALL [X Y Z ; X <: Z ; ((X*Y)*D) <: }\text{LED}\obj{] (X,Y) -> Z))}
  \end{array}
\]

We could simplify the type by eliminating simple constraints without loss of safety or precision:

\[
  \begin{array}[t]{@{} l}
    \obj{TOP}
    \\
    \obj{\& (ALL [X Y ; ((X*Y)*(<true> @)) <: }\text{LED}\obj{] (X,Y) -> Y)}
    \\
    \obj{\& (ALL [X Y ; ((X*Y)*(<false> @)) <: }\text{LED}\obj{] (X,Y) -> X)}
  \end{array}
\]

However, we have not included this rewriting in the semantics or implementation. 


\TODO{show type generated from code}


\TODO{more motivating and elucidating examples}
% \paragraph{List bounds.}
% \paragraph{Generalization.} This is motivated by applying the same function to multiple arguments of varying types.
% \paragraph{Object oriented.}  

\section{Expression System}
The programming language is pure and applicative. 


\begin{definition} Expressions
  \label{def:expressions}
  \[\begin{array}[t]{r@{}l}
    \nonterm{e} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      x \sep 
      \obj{@} \sep
      \obj{<}l\obj{>}e \sep 
      \vec{r} \sep
      \vec{f} \sep 
      e\obj{.}l \sep
      e\obj{(}e\obj{)} \sep
      \obj{loop(}e\obj{)} \sep
      ...
    \end{array}
    \\
    \nonterm{\vec{r}} & \is \epsilon \sep \vec{r}\ r 
    \\
    \nonterm{r} & \is \obj{?}l\obj{=>}e
    \\
    \nonterm{\vec{f}} & \is \epsilon \sep \vec{f}\ f
    \\
    \nonterm{f} & \is \obj{?}p\obj{=>}e
    \\
    \nonterm{p} & \is 
      x \sep
      \obj{@} \sep
      \obj{<}l\obj{>}p \sep
      \vec{k}
    \\
    \nonterm{\vec{k}} & \is \epsilon \sep \vec{k}\ k
    \\
    \nonterm{k} & \is \obj{?}l\obj{=>}p
  \end{array}\]
\end{definition}

A program is an expression 
of the form in definition \ref{def:expressions}. The forms of expressions
enable function abstraction, function application, tagged constructions, record construction, record projection,
and pattern matching. These forms enable us to express non-trivial programs. They also allow
for compositions that have no reasonable semantics.  

\begin{definition}
  \label{def:progression}
  Progression
  \hfill 
  \boxed{e \rightsquigarrow e}
  \\
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{<}l\obj{>}e \rightsquigarrow \obj{<}l\obj{>}e'
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \vec{r}\obj{?}l\obj{=>}e \rightsquigarrow \vec{r}\obj{?}l\obj{=>}e' 
    }

    \inferrule {
      \vec{r} \rightsquigarrow \vec{r}'
    } {
      \vec{r}\obj{?}l\obj{=>}v \rightsquigarrow \vec{r}'\obj{?}l\obj{=>}v
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      e\obj{.}l \rightsquigarrow e'\obj{.}l
    }

    \inferrule {
      \obj{?}l\obj{=>}v \in \vec{g}
      \\
      \forall\ e .\ \obj{?}l\obj{=>}e \in \vec{g} \implies e = v
    } {
      \vec{g}\obj{.}l \rightsquigarrow v
    }

    \inferrule {
      e_f \rightsquigarrow e_f'
    } {
      e_f\obj{(}e\obj{)} \rightsquigarrow e_f'\obj{(}e\obj{)}
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \vec{f}\obj{(}e\obj{)} \rightsquigarrow \vec{f}\obj{(}e'\obj{)}
    }

    \inferrule {
      \vec{f}\obj{(}v\obj{)} \rightsquigarrow e'
      \\
      \text{FV}(e) \subseteq \text{FV}(p)
    } {
      (\vec{f}\obj{?}p\obj{=>}e)\obj{(}v\obj{)} \rightsquigarrow e' 
    }

    \inferrule {
      \exists e' .\ \vec{f}\obj{(}v\obj{)} \rightsquigarrow e'
      \\
      p \equiv v \given \vec{\sigma} 
    } {
      (\vec{f}\obj{?}p\obj{=>}e)\obj{(}v\obj{)} \rightsquigarrow e[\vec{\sigma}]
    }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \obj{loop(}e\obj{)} \rightsquigarrow \obj{loop(}e'\obj{)}
    }

    \inferrule {
    } {
      \obj{loop(?}x\obj{=>}e\obj{)} \rightsquigarrow e[x \slash \obj{loop(?}x\obj{=>}e\obj{)}]
    }
  \end{mathpar}
\end{definition}

\emph{Progression} of an expression, as in definition \ref{def:progression},
is a small-step operational semantics. 
It adheres to typical definitions of applicative languages for the most part. One 
slight departure is that pattern matching is merely a special case of function application. 
Likewise, a switch is merely a function abstraction.
Records are similar to Functions, except that their entries are guarded by literal identifiers. 
Additionally, records may be abstracted as patterns, but functions may not.
The semantics enables recursion via the fixed point combinator \obj{loop}.


\section{Type System}
The static semantics is a system for checking if the construction of an expression is viable.   

\hfill
\begin{definition} Types 
  \label{def:types}
  \[\begin{array}[t]{r@{}l@{}r}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \kappa \sep 
      \phi \sep 
      \psi \sep 
      \theta \sep
      \gamma
    \end{array}
    & \com{type}
    \\
    \nonterm{\kappa} & \is 
    \begin{array}[t]{@{}l}
      \obj{@} \sep
      \obj{<}l\obj{>}\tau \sep 
      l \fieldmap \tau \sep 
      \tau\obj{->}\tau
    \end{array}
    & \com{base type}
    \\
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      \tau\obj{|}\tau \sep 
      \obj{EXI[}\vec{\alpha}\ \Delta \obj{]} \tau
    \end{array}
    & \com{expansion type}
    \\
    \nonterm{\psi} & \is 
    \begin{array}[t]{@{}l}
      \tau\obj{\&}\tau \sep 
      \obj{ALL[}\vec{\alpha}\ \Delta \obj{]} \tau
    \end{array}
    & \com{refinement type}
    \\
    \nonterm{\theta} & \is 
    \begin{array}[t]{@{}l}
      \obj{LFP[}\alpha\obj{]}\tau \sep
      \tau \typdiff \eta
    \end{array}
    & \com{special type}
    \\
    \nonterm{\gamma} & \is 
    \begin{array}[t]{@{}l}
      \obj{TOP} \sep \obj{BOT} \sep 
      \tau \obj{*} \tau 
    \end{array}
    & \com{sugar type}
    % \\
    % \nonterm{r} & \is 
    % \begin{array}[t]{@{}l}
    %   \tau \obj{|} \tau \obj{->} \tau \sep
    %   \tau \obj{->} \tau \obj{\&} \tau \sep
    %   l \obj{->} \tau \obj{\&} \tau
    % \end{array}
    % & \com{rewritable type}
    % A | B -> C <: P -> Q ... (A -> C) & (B -> C) <: P -> Q ... (A -> C) <: P -> Q OR  (B -> C) <: P -> Q ..  P <: A, C <: Q OR  P <: B OR C <: Q 
    % A | B -> C <: P -> Q ... P <: A | B, C <: Q  ... P <: A, C <: Q OR P <: B, C <: Q 
    %%%%
    % P -> Q <: A | B -> C  ...  P -> Q <: (A -> C) & (B -> C) ...  P -> Q <: (A -> C), P -> Q <: (B -> C) .. A <: P, Q <: C, B <: P 
    %  P -> Q <: A | B -> C  ... A | B <: P, Q <: C ... A <: P, B <: P, Q <: C
    \\\\
    \nonterm{\eta} & \is 
    \begin{array}[t]{@{}l}
      \obj{EXI[}\vec{\alpha}\ \Delta \obj{]} \rho \sep 
      \rho
    \end{array}
    & \com{subtracted type}
    \\
    \nonterm{\rho} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \obj{@} \sep
      \obj{<}l\obj{>}\rho \sep 
      l \fieldmap \rho \sep 
      \rho\obj{\&}\rho
    \end{array}
    & \com{pattern type}
    \\
    \nonterm{\vec{\alpha}} & \is \epsilon \sep \vec{\alpha}\ \alpha 
    & \com{type variable sequence}
    \\
    \nonterm{\Delta} & \is \epsilon \sep \Delta\ \obj{;} \tau \obj{<:} \tau
    & \com{subtyping environment}
  \end{array}\]
\end{definition}
\hfill

The system leverages types of the forms in Definition \ref{def:types}, 
which allow expressing properties of expressions with varying levels of precisions. 

\hfill
\begin{definition} 
  \label{def:type_desugaring}
  Type Desugaring 
  \hfill 
  \boxed{\text{desugar}(\gamma) = \tau}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \text{desugar}(\obj{TOP}) = \obj{EXI[} \alpha \obj{]} \alpha
    }

    \inferrule {
    } {
      \text{desugar}(\obj{BOT}) = \obj{ALL[} \alpha \obj{]} \alpha
    }

    \inferrule {
    } {
      \text{desugar}(\tau_l \obj{*} \tau_r) = (\obj{left} \fieldmap \tau_l)  \obj{*} (\obj{right} \fieldmap \tau_r)
    }
  \end{mathpar}
\end{definition} 
\hfill

For each statement over a sugar type $\gamma$, we assume that $\gamma$ is implicitly replaced with $\text{desugar}(\gamma)$.

\hfill
\begin{definition} 
  \label{def:proof_typing}
  Proof Typing
  \hfill 
  \boxed{\Gamma \entails e \hastype \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \Gamma \entails \obj{@} \hastype \obj{@} \given \Omega 
    }

    \inferrule {
      x:\tau \in \Gamma
    } {
      \Gamma \entails x \hastype \tau \given \Omega 
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given \Omega 
    } {
      \Gamma \entails \obj{<}l\obj{>}e \hastype \obj{<}l\obj{>}\tau \given \Omega 
    }

    \inferrule {
      \vec{r} = \epsilon
    } {
      \Gamma \entails \vec{r} \hastype \obj{TOP} \given \Omega
    }

    \inferrule {
      \Gamma \entails \vec{r} \hastype \tau \given \Omega 
      \\\\
      \Omega \preceq \Omega'
      \\
      \Gamma \entails e \hastype \tau' \given \Omega' 
    } {
      \Gamma \entails \vec{r}\ \obj{?}l \fieldmap e \hastype \tau\ \obj{\&}\ l \fieldmap \tau' \given \Omega' 
    }

    \inferrule {
      \exists \vec{\eta}.\ \vec{\alpha}, \Delta, \Gamma \entails \vec{f} \liftfun \vec{\pi} \sim \vec{\eta} 
      \\\\
      \text{pack}^+(\text{FTV}(\Gamma)\ \vec{\alpha} \entails \vec{\pi}) = \tau 
    } {
      \Gamma \entails \vec{f} \hastype \tau \given \vec{\alpha}, \Delta
    }

    \inferrule {
      \Gamma \entails e \hastype \tau_0 \given \Omega 
      \\\\
      \Omega \preceq \Omega'
      \\
      \tau_0 \subtypes l \fieldmap \alpha \given \Omega' 
    } {
      \Gamma \entails e\obj{.}l \hastype \alpha \given \Omega'
    }

    \inferrule {
      \Gamma \entails e_f \hastype \tau_f \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \Gamma \entails e_a \hastype \tau_a \given \Omega' 
      \\\\
      \Omega' \preceq \Omega''
      \\
      \tau_f \subtypes \tau_a\obj{->}\alpha \given \Omega'' 
    } {
      \Gamma \entails e_f\obj{(}e_a \obj{)} \hastype \alpha \given \Omega''
    }

    \inferrule {
      \Gamma \entails e \hastype \tau \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau \subtypes \tau_a \given \Omega' 
      \\\\
      \Omega' \preceq \Omega''
      \\
      \Gamma\ x:\tau_x \entails e' \hastype \tau' \given \Omega''
    } {
      \Gamma \entails \obj{let}\ x \obj{:} \tau_a\ \obj{=}\ e\ \obj{in}\ e' \hastype \tau' \given \Omega'' 
    }

    \inferrule {
      \Gamma \entails e \hastype \alpha_\nu\obj{->}\tau \given  \vec{\alpha}, \Delta 
      \\\\
      \forall \vec{\alpha}'\ \Delta' .\ 
        \vec{\alpha}', \llbracket \epsilon, \vec{\alpha}\ \vec{\alpha}' \entails \Delta', \alpha_l \obj{->} \alpha_r \rrbracket^+ \in \vec{\pi}_\nu
      \implies
      \tau \subtypes \alpha_l\obj{->}\alpha_r \given  \vec{\alpha}\ \vec{\alpha}', \Delta\ \Delta' 
      \\\\
      \exists \pi.\ \pi \in \vec{\pi}_\nu
      \\
      \alpha_\nu \downarrow \vec{\pi}_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \vec{\pi}_\mu
      \\
      \text{pack}^-(\text{FTV}(\Gamma)\ \vec{\alpha}\ \alpha_\mu \entails \vec{\pi}_\mu) = \tau_\mu
      \\\\
      \exists \alpha .\ \alpha \obj{*} \obj{BOT} \subtypes \obj{LFP[} \alpha_\mu \obj{]}\tau_\mu \factorsinto \alpha \subtypes \tau_l 
      \\
      \exists \alpha .\ \obj{BOT} \obj{*} \alpha  \subtypes \obj{LFP[} \alpha_\mu \obj{]}\tau_\mu \factorsinto \alpha \subtypes \tau_l 
    } {
      \Gamma \entails \obj{loop(}e\obj{)} 
      \hastype 
      \tau_l \obj{->} \tau_r
      \given \vec{\alpha}, \Delta 
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{explain the advantage of using the least fixed point type over the greatest fixed point type.
By rewriting a function type in terms of the least fixed point type,
instead of the greatest fixed point type around the implication type,
the subtyping solver can avoid infinitely unrolling the GFP in an attempt to construct
the least fixed point return type. 
}

\emph{Proof typing}, def. \ref{def:proof_typing}, checks the viability of an expression's
form. Additionally, by extending the forms of expressions with type annotations, 
as in Definition \ref{def:sugared_expressions},
proof typing is also able to check that expressions meet abstract specifications.
In order to check the viability of constructions and specifications, 
proof typing lifts expressions into types and leverages subtyping to 
check compatibility between types. 
The proof typing predicate represents a typing that holds under the assumptions
of a typing environment, and a world, 
which consists of emph{closed} type variables and subtyping constraints. 

Whether a variable is a closed or not represents how a variable is quantified.

If proof typing holds, then its typing holds under every interpretation of its closed type variables
under some interpretation of its open variables.
We formalize ths soundness claim in Section \ref{sect:correctness}. 

The proof typing predicate, $\Gamma \entails e \hastype \tau \given \Omega'$, can 
be interpreted as an algorithm that takes a typing environment $\Gamma$, an expression $e$,
and a world $\Omega$ as inputs and returns a type and a world $\Omega'$ as outputs,
such that the output world is an extension of the input world $(\Omega \preceq \Omega')$.
The input world is not explicitly represented in the predicate, so the algorithm
interprets the input world as the smallest world that can satisfy the predicate. 
Additionally, the outputs of the predicate are not deterministic. Therefore, the algorithm
enumerates all possible outputs.


% The proof typing predicate, $\Omega, \Gamma \entails e \hastype \tau \with \Omega'$, can 
% be interpreted as an algorithm that takes a world $\Omega$, a typing environment $\Gamma$, and an expression $e$,
% as inputs and returns a type $\tau$ and a world $\Omega'$ as outputs,
% such that the output world is an extension of the input world $(\Omega \preceq \Omega')$.
% Additionally, the outputs of the predicate are not deterministic. Therefore, the algorithm
% enumerates all possible outputs.

\paragraph{Rule \ref{def:proof_typing}.1}
For unit, \obj{@}, proof typing simply returns the singleton type of the same
form. 

\paragraph{Rule \ref{def:proof_typing}.2}
For a variable, $x$, proof typing looks
for a corresponding typing in the environment, and returns the 
corresponding type if found.

\paragraph{Rule \ref{def:proof_typing}.3}
For a tagged expression, $\obj{<}l\obj{>}e$, proof typing recursively 
constructs the type of the tag's body,
and returns the corresponding tag type.

\paragraph{Rule \ref{def:proof_typing}.4}
For an empty record, proof typing constructs the top type \obj{TOP},
which is merely syntactic sugar for $\obj{EXI[}\alpha\obj{]}\alpha$.

\paragraph{Rule \ref{def:proof_typing}.5}
For a non empty record, $\vec{r}\obj{?}l\obj{=>}e$, proof typing 
recursively constructs the type for each entry, and
refines their types against each other via intersection.

\paragraph{Rule \ref{def:proof_typing}.6}
For a function, $\vec{f}$, proof typing 
delegates the work to two helper predicates: \emph{function lifting}, as in definition \ref{def:function_lifting}, and
\emph{constrained implication congruence}, as in definition \ref{def:constrained_implication_congruence}.
Function lifting constructs a sequence of implication types, where each associated with a world, represented by $\vec{\pi}$.
Constrained implication congruence, constructs a sequence of types congruent with each implication,
such that each world is packaged with its corresponding type, resulting in a universally constrained type 
(if there are type variables in the original implication). 
During an application, each path of a function is tried in order, which means values matching subsequent
patterns, will not be matched by earlier patterns. Thus, function lifting generates types from patterns,
and for each pattern, it subtracts the types of previous patterns,
represented by prefixes of $\vec{eta}$

\paragraph{Rule \ref{def:proof_typing}.7}
For a projection, $e\obj{.}l$, proof typing
leverages subtyping to check that there is an entry with label $l$ 
in the supposed record $e$, and it learns a lower bound 
on the type of the body $\alpha$ associated with that label.


\paragraph{Rule \ref{def:proof_typing}.8}
For an application, $e_f\obj{(}e_a\obj{)}$, proof typing
leverages subtyping to check that that the function $e_f$ can actually
map the argument $e_a$ to a result. It learns a lower bound 
on the type of the result $\alpha$ associated with that argument.


\paragraph{Rule \ref{def:proof_typing}.9}
For a recursive expression, $\obj{loop(}e{)}$, proof typing
constructionsa complex type containing an implication constrained
by a least fixed point type.  
First, it ensures that argument of the fixpoint combinator $e$ is indeed a 
singe path function. Then, by leveraging subtyping, 
it finds a lower bound for every path in the body of $e$,
represented by a sequence of worlds $\vec{\Omega}$, 
all associated with a variable implication, $\alpha_l\obj{->}\alpha_r$.
Using all these worlds, it delegates to \emph{fixpoint duality}, as in definition \ref{def:fixpoint_duality},
it order to construct the cases of a relational least fixpoint type, 
representing the dual of the greatest fixpoint of implication under intersected over its worlds.
Finally, it reconstructs a type for a function, by wrapping the relational type in an existential constraint,
and wrapping a generalized implication around that. 

For an annotated definition, $\obj{let}\ x \obj{:} \tau_a\ \obj{=}\ e\ \obj{in}\ e'$, 
proof typing checks the definition's source $e$ against the annotation $\tau_a$,
and adds the annotation to the typing environment when checking the contintuation $e'$.

\hfill
\begin{definition} 
  \label{def:world_containment}
  World Containment 
  \hfill
  \boxed{\Omega \preceq \Omega}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      (\vec{\alpha},\Delta)  \preceq (\vec{\alpha}\ \vec{\alpha}',\Delta\ \Delta') 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:function_lifting}
  Function Lifting
  \hfill
  \boxed{\vec{\alpha}, \Delta, \Gamma \entails \vec{f} \liftfun \vec{\pi} \sim \vec{\eta}}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \vec{\alpha}, \Delta, \Gamma \entails \epsilon \liftfun \epsilon \sim \epsilon 
    }

    \inferrule {
      \vec{\alpha}, \Delta, \Gamma \entails \vec{f} \liftfun \vec{\pi} \sim \vec{\eta} 
      \\
      p \hastype \rho \given \Gamma'
      \\
      \text{diff}(\rho, \vec{\eta}) = \tau_l
      \\\\
      \forall \vec{\alpha}'\ \Delta'\ \tau_r .\ 
      \vec{\alpha}', \llbracket \epsilon, \vec{\alpha}\ \vec{\alpha}' \entails \Delta', \tau_l \obj{->} \tau_r \rrbracket^+ \in \vec{\pi}'
      \implies
      \Gamma\ \Gamma' \entails e \hastype \tau_r \given \vec{\alpha}\ \vec{\alpha}', \Delta\ \Delta' 
      \\\\
      \exists \pi .\ \pi \in \vec{\pi}' 
      \\
      \text{close}(\rho) = \eta
    } {
      \vec{\alpha}, \Delta, \Gamma \entails \vec{f}\ \obj{?}p\obj{=>}e \liftfun 
      \vec{\pi}\ \vec{\pi}' \sim \vec{\eta}\ \eta
    }
  \end{mathpar}
\end{definition}

\begin{definition} 
  \label{def:fixed_point_duality}
  Fixed Point Duality 
  \hfill
  \boxed{\alpha \downarrow \vec{\pi} \fallingdotseq \alpha \uparrow \vec{\pi}}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_{\nu} \downarrow \epsilon
      \fallingdotseq 
      \alpha_{\mu} \uparrow \epsilon 
    }

    \inferrule {
      \alpha_{\nu} \downarrow \vec{\pi}_\nu
      \fallingdotseq 
      \alpha_{\mu} \uparrow \vec{\pi}_\mu
      % \\\\
      % \llbracket \Delta_\nu, \alpha_l \rrbracket^- = (\Delta', \tau_l)
      % \\
      % \llbracket \Delta', \alpha_r \rrbracket^+ = (\Delta'', \tau_r)
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \vec{\alpha}_f \entails 
      \alpha_{\nu} \downarrow \vec{\pi}_\nu\ \left< \vec{\alpha}_c,\Delta_\nu, \tau_l \obj{->} \tau_r \right> 
      \fallingdotseq 
      \alpha_{\mu} \uparrow \vec{\pi}_\mu\ \left< \vec{\alpha}_c,\Delta_\mu, \tau_l' \obj{*} \tau_r' \right>
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{Note the reason for excluding rigids and closeds from quantification is a way to improve precision, but not necessary for soundness. (Right?). Need to conjure up an example to support this idea.}

\TODO{soundness idea: $ 
\\ \forall f\ e_l\ e_r\ \alpha_l\ \alpha_r\ \vec{\alpha}\ \Delta\ \vec{\alpha}'\ \Delta'\ \vec{\Omega},  
\\ ... \implies
\\ f(e_1) = e_2 \implies \left< \vec{\alpha}', \Delta' \right> \in \vec{\Omega} \implies 
\\ (
\Gamma, ... \satisfies f : \alpha_l \obj{->} \alpha_r 
\iff 
\Gamma, ... \satisfies (e_l,e_r) : \alpha_l \obj{*} \alpha_r
)$ 
}


\hfill
\begin{definition}
  \label{def:pair_duality}
  Fixed Point Constraint Duality 
  \hfill
  \boxed{\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon 
    }

    \inferrule {
      \alpha_\nu \notin \text{FTV}(\tau_l)
      \\
      \alpha_\nu \notin \text{FTV}(\tau_r)
      \\
      \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_\mu
    } {
      \alpha_\nu \downarrow \Delta_\nu\ (\tau_l <: \tau_r) \fallingdotseq \alpha_\mu \uparrow \Delta_\mu\ (\tau_l <: \tau_r)
    }

    \inferrule {
    } {
      \alpha_\nu \downarrow \Delta_\nu\ (\alpha_\nu <: \alpha_l \obj{->} \alpha_r) \fallingdotseq \alpha_\mu \uparrow \Delta_\mu\ (\alpha_l \obj{*} \alpha_r <: \alpha_\mu)
    }
  \end{mathpar}
\end{definition}
\hfill

% \hfill
% \begin{definition}\boxed{\alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_l, \Delta_r}\ Fixed Point Constraint Extraction 
% \label{def:pair_duality}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       \alpha_\nu \downarrow \epsilon \fallingdotseq \alpha_\mu \uparrow \epsilon, \epsilon
%     }

%     \inferrule {
%       \alpha_\nu \notin \text{FTV}(\tau_l)
%       \\
%       \alpha_\nu \notin \text{FTV}(\tau_r)
%       \\
%       \alpha_\nu \downarrow \Delta_\nu \fallingdotseq \alpha_\mu \uparrow \Delta_l, \Delta_r
%     } {
%       \alpha_\nu \downarrow \Delta_\nu\ (\tau_l <: \tau_r) \fallingdotseq \alpha_\mu \uparrow \Delta_l\ (\tau_l <: \tau_r), \Delta_r\ (\tau_l <: \tau_r)
%     }

%     \inferrule {
%     } {
%       \alpha_\nu \downarrow \Delta_\nu\ (\alpha_\nu <: \alpha_l \obj{->} \alpha_r) \fallingdotseq \alpha_\mu \uparrow 
%       \Delta_l\ (\alpha_l <: \alpha_\mu)
%       , 
%       \Delta_r\ (\alpha_r <: \alpha_\mu)
%     }
%   \end{mathpar}
% \end{definition}
% \hfill









\emph{Proof subtyping}, as in definition \ref{def:proof_subtyping},
checks the viability of one type subtyping another type, under the assumption
of subtyping constraints.

The predicate, $\tau_l \subtypes \tau_r \given \Omega'$, can be interpreted as an algorithm
that takes the types and an implicit world $\Omega$ as inputs and return
a world $\Omega'$, where the output world extends the input world $(\Omega \preceq \Omega')$
and the input world is the smallest world necessary for the proposition to hold.  

% The predicate, $\Omega \entails \tau_l \subtypes \tau_r \with \Omega'$, can be interpreted as an algorithm
% that takes the world $\Omega$, and two types as inputs, and returns
% a world $\Omega'$, where the output world extends the input world $(\Omega \preceq \Omega')$.

The order of the rules 
is critical to ensure that easier constraints are generated. To that end, cases that
strengthen the assumed type (left of subtyping) or weaken the guaranteed type (right of subtyping) occur before rules that
weaken the assumed type or strengthen the guaranteed type.

Due to the complexity of types along with two positions for types to occur in subtyping,
there are many rules needed to define the proof system of subtyping. For clarity,
we show only a subset of the rules in this section in order to explain the essence of the system.
We leave the remaining rules in the appendix, section \ref{sect:appendix}, definition \ref{def:continued_proof_subtyping}. 
The remaining rules include duals and other forms that adhere to similar proof strategies as the rules shown here,
as well as additional rules for increased precision.  


\hfill
\begin{definition} 
  \label{def:proof_subtyping_reflection}
  Proof Subtyping (Reflection)
  \hfill
  \boxed{\tau_l \subtypes \tau_r \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \tau \subtypes \tau \given \Omega 
    }\lab{1}
  \end{mathpar}
\end{definition}
\hfill

For reflexive subtyping, up to alpha renaming, $\tau \subtypes \tau$, 
proof subtyping simply holds without any updates to the world.


\hfill
\begin{definition} 
  \label{def:proof_subtyping_basic_preservation}
  Proof Subtyping (Base Preservation)
  \hfill
  \boxed{\kappa_l \subtypes \kappa_r \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l \subtypes \tau_r
      \given \Omega 
    } {
      \obj{<}l \obj{>} \tau_l \subtypes \obj{<} l \obj{>} \tau_r
      \given \Omega 
    }

    \inferrule {
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      l \obj{->} \tau_l \subtypes l \obj{->} \tau_r \given \Omega 
    }

    \inferrule {
      \tau_{rl} \subtypes \tau_{ll} \given \Omega
      \\
      \Omega \preceq \Omega'
      \\
      \tau_{lr} \subtypes \tau_{rr} \given \Omega' 
    } {
      \tau_{ll} \obj{->} \tau_{lr} 
      \subtypes 
      \tau_{rl} \obj{->} \tau_{rr}
      \given \Omega' 
    }
  \end{mathpar}
\end{definition}
\hfill

For subtyping tagged types, $\obj{<}l \obj{>} \tau_l \subtypes \obj{<} l \obj{>} \tau_r$, 
proof subtyping simply checks that the labels match and subtyping holds
for their contents.


For subtyping record types, $l \obj{->} \tau_l \subtypes l \obj{->} \tau_r \given \Omega$
proof subtyping simply checks that the labels match and subtyping holds
for their contents.

For subtyping implication types, $\tau_{ll} \obj{->} \tau_{lr} \subtypes \tau_{rl} \obj{->} \tau_{rr}$
proof subtyping simply checks that the space between types of the upper bound
contains the space between types of the lower bound.


\hfill
\begin{definition} 
  \label{def:proof_subtyping_implication_rewriting}
  Proof Subtyping (Implication Rewriting)
  \hfill
  \boxed{\tau \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l \subtypes
      (\tau_a\obj{->}\tau_r)\obj{\&}(\tau_b\obj{->}\tau_r)
      \given \Omega
    } {
      \tau_l \subtypes 
      (\tau_a\obj{|}\tau_b)\obj{->}\tau_r
      \given \Omega 
    }


    \inferrule {
      \tau_l
      \subtypes
      (\tau_r\obj{->}\tau_a)
      \obj{\&}
      (\tau_r\obj{->}\tau_b)
      \given \Omega 
    } {
      \tau_l \subtypes 
      \tau_r\obj{->}(\tau_{a}\obj{\&}\tau_{b})
      \given \Omega
    }

    \inferrule {
      \tau
      \subtypes
      (l\obj{->}\tau_a)
      \obj{\&}
      (l\obj{->}\tau_b)
      \given \Omega 
    } {
      \tau \subtypes 
      l\obj{->}(\tau_{a}\obj{\&}\tau_{b})
      \given \Omega
    }

  \end{mathpar}
\end{definition}
\hfill

\TODO{NOTE how this rewriting turns the type inside out; going from implication on the outside to refinement/abstraction on the outside}

\TODO{Note how this is the opposite direction from the loop type consturction, which puts the implication on the outside and the fixed point on the inside,
in order to prevent infinite unrolling in the subtyping solver}

\TODO{Note how these correspond to disjunction elimination and conjunction introduction in traditional proofs}

\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_elimination}
  Proof Subtyping (Abstraction Elim)
  \hfill
  \boxed{\phi \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_{ll} \subtypes \tau_r
      \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau_{lr} \subtypes \tau_r
      \given \Omega' 
    } {
      \tau_{ll}\obj{|}\tau_{lr} \subtypes \tau_r
      \given \Omega' 
    }
    \\
    \inferrule {
      \vec{\alpha}_l \notfree \tau_r
      \\
      \Delta_l \given \vec{\alpha}, \Delta
      \\
      (\vec{\alpha}\ \vec{\alpha}_l, \Delta) \preceq \Omega 
      \\
      \tau_l \subtypes \tau_r \given \Omega 
      \\\\
      \forall \Omega' .\ (\vec{\alpha}\ \vec{\alpha}_l, \Delta) \preceq \Omega' \implies \tau_l \subtypes \tau_r \given \Omega' \implies \Omega' = \Omega
    } {
      \obj{EXI[}\vec{\alpha}_l\ \Delta_l \obj{]}\tau_l \subtypes \tau_r
      \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:proof_subtyping_refinement_introduction}
  Proof Subtyping (Refinement Intro)
  \hfill
  \boxed{\tau \subtypes \psi \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_{l} \subtypes \tau_{rl} \given \Omega 
      \\
      \Omega \preceq \Omega'
      \\
      \tau_{l} \subtypes \tau_{rr} \given \Omega' 
    } {
      \tau_l \subtypes \tau_{rl}\obj{\&}\tau_{rr} \given \Omega '
    }
    \\
    \inferrule {
      \vec{\alpha}_r \notfree \tau_l
      \\
      \Delta_r \given \vec{\alpha}, \Delta
      \\
      (\vec{\alpha}\ \vec{\alpha}_r, \Delta) \preceq \Omega 
      \\
      \tau_l \subtypes \tau_r \given \Omega 
      \\\\
      \forall \Omega' .\ (\vec{\alpha}\ \vec{\alpha}_r, \Delta) \preceq \Omega' \implies \tau_l \subtypes \tau_r \given \Omega' \implies \Omega' = \Omega
    } {
      \tau_l \subtypes \obj{ALL[}\vec{\alpha}_r\ \Delta_r \obj{]}\tau_r \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:proof_subtyping_variable_elimination}
  Proof Subtyping (Variable Elim)
  \hfill
  \boxed{\alpha \subtypes \tau \given \Omega} 
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \psi.\ \tau = \psi
      \\
      (\vec{\alpha}_\closed, \Delta\ \Delta_\closed) \preceq (\vec{\alpha}_\closed', \Delta')
      \\ 
      \alpha_\open \notin \vec{\alpha}_\closed
      \\\\
      \text{split}^-(\Delta[\alpha_\open\slash\tau]^{+} \backslash \Delta) = (\Delta_\closed, \Delta_\open)
      \\
      \Delta_\open \given \vec{\alpha}_\closed', \Delta'
    } {
      \alpha_\open \subtypes \tau \given (\vec{\alpha}_\closed', \Delta'\ \obj{;} \alpha\obj{<:}\tau) 
    }

    \inferrule {
      \nexists \psi.\ \tau_r = \psi
      \\
      \alpha_\closed \in \vec{\alpha}_\closed 
      \\
      \nexists \alpha.\ \tau_r = \alpha 
      \\\\
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau_r \safe
    } {
      \alpha_\closed \subtypes \tau_r
      \given (\vec{\alpha}_\closed, \Delta)
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_variable_introduction}
  Proof Subtyping (Variable Intro)
  \hfill
  \boxed{\tau \subtypes \alpha \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \phi.\ \tau = \phi
      \\
      (\vec{\alpha}_\closed, \Delta\ \Delta_\closed) \preceq (\vec{\alpha}_\closed', \Delta')
      \\ 
      \alpha_\open \notin \vec{\alpha}_\closed
      \\\\
      \text{split}^+(\Delta[\alpha_\open\slash\tau]^{-} \backslash \Delta) = (\Delta_\closed, \Delta_\open)
      \\
      \Delta_\open \given \vec{\alpha}_\closed', \Delta'
    } {
      \tau \subtypes \alpha_\open \given (\vec{\alpha}_\closed', \Delta'\ \obj{;} \tau\obj{<:}\alpha_\open) 
    }

    \inferrule {
      \nexists \phi.\ \tau_l = \phi
      \\
      \alpha_\closed \in \vec{\alpha}_\closed 
      % \\
      % \forall \alpha.\ \tau_l = \alpha \implies \alpha \in \vec{\alpha} 
      \\
      \nexists \alpha.\ \tau_l = \alpha 
      \\\\
      (\vec{\alpha}_\closed, \Delta) \entails \tau_l \subtypes \alpha_\closed \safe
    } {
      \tau_l \subtypes \alpha_\closed \given (\vec{\alpha}_\closed, \Delta) 
    }
  \end{mathpar}
\end{definition}
\hfill

\TODO{Note how free variables in interpreted type are marked as closed, to ensure a strict consistency check}

For an upper bound open variable $\alpha$, proof subtyping
finds a lenient interpretation of the variable and checks it against the lower bound.
If safe, it updates the worlds with the subtyping.
To find a lenient interpretation in simple constraints, it searches the world for 
the first upper bounds that are not closed variables. It also looks for relational
upper bounds of pattern type containing the open variable $\alpha$.
Additionally, it learns constraints on closed variables $\Delta^\dagger$ 
that are transitive upper bounds of the open variable $\alpha$.  

The dual of this rule is the one for a lower bound open variable, 
in the continued definition \ref{def:continued_proof_subtyping}.

For elimination of a union type, $\tau_{ll}\obj{|}\tau_{lr}$, proof subtyping
ensures that both parts of the assumed type subtype the guaranteed type.

For elimination of an existential type, $\obj{EXI[}\vec{\alpha}\ \Delta\obj{]}\tau_l$, proof subtyping 
infers necessary constraints over closed variables from the qualifiers $\Delta$ of the assumed existential type, 
which it leverages to prove the guaranteed type. 

For elimination of a least fixed point, $\obj{LFP[} \alpha \obj{]} \tau_l$, proof subtyping  
attempts a proof by induction, by unrolling the least fixed point
and replacing its self referencing variable with the upper bound.

For introduction of a difference type, $\tau_r \typdiff \eta$, proof subtyping,
checks that the assumed type subtypes the positive portion of the guaranteed type $\tau_r$
and does not subtype the subtracted portion $\eta$.
When relying on negation, one must be careful to preserve soundness.
We ensure that proof subtyping is complete for an upper bound of limited
form $\eta$ with no free type variables, which
means its negation is sound. We will make the limited notion
of completeness precise in section \ref{sect:correctness}.

For a lower bound closed variable $\alpha$, proof subtyping
finds a strict interpretation of the variable
and checks it against the upper bound. Since the subtyping constraints
may contain relational constraints, it factors the relational constraints
to find constraints over single variables, which it used to construct the strict
interpretation $\text{inter}(\vec{\tau})$.  

The dual of this rule is the one for an upper bound closed variable, 
in the continued definition \ref{def:continued_proof_subtyping}.



\hfill
\begin{definition} 
  \label{def:proof_subtyping_refinement_elimination}
  Proof Subtyping (Refinement Elim)
  \hfill
  \boxed{\psi \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_{l} \subtypes \kappa \given \Omega
    } {
      \tau_{l}\obj{\&}\tau_{r}  \subtypes \kappa \given \Omega 
    }

    \inferrule {
      \tau_{l} \subtypes \kappa \given \Omega 
    } {
      \tau_{l}\obj{\&}\tau_{r}  \subtypes \kappa \given \Omega 
    }

    \inferrule {
      \nexists \alpha .\ \tau_r = \alpha 
      \\
      \nexists \psi .\ \tau_r = \psi 
      \\\\
      \tau_l \subtypes \tau_r \given \Omega 
      \\
      \Omega \preceq \Omega' 
      \\
      \Delta_l \given \Omega' 
    } {
      \obj{ALL[}\vec{\alpha}_l\ \vec{\Delta}_l\obj{]}\tau_l
      \subtypes 
      \tau_r
      \given \Omega' 
    }
  \end{mathpar}
\end{definition}
\hfill

For a lower bound difference, $\tau_l \typdiff \eta$, proof subtyping
simply checks that the positive type subtypes
the upper bound union with the subtracted type. 

\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Proof Subtyping (Abstraction Intro)
  \hfill
  \boxed{\tau \subtypes \phi \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \kappa \subtypes \tau_{l} \given \Omega 
    } {
      \kappa \subtypes \tau_{l}\obj{|}\tau_{r} \given \Omega 
    }

    \inferrule {
      \kappa \subtypes \tau_{r} \given \Omega 
    } {
      \kappa \subtypes \tau_{l}\obj{|}\tau_{r} \given \Omega 
    }

    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha 
      \\
      \nexists \phi .\ \tau_l = \phi 
      \\\\
      \tau_l \subtypes \tau_r \given \Omega
      \\
      \Omega \preceq \Omega' 
      \\
      \Delta_r \given \Omega' 
    } {
      \tau_l
      \subtypes 
      \obj{EXI[}\vec{\alpha}_r\ \Delta_r \obj{]}\tau_r \given \Omega' 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_special_elimination}
  Proof Subtyping (Special Elim)
  \hfill
  \boxed{\theta \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l[\alpha\slash\tau_r] \subtypes \tau_r \given \Omega 
    } {
      \obj{LFP[}\alpha\obj{]}\tau_l \subtypes \tau_r \given \Omega 
    }

    \inferrule {
      \rho \subtypes \tau \obj{|} \eta \given \Omega
    } {
      \rho \typdiff \eta \subtypes \tau \given \Omega
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_special_intro}
  Proof Subtyping (Special Intro)
  \hfill
  \boxed{\tau \subtypes \theta \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \Omega \preceq \Omega'
      \\
      \Omega \entails \tau_l \circlearrowleft \obj{LFP[} \alpha \obj{]} \tau_r
      \\\\
      \tau_l \subtypes \tau_r[\alpha \slash \obj{LFP[} \alpha \obj{]} \tau_r]
      \given \Omega'
    } {
      \tau_l \subtypes \obj{LFP[} \alpha \obj{]}\tau_r \given \Omega'
    }

    \inferrule {
      % \TODO{prove that subtyping of diff is complete}
      % \\\\
      % \TODO{which implies that its negation is sound}
      % \\\\
      \tau \subtypes \rho \given \Omega 
      \\
      \text{FTV}(\eta) \subseteq \epsilon
      \\\\
      \nexists \Omega' .\  
      \Omega \preceq \Omega'
      \land
      \tau \subtypes \eta \given \Omega'
    } {
      \tau \subtypes \rho \typdiff \eta
      \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill



For introduction of an existential type, $\obj{EXI[}\vec{\alpha}\ \Delta\obj{]}\tau_r$, proof subtyping
infers constraints to witness the guaranteed existential type. 

The elimination counterpart of this rule is the elimination of a universal type (Rule \ref{def:continued_proof_subtyping}.?), 
in which proof subtyping infers constraints to instantiate assumed the universal type.

For an upper bound union, $\tau_{rl}\obj{|}\tau_{rr}$, 
proof subtyping checks that the left part of the union holds against
the lower bound. 

The dual of this rule is one for an upper bound intersection, 
in the continued definition \ref{def:continued_proof_subtyping}.

For an upper bound union type, $\tau_{rl}\obj{|}\tau_{rr}$, 
proof subtyping also checks that the right part of the union holds against
the lower bound. 

The dual of this rule is one for an upper bound intersection, 
in the continued definition \ref{def:continued_proof_subtyping}.


For an upper bound least fixed point, $\obj{LFP[} \alpha \obj{]} \tau_r$, 
where subtyping is decomposable, proof subtyping   
unrolls the least fixed point and checks it against the lower bound. 

For an upper bound least fixed point, $\obj{LFP[} \alpha \obj{]} \tau$, 
where the lower bound is a pattern type containing at least one closed variable,
proof typing searches the world for a constraint with a matching pattern type,
which provides a strict interpretation of the pattern type,
in the form of found constraint's upper bound.
It then checks that the strict interpretation of the pattern type holds.
For increased coverage, the system rewrites relational constraints
into equivalent normal forms.

This rule is the relational analog of the closed variable rules.

For an upper bound least fixed point, $\obj{LFP[} \alpha \obj{]} \tau$, 
where the lower bound is a pattern type whose variables are all open,
proof subtyping checks that the subtyping is consistent
and checks that a lenient interpretation of the pattern type's open variables
holds. If the subtyping is safe, then world is updated
with the subtyping constraint. 

This rule is the relational analog of the open variable rules.


\hfill
\begin{definition} 
  \label{def:closed_variable_safety_negative}
  Closed Variable Safety (Negative)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe}
  \\
  \begin{mathpar}

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \tau_l \obj{<:} \tau_r) \entails \alpha_\closed \subtypes \tau \safe
    }

    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\\\
      \exists \Omega .\ 
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \alpha_\closed \obj{<:} \tau_l) \entails \alpha_\closed \subtypes \tau_r \safe
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:closed_variable_safety_positive}
  Closed Variable Safety (Positive)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \tau \subtypes \alpha_\closed \safe}
  \\
  \begin{mathpar}

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \tau \subtypes \alpha_\closed \safe
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \tau_l \obj{<:} \tau_r) \entails \alpha_\closed \subtypes \tau \safe
    }

    \inferrule {
      \nexists \alpha .\ \tau_r = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\\\
      \exists \Omega .\ 
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;}  \tau_r \obj{<:} \alpha_\closed) \entails \tau_l \subtypes \alpha_\closed \safe
    }
  \end{mathpar}
\end{definition}
\hfill













\section{Correctness}
\label{sect:correctness}

\TODO{introduce model typing and soundness properties}

\hfill
\begin{definition}
  \label{def:model_typing}
  Model Typing
  \hfill
  \boxed{\vec{\delta}, \Gamma \satisfies e \hastype \tau}
  \\
  \begin{mathpar}
    \inferrule { 
      \alpha \slash \tau \in \vec{\delta}
      \\
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \alpha 
    } 

    \inferrule { 
      \alpha \slash \tau \notin \vec{\delta}
      \\
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{TOP} 
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \alpha 
    } 

    \inferrule { 
    } {
      \vec{\delta}, \Gamma \satisfies \obj{@} \hastype \obj{@}
    } 

    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } {
      \vec{\delta}, \Gamma \satisfies \obj{<$l$>$e$} \hastype \obj{<$l$>$\tau$}
    } 

    \inferrule { 
      \obj{?$l$=>$v$} \in G 
      \\
      \vec{\delta}, \Gamma \satisfies v \hastype \tau 
      \\\\
      \forall v' .\ \obj{?$l$=>$v'$} \in G \implies v' = v
    } {
      \vec{\delta}, \Gamma \satisfies G \hastype \obj{$l$->$\tau$}
    } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ORIGINAL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \inferrule { 
    %   F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    %   \\
    %   \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_l
    %   \\
    %   \vec{\delta}, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    % } {
    %   \vec{\delta}, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ALTERNATIVE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \inferrule { 
      \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_p
      \\
      \vec{\delta}, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
      \\\\
      \forall e .\ 
        \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
        \implies
        \vec{\delta}, \Gamma \satisfies e \hastype \tau_p 
        \land
        (\forall \tau_n\ \tau .\ \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_n$->$\tau$} \implies \neg (\vec{\delta}, \Gamma \satisfies e \hastype \tau_n))
    } {
      \vec{\delta}, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \inferrule { 
      \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    } {
      \vec{\delta}, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DERIVABLE??
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \inferrule { 
    %   \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_n$->$\tau_r$}
    %   \\
    %   \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_p
    %   \\
    %   \vec{\delta}, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    %   \\\\
    %   \forall e .\ 
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
    %     \implies
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_p 
    %     \lor
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_n 
    % } {
    %   \vec{\delta}, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % } 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_l$}
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_l$|$\tau_r$}
    } 

    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_r$}
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_l$|$\tau_r$}
    } 

    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_l$}
      \\
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_r$}
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_l$\&$\tau_r$}
    } 

    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_l
      \\
      \neg\ (\vec{\delta}, \Gamma \satisfies e \hastype \tau_r)
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_l \typdiff \tau_r
    } 

    \inferrule { 
      \vec{\delta} \sqcup \vec{\delta}' \satisfies Q
      \\
      \vec{\delta} \sqcup \vec{\delta}' \satisfies e \hastype \tau
    } {
      \vec{\delta} \satisfies e \hastype \obj{EXI[$\Alpha$ $Q$]$\tau$}
    } 

    \inferrule { 
      \forall \vec{\delta}' .\ \vec{\delta} \sqcup \vec{\delta}' \satisfies Q \implies 
      \vec{\delta} \sqcup \vec{\delta}', \Gamma \satisfies e \hastype \tau
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{ALL[$\Alpha$ $Q$]$\tau$}
    } 

    \inferrule { 
      \vec{\delta} \ \alpha \slash \obj{LFP[$\alpha$]$\tau$} \satisfies e \hastype \tau
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{LFP[$\alpha$]$\tau$}
    } 



    \inferrule { 
      x \hastype \tau \in \Gamma 
    } {
      \vec{\delta}, \Gamma \satisfies x \hastype \tau 
    } 

    \inferrule { 
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
      \\
      e[\vec{\sigma}] \rightsquigarrow e'[\vec{\sigma}']
      \\
      \vec{\delta}, \vec{\sigma}' \satisfies \Gamma' 
      \\
      \vec{\delta}, \Gamma' \satisfies e' \hastype \tau 
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    } 

  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition}\boxed{\vec{\delta} \satisfies \tau <: \tau}\ Model Subtyping
  \label{def:model_subtyping}
  \begin{mathpar}
    \inferrule { 
      \forall e\ \Gamma .\ 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_l \implies 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_r 
    } {
      \vec{\delta} \satisfies \tau_l <: \tau_r
    } 
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\vec{\delta} \satisfies Q}\ Model Sequence Subtyping
  \label{def:model_sequence_subtyping}
  \begin{mathpar}
    \inferrule { 
    } {
      \vec{\delta} \satisfies \epsilon 
    } 

    \inferrule { 
      \vec{\delta} \satisfies Q
      \\
      \vec{\delta} \satisfies \tau_l <: \tau_r
    } {
      \vec{\delta} \satisfies Q\ \obj{.$\tau_l$<:$\tau_r$}
    } 
  \end{mathpar}
\end{definition}


\section{Experiments}

\TODO{develop 12 tree/list experiments}

\section{Related work}

\TODO{...}


% \paragraph{Tree interpolation}
% Exemplified by CHC duality solver.

% \paragraph{Hindley-Milner type inference}
% Exemplified by ML.

% \paragraph{Logic programming.}
% Exemplified by Prolog. 


% Similar: both have backchaining. 

% Different: RLT is fully declarative, lacks negations, but has implication. 

% Different: RLT allows comparing inductive relations via subtyping. 

% \paragraph{Semantic subtyping.} 
% Exemplified by XDuce and CDuce. complete subtyping.

% Similar: set-like combinators: union and intersection.

% Different: RLT uses rigid syntactic rules; incomplete subtyping.

% % set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% % semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
% The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
% "semantics subtyping" means the semantics of types is determined indirectly by the semantics of another structure.
% "syntactic subtyping" means the semantics of types is determined directly by the type structure

% \paragraph{Extrinsic typing.}
% Exemplified by Typescript, which is unsound. Maybe not as lenient?  
% The static behavior of a program is not necessarily specified/prescribed; 
% it may be over-approximated from the program composition. 
% Intrinsic vs extrinsic is orthogonal to static vs dynamic, although static and dynamic are often used to mean the former.
% All modern languages use a combination of static and dynamic type checking.
% The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
% even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.

% \paragraph{Refinement Types.}
% Exemplified by Refinement ML. Base types with intersections and subtyping.

% \paragraph{Predicate Subtyping.}
% Exemplified by Liquid Types. An extension of refinement types.

% Similar: both use type inference to infer expressive relational properties. 

% Different: RLT starts with an invalid post-condition, then weakens return type to a valid post-condition from outside in by expanding unions.

% Different: RLT starts with an invalid pre-condition, then strengthens parameter type to a valid pre-condition from inside out by adding intersections.

% Different: Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.


% \paragraph{Abstraction Refinement.} 
% Similar: type unification over subtyping resembles abstraction refinement  
% where solving for variables and failing on different sides of the subtyping relation corresponds to
% solving with the abstractor vs solving with the refiner.

% \paragraph{Craig interpolation.} 
% Similar: extracting an inductive type with unions and intersections 
% from a recursive program without needing to specify a predicate universe might be similar to
% craig interpolation.

% \paragraph{PDR.}
% exemplified by IC3. 

% Similar: RLT infers abstract type for return type, 
% then safely constrains the variables in previous step (fix's antecedent) 
% to subtype the least fixed point.
% This lazily propagates the type for the last step to the previous steps.
% This is safe as antecedent is stronger than consequent at any step.
% Seems similar to the notion in PDR of propagating negation of loss points to previous steps. 

% Different: RLT isn't cartesian

\section{Future Work}
\label{sect:future_work}

Relational reasoning.

\hfill
\begin{definition} 
  \label{def:relational_proof_typing}
  Rel Proof Typing (Loop)
  \hfill 
  \boxed{\Gamma \entails e \hastype \tau \given \Omega}
  \\
  \begin{mathpar}

    \inferrule {
      \Gamma \entails e \hastype \alpha_\nu\obj{->}\tau \given  \vec{\alpha}, \Delta 
      \\\\
      \forall \vec{\alpha}'\ \Delta' .\ 
        \vec{\alpha}', \llbracket \epsilon, \vec{\alpha}\ \vec{\alpha}' \entails \Delta', \alpha_l \obj{->} \alpha_r \rrbracket^+ \in \vec{\pi}_\nu
      \implies
      \tau \subtypes \alpha_l\obj{->}\alpha_r \given  \vec{\alpha}\ \vec{\alpha}', \Delta\ \Delta' 
      \\\\
      \exists \pi.\ \pi \in \vec{\pi}_\nu
      \\
      \alpha_\nu \downarrow \vec{\pi}_\nu
      \fallingdotseq 
      \alpha_\mu \uparrow \vec{\pi}_\mu
      \\
      \text{pack}^-(\text{FTV}(\Gamma)\ \vec{\alpha}\ \alpha_\mu \entails \vec{\pi}_\mu) = \tau_\mu
    } {
      \Gamma \entails \obj{loop(}e\obj{)} 
      \hastype 
      \obj{ALL[}\alpha_x \obj{]}
      \alpha_x
      \obj{->} 
      \obj{EXI[}\alpha_y 
          \obj{;} \alpha_x \obj{*} \alpha_y 
      \obj{<:LFP[} \alpha_\mu \obj{]}\tau_\mu
      \obj{]}\alpha_y
      \given \vec{\alpha}, \Delta 
    }

  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:proof_subtyping_implication_rewriting}
  Rel Proof Subtyping (Implication Rewriting)
  \hfill
  \boxed{\tau \subtypes \tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \tau_l \subtypes
      \obj{ALL[}\alpha\obj{;} \alpha \obj{<:} \tau_\mu \obj{]} \alpha \obj{->} \tau_r
      \given \Omega
    } {
      \tau_l
      \subtypes 
      \obj{LFP[}\alpha_\mu\obj{]}\tau_\mu\obj{->}\tau_r
      \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Rel Proof Subtyping (Pattern Intro)
  \hfill 
  \boxed{\rho \subtypes \obj{LFP[}\alpha\obj{]}\tau \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \rho \subtypes \obj{LFP[}\alpha\obj{]}\tau \cong \rho' \subtypes \obj{LFP[}\alpha \obj{]} \tau'
      \\
      \Delta \entails \rho' \subtypes \tau_n \sim 
      \\\\
      (\vec{\alpha}, \Delta) \preceq \Omega
      % \\
      % \exists \alpha .\ \alpha \in \text{FTV}(\rho) \land \alpha \in \vec{\alpha} 
      \\
      \tau_n \subtypes \obj{LFP[}\alpha \obj{]} \tau' \entails \Omega
    } {
      \rho \subtypes \obj{LFP[}\alpha\obj{]}\tau
      \given \Omega 
    }

    \inferrule {
      \entails \rho \subtypes \obj{LFP[}\alpha\obj{]}\tau \consis 
      \\
      \forall \alpha_\closed .\ 
      \alpha_\closed \in \text{FTV}(\rho) \land \alpha_\closed \in \vec{\alpha}_\closed
      \implies
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \wr \rho \subtypes \obj{LFP[}\alpha\obj{]}\tau \safe
      \\\\
      \exists \Delta_i .\ \llbracket \epsilon, \vec{\alpha} \entails \Delta, \rho\rrbracket^+ = \Delta_i, \rho'
      \\
      (\vec{\alpha}, \Delta) \preceq (\vec{\alpha}', \Delta')
      \\
      \rho' \subtypes \obj{LFP[}\alpha\obj{]}\tau
      \given \vec{\alpha}', \Delta'
    } {
      \rho \subtypes \obj{LFP[}\alpha\obj{]}\tau
      \given \vec{\alpha}', \Delta'\ \obj{;} \rho \obj{<:} \obj{LFP[}\alpha\obj{]}\tau
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:rel_closed_variable_safety_negative}
  Rel Closed Variable Safety (Negative)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe}
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\
      \exists \Omega .\ 
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \alpha_\closed \obj{<:} \tau_l) \entails \alpha_\closed \subtypes \tau_r \safe
    }

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \subtypes \tau \safe
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \tau_l \obj{<:} \tau_r) \entails \alpha_\closed \subtypes \tau \safe
    }

    \inferrule {
      \alpha_\closed \in \text{FTV}(\rho)
      \\
      \rho \subtypes \tau \factorsinto \alpha_\closed \subtypes \tau' 
      \\
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \alpha_\closed \obj{<:} \tau') \entails \alpha_\closed \subtypes \tau'' \safe
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \rho \obj{<:} \tau) \entails \alpha_\closed \subtypes \tau'' \safe
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:relational_key_safety_negative}
  Relational Key Safety (Negative)
  \hfill
  \boxed{(\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \wr \rho \subtypes \tau \safe}
  \\
  \begin{mathpar}
    \inferrule {
      \nexists \alpha .\ \tau_l = \alpha \land \alpha \notin \vec{\alpha}_\closed
      \\
      \forall \tau_r .\
      \rho \subtypes \tau \factorsinto \alpha_\closed \subtypes \tau_r
      \implies
      \exists \Omega .\  
      (\vec{\alpha}_\closed, \Delta) \preceq \Omega \land
      \tau_l \subtypes \tau_r \given \Omega 
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \alpha_\closed \obj{<:} \tau_l) 
      \entails 
      \alpha_\closed  \wr \rho \subtypes \tau \safe
    }

    \inferrule {
      (\vec{\alpha}_\closed, \Delta) \entails \alpha_\closed \wr \rho \subtypes \tau \safe
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \tau_l \obj{<:} \tau_r) 
      \entails
      \alpha_\closed  \wr \rho \subtypes \tau \safe
    }

    \inferrule {
      \alpha_\closed \in \text{FTV}(\rho)
      \\
      \rho \subtypes \tau \factorsinto \alpha_\closed \subtypes \tau' 
      \\\\
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \alpha_\closed \obj{<:} \tau') \entails \alpha_\closed \wr \rho' \subtypes \tau'' \safe
    } {
      (\vec{\alpha}_\closed, \Delta\ \obj{;} \rho \obj{<:} \tau) \entails \alpha_\closed \wr \rho' \subtypes \tau'' \safe
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:relational_constraint_factorization}
  Relational Constraint Factorization 
  \hfill
  \boxed{\rho \subtypes \tau \factorsinto \alpha \subtypes \tau'}
  \\
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \rho \subtypes \tau \factorsinto \alpha \subtypes \tau' 
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:proof_subtyping_abstraction_introduction}
  Rel Proof Subtyping (Abstraction Intro)
  \hfill
  \boxed{\tau \subtypes \phi \given \Omega}
  \\
  \begin{mathpar}
    \inferrule {
      \rho \subtypes \tau_{l} \given \Omega 
    } {
      \rho \subtypes \tau_{l}\obj{|}\tau_{r} \given \Omega 
    }

    \inferrule {
      \rho \subtypes \tau_{r} \given \Omega 
    } {
      \rho \subtypes \tau_{l}\obj{|}\tau_{r} \given \Omega 
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}
  \label{def:rel_interpretation}
  Rel Interpretation  (Negative)
  \hfill
  \boxed{\llbracket \Delta, \alpha \rrbracket^- = (\Delta, \tau)}
  \\
  \begin{mathpar}
    \inferrule {
      \neg(\Delta \entails \alpha \relational)
      \\
    } {
      \llbracket \epsilon, \alpha \rrbracket^- = (\epsilon, \obj{TOP})
    }

    \inferrule {
      \neg(\Delta \entails \alpha \relational)
      \\
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau')
    } {
      \llbracket \Delta\ \obj{;}\alpha  \obj{<:} \tau, \alpha \rrbracket^- = (\Delta', \tau' \obj{\&} \tau)
    }

    \inferrule {
      \alpha \neq \tau_l
      \\
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau)
    } {
      \llbracket \Delta\ \obj{;}\tau_l \obj{<:} \tau_r, \alpha \rrbracket^- = (\Delta'\ \obj{;}\tau_l \obj{<:} \tau_r, \tau)
    }

    \inferrule {
      \Delta \entails \alpha \relational
    } {
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta, \alpha)
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}
  \label{def:relational_constraint_key}
  Relational Constraint Key
  \hfill
  \boxed{\Delta \entails \alpha \relational}
  \\
  \begin{mathpar}
    \inferrule {
      \obj{;} \tau_l \obj{<:} \tau_r \in \Delta 
      \\
      \nexists \alpha' .\ \tau_l = \alpha'
      \\
      \alpha \in \text{FTV}(\tau_l)
    } {
      \Delta \entails \alpha \relational
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition}
  \label{def:decomposable}
  Decomposable 
  \\\\
  \boxed{\Omega \entails \tau \circlearrowleft \tau}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      % \text{decomposable}(\Delta_0, \tau_l, \obj{LFP[} \alpha \obj{]} \tau_r)
      \Omega \entails \tau \circlearrowleft \tau
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}\boxed{\tau \subtypes \tau \cong \tau \subtypes \tau}\ Normal Constraint Congruence 
  \label{def:normal_constraint_congruence}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \tau \subtypes \tau \cong \tau \subtypes \tau
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition}\boxed{\Delta \entails \tau' \subtypes \tau \sim}\ Normal Constraint Entailment  
  \label{def:normal_constraint_entailment}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \Delta \entails \tau' \subtypes \tau \sim
    }
  \end{mathpar}
\end{definition}
\hfill


\section{Appendix}
\label{sect:appendix}
\begin{definition} Internals 
  \label{def:internals}
  \[\begin{array}[t]{r@{}l}
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ x : \tau
    \\
    \\
    \nonterm{\vec{\Omega}} & \is \epsilon \sep \vec{\Omega}\ \Omega
    \\
    \nonterm{\Omega} & \is \vec{\alpha}, \Delta
    \\
    \\
    \nonterm{\vec{\tau}} & \is \epsilon \sep \vec{\tau}\ \tau
    \\
    \nonterm{\vec{\phi}} & \is \epsilon \sep \vec{\phi}\ \phi
    \\
    \\
    \nonterm{\vec{\pi}} & \is \epsilon \sep \vec{\pi}\ \pi
    \\
    \nonterm{\pi} & \is \vec{\alpha}, \Delta, \tau \obj{->} \tau
    \\
    \\
    \nonterm{\vec{\delta}} & \is \epsilon \sep \vec{\delta}\ \delta
    \\
    \nonterm{\delta} & \alpha \slash \tau
  \end{array}\]
\end{definition}


\begin{definition} Sugared Expressions 
  \label{def:sugared_expressions}
  \[\begin{array}[t]{r@{}l}
    \nonterm{e} & \is 
    \begin{array}[t]{@{}l}
      ... \sep
      e\obj{,}e \sep
      e\obj{|>}e \sep
      \obj{let}\ x\ z\ \obj{=}\ e\ \obj{in}\ e \sep
      \obj{(}e\obj{)}
    \end{array}
    \\
    \nonterm{z} & \is \epsilon \sep \obj{:}\tau 
    \\
    \nonterm{p} & \is 
      ... \sep
      p\obj{,}p \sep
      \obj{(}p\obj{)} 
  \end{array}\]
\end{definition}

\begin{definition} Values 
  \label{def:others}
  \[\begin{array}[t]{r@{}l}
    \nonterm{v} & \is 
      \obj{@} \sep
      \obj{<$l$> $v$} \sep
      \vec{g} \sep
      \obj{$v$,$v$} \sep
      \obj{($v$)} \sep
      \vec{f} 
    \\
    \nonterm{\vec{g}} & \is \epsilon \sep \vec{g}\ g
    \\
    \nonterm{g} & \is \obj{?$l$=>$v$}
    \\
    \\
    \nonterm{\vec{\sigma}} & \is \epsilon \sep \vec{\sigma}\ \sigma
    \\
    \nonterm{\sigma} & \is x \slash v
  \end{array}\]
\end{definition}


\begin{definition}\boxed{e \rightsquigarrow e}\ Sugared Progression
  \begin{mathpar}
    \inferrule {
      e_b \obj{(} e_a \obj{)} \rightsquigarrow e' 
    } {
      e_a \obj{|>} e_b \rightsquigarrow e' 
    }

    \inferrule {
      e \rightsquigarrow e' 
    } {
      \obj{(} e \obj{)} \rightsquigarrow e' 
    }

    \inferrule {
      \obj{?left=>} e_l\ \obj{?right=>} e_r \rightsquigarrow e' 
    } {
      e_l\obj{,}e_r \rightsquigarrow e' 
    }

    \inferrule {
      \obj{(? <true> @=>}e_t \obj{\ ? <false> @=>}e_f \obj{)(}e_c\obj{)} \rightsquigarrow e'
    } {
      \obj{if}\ e_c\ \obj{then}\ e_t\ \obj{else}\ e_f \rightsquigarrow e' 
    }


    \inferrule {
      \obj{(?} x \obj{=>} e_k \obj{)(} e \obj{)}
      \rightsquigarrow e'
    } {
      \obj{let}\ x \obj{:} \tau\ \obj{=}\ e\ \obj{in}\ e_k \rightsquigarrow e'
    }

    % \inferrule {
    %   e \rightsquigarrow e'
    % } {
    %   \obj{let $x$:$\tau$ = $e$ in $e_k$} \rightsquigarrow \obj{let $x$:$\tau$ = $e'$ in $e_k$}
    % }

    % \inferrule {
    % } {
    %   \obj{let $x$:$\tau$ = $v$ in $e$} \rightsquigarrow e[x \slash v]
    % }
  \end{mathpar}
\end{definition}

\begin{definition} Sugared Types 
  \label{def:sugared_types}
  \[\begin{array}[t]{r@{}l}
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      ... \sep
      \obj{TOP} \sep 
      \obj{BOT} \sep
      \obj{(}\tau\obj{)}

    \end{array}
    \\
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      ... \sep
      \obj{(}\phi\obj{)}

    \end{array}
  \end{array}\]
\end{definition}

\begin{definition} 
  \label{def:type_interpretation}
  Type Interpretation 
  \\\\
  \boxed{
    \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau)
  }
  \\
  \begin{mathpar}
    \inferrule {
      \alpha \notin \vec{\alpha}_\local
      \\
      \alpha \notin \vec{\alpha}_\closed
      \\
      \llbracket \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
    }

    \inferrule {
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \obj{@} \rrbracket^\pm = (\Delta, \obj{@})
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \obj{<}l\obj{>}\tau \rrbracket^\pm = (\Delta', \obj{<}l\obj{>}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, l\obj{->}\tau \rrbracket^\pm = (\Delta', l\obj{->}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^\pm = (\Delta_r, \tau_r')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^{\text{flip}(\pm)} = (\Delta_l, \tau_l')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l\obj{->}\tau_r \rrbracket^\pm = (\Delta_l \cap \Delta_r, \tau_l'\obj{->}\tau_r')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^\pm = (\Delta_l, \tau_l')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^{\pm} = (\Delta_r, \tau_r')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l\obj{|}\tau_r \rrbracket^\pm = (\Delta_l \cap \Delta_r, \tau_l'\obj{|}\tau_r')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
      \\\\
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^{\pm} = (\Delta'', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \obj{EXI[}\vec{\alpha}\ \Delta_q \obj{]} \tau \rrbracket^\pm 
      = 
      (\Delta' \cap \Delta'', \obj{EXI[}\vec{\alpha}\ \Delta_q' \obj{]}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^{\pm} = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \obj{LFP[}\alpha \obj{]} \tau \rrbracket^\pm 
      = 
      (\Delta', \obj{LFP[}\alpha \obj{]}\tau')
    }

    \\

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^\pm = (\Delta_l, \tau_l')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^{\pm} = (\Delta_r, \tau_r')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l\obj{\&}\tau_r \rrbracket^\pm = (\Delta_l \cap \Delta_r, \tau_l'\obj{\&}\tau_r')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
      \\\\
      \llbracket \vec{\alpha}_\local \cup \vec{\alpha}, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^{\pm} = (\Delta'', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \obj{ALL[}\vec{\alpha}\ \Delta_q \obj{]} \tau \rrbracket^\pm 
      = 
      (\Delta' \cap \Delta'', \obj{ALL[}\vec{\alpha}\ \Delta_q' \obj{]}\tau')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \rrbracket^\pm = (\Delta', \tau')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau \typdiff \eta \rrbracket^\pm 
      = (\Delta', \tau' \typdiff \eta)
    }
  \end{mathpar}
\end{definition}

\begin{definition} 
  \label{def:Qualification_interpretation}
  Qualification Interpretation 
  \\\\
  \boxed{
    \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \Delta_q \rrbracket^\pm = (\Delta', \Delta_q')
  }
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \epsilon \rrbracket^\pm = (\Delta', \epsilon')
    }

    \inferrule {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \Delta_q\rrbracket^\pm = (\Delta', \Delta_q')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_r \rrbracket^\pm = (\Delta_l, \tau_r')
      \\\\
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \tau_l \rrbracket^{\text{flip}(\pm)} = (\Delta_r \tau_l')
    } {
      \llbracket \vec{\alpha}_\local, \vec{\alpha}_\closed \entails \Delta, \Delta_q\ \obj{;} \tau_l \obj{<:} \tau_r \rrbracket^\pm = (\Delta' \cap \Delta_l \cap \Delta_r, \Delta_q'\ \obj{;} \tau_l' \obj{<:} \tau_r')
    }

  \end{mathpar}
\end{definition} 


\hfill
\begin{definition} 
  \label{def:pruning_interpretation}
  Pruning Interpretation 
  \\\\
  \boxed{
    \llbracket \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
  }
  \\
  \begin{mathpar}
    \inferrule {
      \forall \tau_l\ \tau_r .\ \obj{;} \tau_l \obj{<:} \tau_r \in \Delta' \iff \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r 
      \\
      \llbracket \Delta\backslash\Delta', \alpha \rrbracket^\pm = (\Delta', \tau)
    } {
      \llbracket \vec{\alpha}_\closed \entails \Delta, \alpha \rrbracket^\pm = (\Delta', \tau)
    }
  \end{mathpar}
\end{definition}
\hfill

\hfill
\begin{definition} 
  \label{def:indirection}
  Indirection  
  \\\\
  \boxed{
    \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^\pm \tau_l \subtypes \tau_r 
  }
  \\
  \begin{mathpar}
    \inferrule {
      \obj{;}\alpha\obj{<:}\tau \in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \obj{;}\alpha'\obj{<:}\tau' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^- \alpha \subtypes \tau
    }

    \inferrule {
      \obj{;}\alpha\obj{<:}\tau \in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \obj{;}\alpha'\obj{<:}\tau' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^- \alpha' \subtypes \tau'
    }
    \\
    \inferrule {
      \obj{;}\tau \obj{<:} \alpha\in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \obj{;}\tau'\obj{<:} \alpha' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^+ \tau \subtypes \alpha
    }

    \inferrule {
      \obj{;}\tau \obj{<:} \alpha\in \Delta 
      \\
      \alpha' \in \text{FTV}(\tau)
      \\
      \obj{;}\tau'\obj{<:} \alpha' \in \Delta 
    } {
      \vec{\alpha}_\bullet, \Delta, \alpha \looparrowright^+ \tau' \subtypes \alpha'
    }
  \end{mathpar}
\end{definition}
\hfill


\hfill
\begin{definition} 
  \label{def:interpretation}
  Interpretation
  \\\\
  \boxed{
    \llbracket\Delta, \alpha \rrbracket^\pm = (\Delta, \tau)
  }
  \\
  \begin{mathpar}
    \inferrule {
    } {
      \llbracket \epsilon, \alpha \rrbracket^- = (\epsilon, \obj{TOP})
    }

    \inferrule {
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau')
    } {
      \llbracket \Delta\ \obj{;}\alpha  \obj{<:} \tau, \alpha \rrbracket^- = (\Delta', \tau' \obj{\&} \tau)
    }

    \inferrule {
      \alpha \neq \tau_l
      \\
      \llbracket \Delta, \alpha \rrbracket^- = (\Delta', \tau)
    } {
      \llbracket \Delta\ \obj{;}\tau_l \obj{<:} \tau_r, \alpha \rrbracket^- = (\Delta'\ \obj{;}\tau_l \obj{<:} \tau_r, \tau)
    }
    \\
    \inferrule {
    } {
      \llbracket \epsilon, \alpha \rrbracket^+ = (\epsilon, \obj{BOT})
    }

    \inferrule {
      \llbracket \Delta, \alpha \rrbracket^+ = (\Delta', \tau')
    } {
      \llbracket \Delta\ \obj{;} \tau \obj{<:} \alpha  , \alpha \rrbracket^+ = (\Delta', \tau' \obj{|} \tau)
    }

    \inferrule {
      \alpha \neq \tau_r
      \\
      \llbracket \Delta, \alpha \rrbracket^+ = (\Delta', \tau)
    } {
      \llbracket \Delta\ \obj{;}\tau_l \obj{<:} \tau_r, \alpha \rrbracket^+ = (\Delta'\ \obj{;}\tau_l \obj{<:} \tau_r, \tau)
    }
  \end{mathpar}
  \TODO{soundess: $\llbracket \Delta, \alpha \rrbracket^- \subtypes (\Delta', \tau) \implies \Delta' \satisfies \alpha <: \tau$}

  \TODO{soundess: $\llbracket \Delta, \alpha \rrbracket^- \subtypes (\Delta', \tau) \implies \Delta \satisfies \Delta'$}
\end{definition}
\hfill


\begin{definition}\boxed{\text{pack}^\pm(\vec{\alpha}, \vec{\alpha}, \Delta \entails \tau) = \tau} Type Packaging 

  \TODO{update}

  \begin{mathpar}
    \inferrule {
      \text{FTV}(\tau) = \vec{\alpha}_p
      \\
      \Delta \entails \vec{\alpha}_f\ \vec{\alpha}_c\ \vec{\alpha}_p \pitchfork \Delta' 
      \\\\
      \vec{\alpha}_f, \vec{\alpha}_c, \Delta' \entails \Delta_o \wr \Delta_i 
      \\\\
      (\text{FTV}(\Delta)\ \vec{\alpha}_p)\ \diamond\ \vec{\alpha}_c = \vec{\alpha}_o 
      \\
      (\text{FTV}(\Delta_i)\ \vec{\alpha}_p)\ \backslash\ \vec{\alpha}_c \ \backslash\ \vec{\alpha}_f = \vec{\alpha}_i 
      \\\\
      \text{quantify}^{\pm}(\vec{\alpha}_o, \Delta_o, \vec{\alpha}_i, \Delta_i, \tau) = \tau'
    } {
      \vec{\alpha}_f, \vec{\alpha}_c, \Delta \entails \tau \cong^{\pm} \tau'
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\text{pack}^\pm(\vec{\alpha} \entails \vec{\pi}) = \vec{\tau}}\ Multiple Type Packaging 
  \label{def:multiple_type_packaging}

  \TODO{update}

  \begin{mathpar}
    \inferrule {
    } {
      \vec{\alpha}_f \entails \epsilon \cong^\pm \epsilon 
    }

    \inferrule {
      \vec{\alpha}_f \entails \vec{\pi} \cong^\pm \vec{\tau} 
      \\
      \vec{\alpha}_f, \vec{\alpha}_c, \Delta \entails \tau \cong^\pm \tau'
    } {
      \vec{\alpha}_f \entails \vec{\pi}\ \left<\vec{\alpha}_c, \Delta, \tau \right> \cong^\pm \vec{\tau}\ \tau' 
    }
  \end{mathpar}
\end{definition}



\begin{definition}\boxed{\vec{\alpha} \entails \Delta \wr \vec{\alpha} \given \vec{\delta}}\ Modulo Type Solution  
  \label{def:modulo_type_solution}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \vec{\alpha} \entails \Delta \wr \vec{\alpha} \given \vec{\delta}
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\entails \tau_l \subtypes \tau \consis}\ Constraint Consistency  
  \label{def:constraint_consistency}
  \begin{mathpar}
    \inferrule {
      \TODO{...}
    } {
      \entails \tau_l \subtypes \obj{LFP[}\alpha\obj{]}\tau_r \consis 
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta[\alpha\slash\tau]^\pm = \Delta}\ Polar Subtyping Environment Substitution 
  \label{def:polar_subtyping_environment_substitution}
  \TODO{...}
  \begin{mathpar}
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\tau[\alpha\slash\tau]^\pm = \tau}\ Polar Type Substitution 
  \label{def:polar_type_substitution}
  \TODO{...}
  \begin{mathpar}
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\text{skolem}(\Delta) = (\Delta, \Delta)}\ Skolem Subtyping Separation 
  \label{def:skolem}
  \TODO{...}
  \begin{mathpar}
  \end{mathpar}
\end{definition}




\begin{definition} \boxed{\Alpha \notfree \tau}\ Fresh variables 
  \label{def:fresh_variables}
  \begin{mathpar}
    \inferrule {
      \forall \alpha .\ \alpha \in \Alpha \implies \alpha \notin \text{FV}(\tau)
    } {
      \Alpha \notfree \tau
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\tau \subtypes \tau \given Z}\ (Proof universe subtyping)
  \label{def:proof_universe_subtyping}
  \begin{mathpar}
    \inferrule {
      \left< M, \Delta \right> \in Z 
      \\
      \forall  M\ \Delta .\  
      \tau_l \subtypes \tau_r \given M, \Delta 
      \iff
      \left< M, \Delta \right> \in Z 
    } {
      \tau_l \subtypes \tau_r \given Z 
    }

  \end{mathpar}
\end{definition}

\begin{definition}\boxed{Q \given M, \Delta}
  \begin{mathpar}
    \inferrule {
      Q \given M_0, \Delta_0
      \\
      M_0 \preceq M_1
      \\
      \Delta_0 \preceq \Delta_1
      \\
      \tau_l \subtypes \tau_r \given M_1, \Delta_1
    } {
      Q \obj{.$\tau_l$<:$\tau_r$}
      \given
      M_1, \Delta_1
    }

    \inferrule {
    } {
      M, \Delta \entails \epsilon
    }
  \end{mathpar}
\end{definition}

\begin{definition}(Collection)
  \[\begin{array}[t]{r@{}l}
    \nonterm{C} & \is \epsilon \sep C\ c
  \end{array}\]
\end{definition}
\begin{definition}\boxed{C\ C = C}\ Concatenation
  \[\begin{array}{rclr}
    C\ \epsilon 
    &=& 
    C
    & \C{empty} 
    \\

    C\ (C'\ c) 
    &=& 
    (C\ C')\ c
    & \C{step} 
    \\
  \end{array}\]
\end{definition}

\begin{definition}\boxed{C \diamond  C = C}\ Filter
  \[\begin{array}{rclr}
    C \diamond \epsilon 
    &=& 
    \epsilon 
    % & \C{empty} 
    \\

    C \diamond (C'\ c) 
    &=& 
    \begin{cases}
      (C \diamond C')\ c & \text{if } c \in C\\
      (C \diamond C') & \text{otherwise}
    \end{cases}
    % & \D{Step} 
    \\
  \end{array}\]
\end{definition}

% \begin{definition}\boxed{\widebar{\ c\ }^{\vec{t}[P]} \circeq C}\ Comprehension 
%   \begin{mathpar}
%     \inferrule {
%       \forall 
%     } {
%       \widebar{\ c\ }^{A[P]} \circeq C
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{\text{map}(C, t) = C}
%   \[\begin{array}{rclr}
%     \text{map}(\epsilon, t)
%     &=& 
%     \epsilon
%     & \C{empty} 
%     \\

%     \text{map}(C\ c, t)
%     &=& 
%     \text{map}(C, t) \sqcup t(c)
%     & \C{step} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{\widebar{\ c\ }^{c \in C} \circeq C}\ Map sugar 
%   \[\begin{array}{rclr}
%     \widebar{\ c'\ }^{c \in C} 
%     &\circeq& 
%     \text{map}(C, \lambda c . c')
%     % & \C{comprehension} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{c \in C}\ Collection Containment
%   \begin{mathpar}
%     \inferrule {
%       c \notin C
%     } {
%       c \in C\ c 
%     }

%     \inferrule {
%       c \in C
%     } {
%       c \in C\ c' 
%     }
%   \end{mathpar}
% \end{definition}

\begin{definition}\boxed{c \in C}\ Collection Containment
  \begin{mathpar}
    \inferrule {
    } {
      c \in C\ c 
    }

    \inferrule {
      c \neq c'
      \\
      c \in C
    } {
      c \in C\ c' 
    }
  \end{mathpar}
\end{definition}


\begin{definition} \boxed{C \preceq C}
  \begin{mathpar}
    \inferrule {
    } {
      C \preceq C 
    }

    \inferrule {
      C \preceq C' 
    } {
      C \preceq C'\ c 
    }
  \end{mathpar}
\end{definition}

% \begin{definition}\boxed{\text{union}(\Tau) = \tau}\ Collective Union
%   \[\begin{array}{rclr}
%     \text{union}(\epsilon)
%     &=& 
%     \obj{BOT}
%     & \C{empty} 
%     \\

%     \text{union}(\Tau\ \tau)
%     &=& 
%     \text{union}(\Tau) \obj{|} \tau
%     & \C{step} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{\text{inter}(\Tau) = \tau}\ Collective Intersection
%   \[\begin{array}{rclr}
%     \text{inter}(\epsilon)
%     &=& 
%     \obj{TOP}
%     & \C{empty} 
%     \\

%     \text{inter}(\Tau\ \tau)
%     &=& 
%     \text{inter}(\Tau) \obj{\&} \tau
%     & \C{step} 
%     \\
%   \end{array}\]
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails m <:^\sharp \alpha}\ Lower closed subtyping 
%   \begin{mathpar}
%     \inferrule {
%       m \in M
%       \\
%       m <: \alpha \in \Delta
%     } {
%       M, \Delta \entails  m <:^\sharp \alpha
%     }

%     % \inferrule {
%     %   m' \in M
%     %   \\
%     %   M, \Delta \entails m <:^\sharp m' 
%     %   \\
%     %   m' <: \alpha \in \Delta
%     % } {
%     %   M, \Delta \entails  m <:^\sharp \alpha
%     % }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \Delta <:^\sharp \alpha \slash \tau}\ Universal lower closed subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall m\ \tau .\ m <: \tau \in \Delta' \iff  M, \Delta \entails 
%       m \in M
%       \land
%       m <: \alpha \in \Delta
%       % m <:^\sharp \alpha
%     } {
%       M, \Delta \entails \Delta' <:^\sharp \alpha \slash \tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\sharp m}\ Upper closed subtyping 
%   \begin{mathpar}
%     \inferrule {
%       m \in M
%       \\
%       \alpha <: m \in \Delta
%     } {
%       M, \Delta \entails  \alpha <:^\sharp m 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \slash \tau <:^\sharp \Delta}\ Universal upper closed subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau\ m .\ \tau <: m \in \Delta' \iff  
%       m \in M
%       \land
%       \alpha <: m \in \Delta
% % M, \Delta \entails \alpha <:^\sharp m 
%     } {
%       M, \Delta \entails \alpha <:^\sharp \Delta' 
%     }
%   \end{mathpar}
% \end{definition}


% \begin{definition}\boxed{M, \Delta, \Delta \entails M \lessdot \alpha}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \epsilon \lessdot \alpha
%     }

%     \inferrule {
%       m \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails M_1 \lessdot \alpha
%       \\\\
%       M_0, \Delta_0, \Delta_0 \entails M_2 \lessdot m 
%     } {
%       M_0, \Delta_0, \Delta_1 \ m<:\alpha 
%       \entails M_1 \sqcup M_2 \ m \lessdot \alpha
%     }

%     \inferrule {
%       \neg (\tau_l \in M_0 \land \tau_r = \alpha)
%       \\\\
%       M_0, \Delta_0, \Delta_1 \entails M_1 \lessdot \alpha
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r
%       \entails M_1 \lessdot \alpha
%     }
%   \end{mathpar}
% \end{definition}


% \begin{definition}\boxed{M, \Delta \entails \tau <:^\dagger \alpha}\ Lower transitive subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \tau \notin M
%       \\
%       \tau <: \alpha \in \Delta 
%     } {
%       M, \Delta \entails \tau <:^\dagger \alpha
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta \entails \tau <:^\dagger m 
%       \\
%       m <: \alpha \in \Delta 
%     } {
%       M, \Delta \entails \tau <:^\dagger \alpha
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \Tau <:^\dagger \alpha}\ Universal lower transitive subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau .\ \tau \in \Tau \iff  M, \Delta \entails \tau <:^\dagger \alpha
%     } {
%       M, \Delta \entails \Tau <:^\dagger \alpha
%     }
%   \end{mathpar}
% \end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\dagger \tau}\ Upper transitive subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \tau \notin M
%       \\
%       \alpha <: \tau \in \Delta 
%     } {
%       M, \Delta \entails \alpha <:^\dagger \tau
%     }

%     \inferrule {
%       m \in M
%       \\
%       \alpha <: m \in \Delta 
%       \\
%       M, \Delta \entails m <:^\dagger \tau 
%     } {
%       M, \Delta \entails \alpha <:^\dagger \tau 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha <:^\dagger \Tau}\ Universal upper transitive subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau .\ \tau \in \Tau \iff  M, \Delta \entails \alpha <:^\dagger \Tau
%     } {
%       M, \Delta \entails \alpha <:^\dagger \Tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \Tau \ll \alpha}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \epsilon \ll \alpha
%     }

%     \inferrule {
%       \tau \notin M
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau \ll \alpha
%     } {
%       M, \Delta_0, \Delta_1 \ \tau<:\alpha \entails \Tau\ \tau \ll \alpha
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau_0 \ll \alpha
%       \\
%       M, \Delta_0, \Delta_0 \entails \Tau_1 \ll z 
%     } {
%       M, \Delta_0, \Delta_1 \ m<:\alpha \entails \Tau_0 \sqcup \Tau_1 \ll \alpha
%     }

%     \inferrule {
%       \tau_r \neq \alpha
%       \\
%       M, \Delta_0, \Delta_1 \entails \Tau \ll \alpha
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \Tau \ll \alpha
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \lessdot M}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \lessdot \epsilon
%     }

%     \inferrule {
%       m \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot M_1 
%       \\\\
%       M_0, \Delta_0, \Delta_0 \entails m \lessdot M_2 
%     } {
%       M_0, \Delta_0, \Delta_1 \ \alpha<:m \entails \alpha \lessdot M_1 \sqcup M_2\ m 
%     }

%     \inferrule {
%       \neg (\tau_r \in M_0 \land \tau_l = \alpha)
%       \\\\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot M_1
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \lessdot M_1
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \ll \Tau}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \ll \epsilon
%     }

%     \inferrule {
%       \tau \notin M
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau
%     } {
%       M, \Delta_0, \Delta_1 \ \alpha<:\tau \entails \alpha \ll \Tau\ \tau
%     }

%     \inferrule {
%       m \in M
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau_0
%       \\
%       M, \Delta_0, \Delta_0 \entails m \ll \Tau_1
%     } {
%       M, \Delta_0, \Delta_1 \ \alpha<:m \entails \alpha \ll \Tau_0 \sqcup \Tau_1
%     }

%     \inferrule {
%       \tau_l \neq \alpha
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Tau
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \star \tau <: m}\ Relational transitive closed subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l) 
%       \\
%       m \in M
%     } {
%       M, \Delta \entails \alpha \star \tau <: m 
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l) 
%       \\
%       m \in M
%       \\
%       \tau <: m \in \Delta
%       \\
%       M, \Delta \entails m <:^\sharp m' 
%     } {
%       M, \Delta \entails \alpha \star \tau <: m' 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \star \Delta}\ Universal relational transitive closed subtyping
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau_l\ \tau_r .\ \tau_l <: \tau_r \in \Delta \iff  M, \Delta \entails \alpha \star \tau_l <: \tau_r
%     } {
%       M, \Delta \entails \alpha \star \Delta 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \lessdot \Delta}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \lessdot \epsilon
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau)
%       \\
%       m_0 \in M_0
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot \Delta_2
%       \\
%       M_0, \Delta_0, \Delta_0 \entails m_0 \lessdot M_1 
%     } {
%       M_0, \Delta_0
%       \entails
%       \Delta_1 \ \tau<:m_0
%       \entails
%       \alpha 
%       \lessdot 
%       \Delta_2 \sqcup \widebar{\tau<:m_1}^{m_1 \in M_1}\ \tau<:m_0
%     }

%     \inferrule {
%       \neg (\tau_r \in M_0 \land \alpha \in \text{FTV}(\tau_l))
%       \\
%       M_0, \Delta_0, \Delta_1 \entails \alpha \lessdot \Delta_2 
%     } {
%       M_0, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \lessdot \Delta_2
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \dagger \tau <: \tau}\ Relational subtyping 
%   \begin{mathpar}
%     \inferrule {
%       \alpha \neq \tau_l
%       \\
%       \alpha \in \text{FTV}(\tau_l) 
%     } {
%       \Delta \entails \alpha \dagger \tau_l <: \tau_r 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta \entails \alpha \slash \tau \dagger \Delta}\ Relational substitution 
%   \begin{mathpar}
%     \inferrule {
%       \forall \tau_l\ \tau_r .\ \tau_l[\alpha\slash\tau] <: \tau_r \in \Delta' \iff  M, \Delta \entails \alpha \dagger \tau_l <: \tau_r
%     } {
%       M, \Delta \entails \alpha \slash \tau \dagger \Delta' 
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{M, \Delta, \Delta \entails \alpha \ll \Delta}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       M, \Delta, \epsilon \entails \alpha \ll \epsilon
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau_l)
%       \\
%       \tau \notin M 
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Delta_2 \ \tau_l<:\tau_r
%     }

%     \inferrule {
%       \alpha \in \text{FTV}(\tau)
%       \\
%       m \in M 
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%       \\\\
%       M, \Delta_0, \Delta_0 \entails z \ll \Delta_3 
%     } {
%       M, \Delta_0, \Delta_1 \ \tau<:z \entails \alpha \ll \Delta_2 \sqcup \Delta_3
%     }

%     \inferrule {
%       \alpha \notin \text{FTV}(\tau_l)
%       \\
%       M, \Delta_0, \Delta_1 \entails \alpha \ll \Delta_2
%     } {
%       M, \Delta_0, \Delta_1 \ \tau_l<:\tau_r \entails \alpha \ll \Delta_2
%     }
%   \end{mathpar}
% \end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subtyping Solving (Inductive) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}\boxed{M, \Delta, \Alpha \entails \vec{\delta}}
  \begin{mathpar}
    \inferrule {
    } {
      M, \Delta, \epsilon \entails \epsilon
    }

    \inferrule {
      \alpha \notin M 
      \\
      \forall \tau .\ \tau<:\alpha \notin \Delta
      \\
      M, \Delta, A \entails \vec{\delta}
    } {
      M, \Delta, A \ \alpha \entails \vec{\delta}
    }

    \inferrule {
      \alpha \notin M 
      \\
      \exists \tau .\  \tau<:\alpha \in \Delta
      \\
      M, \Delta, \Alpha \entails \vec{\delta}
    } {
      M, \Delta, \Alpha\ \alpha 
      \entails 
      \vec{\delta}\ \alpha \slash \obj{|}(\widebar{\ \tau\ }^{\tau<:\alpha \in \Delta})
    }
  \end{mathpar}
\end{definition}

% \begin{definition}
% \boxed{\vec{\alpha} \entails \text{GFP}[\alpha]\vec{\Omega} \Rightarrow \alpha \rightarrow \alpha \fallingdotseq \text{LFP}[\alpha]\vec{\tau}}
% \ Fixpoint Duality
% \label{def:fixpoint_duality}

%   % NOTE: read "z, \- a0 Circle W  . a1 -> a2 --> T" as 
%   % - forall x y, (LFP[a] intersect vec{W}: a1 -> a2) <: (x -> y) iff (x, y) <: union of vec{T}
%   \begin{mathpar}
%     \inferrule {
%     } {
%       \vec{\alpha}_f \entails 
%       \text{GFP}[\alpha_{h^+}] \epsilon \Rightarrow \alpha_l \rightarrow \alpha_r 
%       \fallingdotseq 
%       \text{LFP}[\alpha_{h^-}]\epsilon 
%     }

%     \inferrule {
%       \vec{\alpha}_f \entails 
%       \text{GFP}[\alpha_{\nu}] \vec{\Omega} \Rightarrow \alpha_l \rightarrow \alpha_r
%       \fallingdotseq 
%       \text{LFP}[\alpha_{\mu}]\vec{\tau}
%       \\\\
%       \Delta_\nu \entails \alpha_{\nu} \subtypes \vec{\tau}_\nu
%       \\
%       \Delta_\nu \entails \alpha_l \subtypes \vec{\tau}_l 
%       \\
%       \Delta_\nu \entails \vec{\tau}_r \subtypes \alpha_r
%       \\\\
%       \vec{\tau}_\nu \fallingdotseq \vec{\tau}_\mu
%       \\
%       \text{union}(\vec{\tau}_\mu) \subtypes \alpha_\mu \given \Delta_\mu
%       \\\\
%       \vec{\alpha}_f\ \alpha_{\mu}, \vec{\alpha}_c, \Delta_\nu\ \Delta_\mu \entails \obj{\&$(\vec{\tau}_l)$*|$(\vec{\tau}_r)$} \cong^{-} \tau
%       % TODO: should closeds be included using universal constraint? 
%     } {
%       \vec{\alpha}_f \entails 
%       \text{GFP}[\alpha_{\nu}]\vec{\Omega}\ \left< \vec{\alpha}_c,\Delta_\nu \right> \Rightarrow \alpha_l \rightarrow \alpha_r 
%       \fallingdotseq 
%       \text{LFP}[\alpha_{\mu}] \vec{\tau}\ \tau
%     }
%   \end{mathpar}
% \end{definition}

% \begin{definition}\boxed{\vec{\tau} \fallingdotseq \vec{\tau} }\ Pair Duality 
% \label{def:pair_duality}
%   \begin{mathpar}

%     \inferrule {
%     } {
%       \epsilon \fallingdotseq \epsilon 
%     }

%     \inferrule {
%     } {
%       \vec{\tau}_\nu\ (\tau_l \obj{->} \tau_r) \fallingdotseq \vec{\tau}_\mu\ (\tau_l \obj{*} \tau_r)
%     }
%   \end{mathpar}
% \end{definition}

\begin{definition}\boxed{\Delta \entails \Alpha \pitchfork \Delta}\ Influential Filter 
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \Alpha \pitchfork \epsilon 
    }

    \inferrule {
      \alpha \in \Alpha  
      \\
      \alpha \in \text{FTV}(\tau_l) \sqcup \text{FTV}(\tau_r)
      \\
      \Delta \entails \Alpha \pitchfork \Delta'
    } {
      \Delta \ \tau_l<:\tau_r \entails N \pitchfork \Delta' \ \tau_l<:\tau_r
    }

    \inferrule {
      \forall \alpha .\ \alpha \in \Alpha \implies \alpha \notin \text{FTV}(\tau_l) \sqcup \text{FTV}(\tau_r)
      \\
      \Delta \entails \Alpha \pitchfork \Delta'
    } {
      \Delta \ \tau_l<:\tau_r \entails \Alpha \pitchfork \Delta'
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \Tau \subtypes \alpha}
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \epsilon \subtypes \alpha
    }

    \inferrule {
      \Delta \entails \Tau \subtypes \alpha
    } {
      \Delta \ \tau<:\alpha \entails \Tau\ \tau \subtypes \alpha
    }

    \inferrule {
      \tau_r \neq \alpha
      \\
      \Delta \entails \Tau \subtypes \alpha
    } {
      \Delta \ \tau_l<:\tau_r \entails \Tau \subtypes \alpha
    }
  \end{mathpar}
\end{definition}

\begin{definition}\boxed{\Delta \entails \alpha \subtypes \Tau}
  \begin{mathpar}
    \inferrule {
    } {
      \epsilon \entails \alpha \subtypes \epsilon
    }

    \inferrule {
      \Delta \entails \alpha \subtypes \Tau
    } {
      \Delta \ \alpha<:\tau \entails \alpha \subtypes \Tau\ \tau
    }

    \inferrule {
      \tau_l \neq \alpha
      \\
      \Delta \entails \alpha \subtypes \Tau
    } {
      \Delta \ \tau_l<:\tau_r \entails \alpha \subtypes \Tau
    }
  \end{mathpar}
\end{definition}



\begin{definition}\boxed{\text{outer}(\pm) = \obj{ALL}|\obj{EXI}}
  \[\begin{array}{rclr}
    \\
    \text{outer}(+) 
    &=& 
    \obj{EXI} 
    & \C{positive} 
    \\
    \text{outer}(-) 
    &=& 
    \obj{ALL} 
    & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\text{inner}(\pm) = \obj{ALL}|\obj{EXI}}
  \[\begin{array}{rclr}
    \\
    \text{inner}(+) 
    &=& 
    \obj{ALL} 
    & \C{positive} 
    \\
    \text{inner}(-) 
    &=& 
    \obj{EXI} 
    & \C{negative} 
  \end{array}\]
\end{definition}

\begin{definition}\boxed{\text{quantify}^{\pm}(\Alpha, \Delta, \Alpha, \Delta, \tau) = \tau}
  \[\begin{array}{rclr}
    \text{quantify}^{\pm}(\epsilon, \epsilon, \epsilon, \epsilon, \tau) 
    &=& 
    \tau
    \\
    \text{quantify}^{\pm}(\epsilon, \epsilon, \Alpha_i, \Delta_i, \tau) 
    &=& 
    \text{inner}(\pm)\obj{[}\Alpha_i\obj{ }\Delta_i\obj{]}\tau
    \\
    \text{quantify}^{\pm}(\Alpha_o, \Delta_o, \epsilon, \epsilon, \tau) 
    &=& 
    \text{outer}(\pm)\obj{[}\Alpha_o\obj{ }\Delta_o\obj{]}\tau
    \\
    \text{quantify}^{\pm}(\Alpha_o, \Delta_o, \Alpha_i, \Delta_i, \tau) 
    &=& 
    \text{outer}(\pm)\obj{[}\Alpha_o\obj{ }\Delta_o\obj{]}
    \text{inner}(\pm)\obj{[}\Alpha_i\obj{ }\Delta_i\obj{]}
    \tau
  \end{array}\]
\end{definition}


\begin{definition}\boxed{\Alpha, \Delta \entails \Delta \wr \Delta}
  \begin{mathpar}
    \inferrule {
    } {
      \Alpha_z, \epsilon \entails \epsilon \wr \epsilon 
    }

    \inferrule {
      \text{FTV}(\tau_l)\ \text{FTV}(\tau_r) = \Alpha_q
      \\
      \forall \alpha .\ \alpha \in \Alpha_q \implies \alpha \in \Alpha_z
      \\
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
    } {
      \Alpha_z, \Delta \ \tau_l<:\tau_r \entails \Delta_o \ \tau_l<:\tau_r \wr \Delta_i 
    }

    \inferrule {
      \text{FTV}(\tau_l)\ \text{FTV}(\tau_r) = \Alpha_q
      \\
      \alpha \in \Alpha_q \\ \alpha \notin \Alpha_z
      \\
      \Alpha_z, \Delta \entails \Delta_o \wr \Delta_i 
    } {
      \Alpha_z, \Delta \ \tau_l<:\tau_r \entails \Delta_o \wr \Delta_i \ \tau_l<:\tau_r
    }
  \end{mathpar}
\end{definition}


\begin{definition}\boxed{\VDash e}
  \label{def:expression_good_formation}
  \begin{mathpar}
    \inferrule {
      e = v
    } {
      \VDash e
    } 

    \inferrule { 
      e \rightsquigarrow e' 
      \\
      \VDash e'
    } {
      \VDash e
    } 
  \end{mathpar}
\end{definition}

\begin{theorem}(Typing Soundness)
  \label{theorem:typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \entails e \hastype \tau \given Z
    } {
      \VDash e
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } \entails e \hastype \tau \given Z$
    \item \Z $\B{let } \vec{\delta}\ \Gamma' \ \tau' \B{ s.t. } \vec{\delta}, \Gamma' \satisfies e \hastype \tau'$ by \D{Lemma \ref{theorem:proof_typing_soundness}}
    \item \Z $\vec{\delta}, \vec{\sigma} \satisfies \Gamma'$ by ...
    \item \Z $\VDash e[\vec{\sigma}]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $e[\vec{\sigma}] = e$ by ...
    \item \Z $\VDash e$ by substitution 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof typing consistency)
  \label{theorem:proof_typing_consistency}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \vec{\delta} .\ \vec{\delta} \satisfies Z
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\begin{theorem}(Proof typing soundness)
  \label{theorem:proof_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}


\begin{theorem}(Proof typing weak soundness)
  \label{theorem:proof_typing_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \Gamma \entails e \hastype \tau \given Z  
    } {
      \forall \vec{\delta} .\ \vec{\delta} \satisfies Z \implies \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } 
  \end{mathpar}

  \TODO{rewrite inductive hypotheses with just the conclusion implied by the case conditions}

  \TODO{rewrite cases with universal/implication in conclusion/hypotheses}

  Proof: 
  \item $
    \B{assume } 
    \Gamma \entails e \hastype \tau \given Z 
  $ 
    \item \Z $\B{induct on } \Gamma \entails e \hastype \tau \given Z$ 

    \item \Z $\B{case } e = \obj{@} \I \tau = \obj{@}$ 
      \item \Z\Z $\B{let } \vec{\delta}$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{@} \hastype \obj{@}$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau$ by witness 

    \item \Z $\B{case } e = x \I \obj{$x$:$\tau$} \in \Gamma$ 
    \item \Z $\B{wrt } x$ 
      \item \Z\Z $\B{let } \vec{\delta}$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies x \hastype \tau$  by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ by substitution
      \item \Z\Z $\exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau$ by witness 

  \item \Z $\B{case } 
    \Gamma \entails e' \hastype \tau' \given Z
    \I
    \tau = \obj{<$l$>$\tau'$}
    \I
    e = \obj{<$l$>$e'$} 
  $ 
  \item \Z $\B{hypo } 
      \Gamma \entails e' \hastype \tau' \given Z  
      \implies
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau'
  $ 
  \item \Z $\B{wrt } e' \ \tau'$ 
    \item \Z\Z $\B{let } \vec{\delta} $ by definition
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau'
    $ by application
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \obj{<$l$>$e'$} \hastype \obj{<$l$>$\tau'$}
    $ by definition
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    $ by substitution
    \item \Z\Z $
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    $ by witness 

  \item \Z \TODO{remaining trivial introduction cases} 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item \Z $\B{case } $ 
  \item \Z $\B{hypo } $ 
  \item \Z $\B{wrt } $ 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %   \inferrule {
  %     \Gamma \entails R \hastype \tau_0 \given Z_0
  %     \\
  %     Z_0 \looparrowright Z_1
  %     \\
  %     \Gamma \entails e \hastype \tau_1 \given Z_1
  %   } {
  %     \Gamma \entails R\ \obj{*$l$=$e$} \hastype \tau_0\ \obj{\&}\ \obj{$l$:$\tau_1$} \given Z_1
  %   }

  %   \inferrule {
  %     Z, \Gamma \entails F \liftfun \vec{\pi}, \Tau_n 
  %     \\
  %     \Gamma \entails \vec{\pi} \equiv \Tau 
  %   } {
  %     \Gamma \entails F \hastype \obj{\&}(\Tau) \given Z
  %   }
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau_0 \subtypes \obj{$l$->$\alpha$} \given Z_1
    \I
    e = \obj{$e_0$.$l$} \I \tau = \alpha \I Z = Z_1
  $
   
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0 
    \implies 
    \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
  $ 
  \item \Z $\B{wrt } \vec{\delta}\ e' \ l \ \alpha \ \tau_0 \ Z_0 \ Z_1$ 

    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application

    \item \Z\Z $
      \B{let }
      M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \obj{$l$->$\alpha$} \given M, \Delta
    $ by theorem \ref{theorem:proof_subtyping_choice}


    \item \Z\Z $
      \vec{\delta} \satisfies \tau_0  \subtypes \obj{$l$->$\alpha$}
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness}
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \obj{$l$->$\alpha$}
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \obj{$e_0$.$l$} \hastype \alpha 
    $ by theorem \ref{theorem:model_subtyping_record_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by witness 


  \item \Z $\B{case } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \I
    e = \obj{$e_0$($e_1$)} 
    \I 
    \tau = \alpha 
    \I
    Z = Z_2
  $ 
  \item \Z $ 
    Z_1 \looparrowright Z_2
    \I
    \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} \given Z_2
  $ 
  \item \Z $\B{hypo } 
    \Gamma \entails e_0 \hastype \tau_0 \given Z_0
    \implies 
    \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
    \I
    \Gamma \entails e_1 \hastype \tau_1 \given Z_1
    \implies 
    \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_1
  $ 
  \item \Z $\B{wrt } e_0\ e_1\ \alpha\ \tau_0\ \tau_1\ Z_0\ Z_1\ Z_2 $ 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_0
    $ by application
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_1
    $ by application

    \item \Z\Z $
      \B{let } M\ \Delta
      \B{ s.t. }
      \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} \given \left<M, \Delta \right>
    $ by theorem \ref{theorem:proof_subtyping_choice} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \tau_0 \subtypes \obj{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:proof_subtyping_weak_soundness} 
    \item \Z\Z $
      \vec{\delta} \satisfies e_0 \hastype \obj{$\tau_1$->$\alpha$} 
    $ by theorem \ref{theorem:model_subtyping_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies \obj{$e_0$($e_1$)} \hastype \alpha
    $ by theorem \ref{theorem:model_typing_implication_elimination} 
    \item \Z\Z $
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by substitution 
    \item \Z\Z $
      \exists \vec{\delta} .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau
    $ by substitution 

  \item \Z $\B{case } 
    e = \obj{loop($e'$)} 
  $ 
  \item \Z $\contin  
    \tau = \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFLFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$} 
  $
  \item \Z $\contin 
    Z = Z_0 
  $
  \item \Z $\contin  
    \Gamma \entails e' \hastype \obj{$\alpha_{h^+}$->$\tau'$} \given Z_0
    \I
    Z_0 \looparrowright Z_1
    \I
    \tau' \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
  $ 
  \item \Z $\contin  
    \text{FTV}(\Gamma) \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{hypo } 
    \forall \vec{\delta} .\ \vec{\delta} \satisfies Z_0 \implies
    \vec{\delta}, \Gamma \satisfies e' \hastype \obj{$\alpha_{h^+}$->$\tau'$}
  $ 
  \item \Z $\B{wrt } e'\ \tau'\ \alpha_{h^+}\ \alpha_l\ \alpha_r\ \alpha_{h^-}\ \alpha_l'\ \alpha_r'\ \Tau\ Z_0\ Z_1 $ 
    \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies Z$
      \item \Z\Z\Z $\vec{\delta} \satisfies Z_0$ by substitution
      \item \Z\Z\Z $
        \vec{\delta}, \Gamma \satisfies e' \hastype \obj{$\alpha_{h^+}$->$\tau'$}
      $ by instantiation and application
      \item \Z\Z\Z $
        \vec{\delta} \satisfies \tau' \subtypes 
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r$}
      $ by theorem \ref{theorem:fixpoint_duality_soundness}

      \item \Z\Z\Z $
        \vec{\delta} \satisfies \tau' \subtypes \tau
      $ by substitution  

      \item \Z\Z\Z $
        \vec{\delta} \satisfies e' \hastype \obj{$\alpha_{h^+}$->$\tau$}
      $ by theorem \ref{theorem:model_subtyping_elimination} 

      \item \Z\Z\Z $
        \vec{\delta} \satisfies \obj{loop($e'$)} \hastype \tau 
      $ by theorem \ref{theorem:model_typing_implication_independence}

      \item \Z\Z\Z $
        \vec{\delta} \satisfies e \hastype \tau 
      $ by substitution 

    \item \Z\Z $
      \forall \vec{\delta} .\ \vec{\delta} \satisfies Z \implies \vec{\delta} \satisfies e \hastype \tau 
    $ by implication and generalization 

  \item \Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$
    by induction
  \item $\square$
\end{theorem}

\begin{theorem}(Fixpoint duality soundness (new))
  \label{theorem:fixpoint_duality_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \\
      \text{FTV}(\tau) \subseteq N
      \\
      \alpha_l \notin N
      \\
      \alpha_r \notin N
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \vec{\delta} \satisfies 
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    } 
  \end{mathpar}
  \TODO{...}
\end{theorem}

\TODO{Cretin's corresponding theorem is Theorem 101 on p. 134}

\TODO{See how Cretin proves this without using subject reduction}

\begin{theorem}(Fixpoint duality soundness old)
  \label{theorem:fixpoint_duality_soundness_old}
  \begin{mathpar}
    \inferrule { 
      Z_0 \looparrowright Z_1
      \\
      N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
    } {
      \forall \tau .\ 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume }
    Z_0 \looparrowright Z_1
    \I
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $ 
  \item \Z $\B{induct on }
    N \entails \alpha_{h^+} \cdot Z_1 \cdot \obj{$\alpha_l$->$\alpha_r$} \fallingdotseq \alpha_{h^-} \cdot \Tau
  $
  \item \Z $\B{case }
    Z_1 = \epsilon \I \Tau = \epsilon
  $
    \item \Z\Z $\B{for } \tau$
      \item \Z\Z\Z $\B{assume }
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      $
        \item \Z\Z\Z\Z $
          \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given \epsilon 
        $ by substitution

        \item \Z\Z\Z\Z $
          \B{let } M\ \Delta\ \B{ s.t. } \left<M, \Delta\right> \in \epsilon 
        $ by theorem \ref{theorem:universe_proof_typing_worldly}  

        \item \Z\Z\Z\Z $\bot$ by theorem \ref{theorem:empty_containment_absurd}
      \item \Z\Z\Z $
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
        \implies
        \tau
        \subtypes
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
        \given Z_0
      $ by implication
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.$\alpha_l'$*$\alpha_r'$<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by generalization 
  \item \Z $\B{case }
    Z_1 = Z\ \left<M, \Delta \right> \I \Tau = \Tau_i\ \tau_i
  $
  \item \Z $\contin
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \obj{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
  $
  \item \Z $\contin
    M, \Delta, \Delta \entails \alpha_{h^+} \subtypes \Tau_h
    \I
    M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
    \I
    M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
  $
  \item \Z $\contin
    \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\ \tau_r .\ \tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
  $
  \item \Z $\contin
    N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
    \I
    \Delta \entails \Alpha \pitchfork \Delta_i  
  $
  \item \Z $\contin
    N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
  $
  \item \Z $\B{hypo }
    N \entails 
    \alpha_{h^+} \cdot Z \cdot \obj{$\alpha_l$->$\alpha_r$} 
    \fallingdotseq 
    \alpha_{h^-} \cdot \Tau_i
    \implies
    \\
    \forall \tau .\ 
    \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z
    \implies
    \tau
    \subtypes
    \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
    \given Z_0
  $
  \item \Z $\B{wrt }
    Z\ M\ \Delta\ \Tau_i\ \tau_i
  $

    \item \Z\Z $\B{for } \tau \B{ assume }
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
    $
      \item \Z\Z\Z $
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z\ \left<M, \Delta\right>
      $ by substitution

      \item \Z\Z\Z $
        \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      $ by theorem \ref{theorem:proof_subtyping_decomposition}

      \item \Z\Z\Z $
        \tau
        \subtypes
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by instantiation and application 
      \item \Z\Z\Z $
        \tau
        \subtypes
        \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r'$} 
        \given Z_0
      $ by theorem \ref{theorem:universe_proof_typing_fixpoint_extension}
    \item \Z\Z $
      \forall \tau .\ 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
      \implies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
      \given Z_0
    $ by implication and generalization 


  \item \Z $
    \forall \tau .\ 
    \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given Z_1
    \implies
    \tau
    \subtypes
    \obj{ALL[$\alpha_l'$]$\alpha_l'$->EXI[$\alpha_r'$.($\alpha_l'$,$\alpha_r'$)<:LFP[$\alpha_{h^-}$] |$(\Tau)$]$\alpha_r'$} 
    \given Z_0
  $ by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint extension)
  \label{theorem:universe_proof_typing_fixpoint_extension}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:LFP[$\alpha_{h^-}$] |$(\Tau_i)$]$\alpha_r$} 
      \\\\
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
    } {
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |$(\Tau_i\ \tau_i)$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing case soundness)
  \label{theorem:universe_proof_typing_case_soundnes}
  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given\left<M, \Delta\right>
      \\\\
      \Delta \entails \alpha_{h^+} \subtypes \Tau_h
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \widebar{\obj{$\tau_l$*$\tau_r$<:$\alpha_{h^-}$}}^{\tau_l\obj{->}\tau_r \in \Tau_h} = \Delta_h
      \\
      N \sqcup M \sqcup \text{FTV}(\Tau_l) \sqcup \text{FTV}(\Tau_r)\ \alpha_{h^-} = \Alpha 
      \\ 
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      N\ \alpha_{h^-}, M, \Delta_i \sqcup \Delta_h \entails \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^{-} \tau_i
    } {
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau_i$]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Universe proof typing fixpoint union)
  \label{theorem:universe_proof_typing_fixpoint_union}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau$)]$\alpha_r$} 
      \\
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] $\tau$]$\alpha_r$} 
    } {
      \vec{\delta} \satisfies
      \tau
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.$\alpha_l$*$\alpha_r$<:LFP[$\alpha_{h^-}$] |($\Tau\ \tau$)]$\alpha_r$} 
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}\ Influential soundness 
  \label{theorem:influential_soundness}

  \TODO{Prove that any constraints on non-influential variables with have been transitively applied to the influential variables}

  \begin{mathpar}
    \inferrule { 
      \tau \subtypes \obj{$\alpha_l$->$\alpha_r$} \given M, \Delta
      \\
      \Delta \entails \alpha_l \subtypes \Tau_l 
      \\
      \Delta \entails \Tau_r \subtypes \alpha_r
      \\\\
      \Delta \entails \Alpha \pitchfork \Delta_i  
      \\
      \text{FTV}(\tau) \subseteq \Alpha
      \\\\
      N, M, \Delta \sqcup \Delta' \given \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau
      \\
      N, M, \Delta_i \sqcup \Delta' \given \obj{\&$(\Tau_l)$*|$(\Tau_r)$} \cong^- \tau_i
    } {
      \vec{\delta} \satisfies \tau \subtypes \tau_i 
      \land
      \vec{\delta} \satisfies \tau_i \subtypes \tau
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

% \begin{theorem}(Universe proof typing implication expansion)
%   \label{theorem:universe_proof_typing_implication}
%   \begin{mathpar}
%     \inferrule { 
%       M, \Delta, \Delta \entails \alpha_l \subtypes \Tau_l 
%       \\
%       M, \Delta, \Delta \entails \Tau_r \subtypes \alpha_r
%       \\
%     } {
%       \obj{\&$(\Tau_l)$->|$(\Tau_r)$}
%       \subtypes
%       \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:(\&$(\Tau_l)$,|$(\Tau_r)$)]$\alpha_r$} 
%       \given M, \Delta
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Universe proof typing implication expansion)
  \label{theorem:universe_proof_typing_implication_expansion}
  \begin{mathpar}
    \inferrule { 
    } {
      \obj{$\tau_l$->$\tau_r$}
      \subtypes
      \obj{ALL[$\alpha_l$]$\alpha_l$->EXI[$\alpha_r$.($\alpha_l$,$\alpha_r$)<:($\tau_l$,$\tau_r$)]$\alpha_r$} 
      \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{$P \implies Q$ is equivalent to $\neg (P \land \neg Q)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\forall x \in X .\ \exists y .\ (x,y) \in (X \times Y)$} 
  \item \TODO{$X \rightarrow Y$ is equivalent to $\neg (\exists x \in X \land \nexists y \in Y)$} 
  \item $\square$
\end{theorem}

\begin{theorem}(Upper bound interpretation sound)
  \label{theorem:upper_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \alpha \subtypes \Tau 
    } {
     \alpha \subtypes \obj{\&$(\Tau)$} \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Lower bound interpretation sound)
  \label{theorem:lower_bound_interpretation_sound}
  \begin{mathpar}
    \inferrule { 
      M, \Delta, \Delta \entails \Tau \subtypes \alpha
      \\
    } {
     \obj{|$(\Tau)$} \subtypes \alpha \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Universe proof typing worldly)
  \label{theorem:universe_proof_typing_worldly}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta\ .\ \left<M, \Delta\right> \in Z
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Empty containment absurd)
  \label{theorem:empty_containment_absurd}
  \begin{mathpar}
    \inferrule { 
      \left<M, \Delta\right> \in \epsilon 
    } {
      \bot
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing implication independence)
  \label{theorem:model_typing_implication_independence}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$\tau_l$->$\tau_r$} 
      \\
      \vec{\delta} \satisfies \tau_r
    } {
      \vec{\delta}, \Gamma \satisfies \obj{loop($e$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


% \begin{theorem}(Proof typing fix interpolation weakest pre-condition)
%   \label{theorem:fix_duality}
%   \begin{mathpar}
%     \inferrule { 
%       \tau \subtypes \obj{$\alpha_0$->$\alpha_1$->$\alpha_2$} \given Z_1
%       \\\\
%       \text{FTV}(\Gamma) \entails \alpha_0 \cdot Z_1 \cdot \obj{$\alpha_1$->$\alpha_2$} \fallingdotseq \alpha_3 \circlearrowright \Tau_{rel}
%     } {
%       \obj{ALL[$\alpha_4$]$\alpha_4$->EXI[$\alpha_5$.($\alpha_4$,$\alpha_5$)<:LFP[$\alpha_3$.|$(\Tau_{rel})$]]$\alpha_5$} 
%       \subtypes
%       \obj{$\alpha_1$->$\alpha_2$}
%       \given Z_1
%     } 
%   \end{mathpar}
%   Proof: 
%   \item \TODO{...} 
%   \item $\square$
% \end{theorem}

\begin{theorem}(Proof subtyping decomposition)
  \label{theorem:proof_subtyping_decomposition}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z\ \left<M, \Delta\right>
    } {
      \tau_l \subtypes \tau_r \given \left<M, \Delta\right>
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}


\begin{theorem}(Proof subtyping choice)
  \label{theorem:proof_subtyping_choice}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given Z 
    } {
      \exists M\ \Delta .\ \tau_l \subtypes \tau_r \given M, \Delta
    } 
  \end{mathpar}
  Proof: 
  \item \TODO{...} 
  \item $\square$
\end{theorem}

\begin{theorem}(Model subtyping elimination)
  \label{theorem:model_subtyping_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \vec{\delta}, \Gamma \satisfies e \hastype  \tau_l  
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_r 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    \I
    \vec{\delta}, \Gamma \satisfies e \hastype  \tau_l  
  $
  \item \Z $\B{invert on } \vec{\delta} \satisfies \tau_l \subtypes \tau_r$
  \item \Z $\B{case } \forall e'\ \Gamma' .\ \vec{\delta}, \Gamma' \satisfies e' \hastype  \tau_l  \implies \vec{\delta}, \Gamma' \satisfies e' \hastype \tau_r$
  \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype  \tau_l  \implies \vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by instantiation
  \item \Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by application 
  \item \Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by inversion
  \item $\square$ by implication
\end{theorem}


\begin{theorem}(Model typing record elimination)
  \label{theorem:model_subtyping_record_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$l$->$\tau$}
    } {
      \vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } 
    \vec{\delta}, \Gamma \satisfies e \hastype \obj{$l$->$\tau$}
  $ 
    \item \Z $\B{induct on } 
      \vec{\delta}, \Gamma \satisfies e \hastype \obj{$l$->$\tau$}
    $ 
    \item \Z $\B{case }
      e = G
      \I
      \obj{?$l$=>$v$} \in G
      \I
      \vec{\delta}, \Gamma \satisfies v \hastype \tau
      \I
      \forall v' .\ \obj{?$l$=>$v'$} \in G \implies v' = v 
    $ 
    \item \Z $\B{wrt }
      G\ v 
    $
  
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies G \hastype \obj{$l$->$\tau$}
      $ by substitution

      \item \Z\Z $
        \obj{$G$.$l$} \rightsquigarrow v
      $ by definition 

      \item \Z\Z $
        \B{let } \vec{\sigma} \B{ s.t. } \vec{\delta}, \Gamma \satisfies \vec{\sigma} 
      $ by theorem \ref{...} 
      \item \Z\Z $
        \obj{$G$.$l$}[\vec{\sigma}] \rightsquigarrow v
      $ by definition 
      \item \Z\Z $
        v = v[\vec{\sigma} \sqcup \epsilon] 
      $ by definition 
      \item \Z\Z $
        \obj{$G$.$l$}[\vec{\sigma}] \rightsquigarrow v[\vec{\sigma} \sqcup \epsilon] 
      $ by substitution 
      \item \Z\Z $
        \vec{\delta}, \epsilon \satisfies \epsilon 
      $ by definition 

      \item \Z\Z $
        \vec{\delta}, \Gamma \sqcup \epsilon \satisfies v \hastype \tau
      $ by definition 
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies \obj{$G$.$l$} \hastype \tau 
      $ by definition 
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
      $ by substitution


    \item \Z $\B{case }
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
      \I
      e[\vec{\sigma}] \rightsquigarrow e'[\vec{\sigma} \sqcup \vec{\sigma}']
      \I
      \vec{\delta}, \vec{\sigma}' \satisfies \Gamma'
      \I
      \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies e' \hastype \obj{$l$->$\tau$}
    $
    \item \Z $\B{hypo }
      \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies e' \hastype \obj{$l$->$\tau$}
      \implies
      \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies \obj{$e'$.$l$} \hastype \tau
    $
    \item \Z $\B{wrt }
      \vec{\sigma}\ e'\ \vec{\sigma}'\ \Gamma'
    $
      \item \Z\Z $
        \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies \obj{$e'$.$l$} \hastype \tau
      $ by application
      \item \Z\Z $
        \obj{$e[\vec{\sigma}]$.$l$} \rightsquigarrow \obj{$e'[\vec{\sigma} \sqcup \vec{\sigma}']$.$l$}
      $ by definition 
      \item \Z\Z $
        \obj{$e[\vec{\sigma}]$.$l$} = \obj{$e$.$l$}[\vec{\sigma}]
      $ by definition 
      \item \Z\Z $
        \obj{$e'[\vec{\sigma} \sqcup \vec{\sigma}']$.$l$} = \obj{$e'$.$l$}[\vec{\sigma} \sqcup \vec{\sigma}']
      $ by definition 
      \item \Z\Z $
        \obj{$e$.$l$}[\vec{\sigma}] \rightsquigarrow \obj{$e'$.$l$}[\vec{\sigma} \sqcup \vec{\sigma}']
      $ by substitution 
      \item \Z\Z $
        \vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
      $ by definition 

    \item \Z $
      \vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau 
    $ by induction 
  \item $\square$
\end{theorem}

\begin{theorem}(Proof subtyping consistency)
  \label{theorem:proof_subtyping_consistency}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \vec{\delta} .\ 
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
\end{theorem}

\begin{theorem}(Proof subtyping soundness)
  \label{theorem:proof_subtyping_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \exists \vec{\delta} .\ 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}
\end{theorem}


\begin{theorem}(Proof subtyping weak soundness)
  \label{theorem:proof_subtyping_weak_soundness}
  \begin{mathpar}
    \inferrule { 
      \tau_l \subtypes \tau_r \given M, \Delta 
    } {
      \forall \vec{\delta} .\ 
      \vec{\delta} \satisfies \Delta
      \implies
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
    } 
  \end{mathpar}

\TODO{closed variabless simply remove variables from soundness consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (EXI[X . 1 <: X, X <: 3] X) <: 2  -| 1 <: X, X <: 3, ..., X <: 2  
% FAILS, not considered for soundness
% (EXI[X . 1 <: X, X <: 2] X) <: 2  -| 1 <: X, X <: 2, ..., X <: 2  
% PASSES, is considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2 <: (EXI[X . 1 <: X, X <: 3] X)  -| 2 <: X, ..., 1 <: X, X <: 3 
% PASSES, is considered for soundness
% 2 <: (EXI[X . X <: 1 ] X)  -| 2 <: X, ..., X <: 1
% FAILS, not considered for soundness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Proof: 
  \item \TODO{think about how to handle the mutually recursive definition} 
  \item $\B{assume } 
    \tau_l \subtypes \tau_r \given M, \Delta 
  $
    \item \Z $\B{induct on } \tau_l \subtypes \tau_r \given M, \Delta$

    \item \Z $\B{case } \tau_l = \tau \I \tau_r = \tau$
    \item \Z $\B{wrt } \tau $
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau \subtypes \tau$
        by theorem \ref{theorem:model_typing_reflexivity}
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_l = \obj{BOT}$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \obj{BOT} \subtypes \tau_r$ by definition
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } \tau_r = \obj{TOP}$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \obj{TOP}$ by definition
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 

    \item \Z $\B{case } 
      \tau_r = \obj{$l$->($\tau_{rl}$\&$\tau_{rr}$)}
      \I
      \tau_l
      \subtypes
      \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
      \given M, \Delta
    $
    \item \Z $\B{hypo }
      \forall \vec{\delta} .\ 
      \vec{\delta} \satisfies \Delta
      \implies
      \vec{\delta} \satisfies \tau_l \subtypes \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}
    $ 
    \item \Z $\B{wrt } l\ \tau_{rl}\ \tau_{rr}$ 
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
        by application
        \item \Z\Z\Z $\B{for } e\ \Gamma \B{ assume } \vec{\delta}, \Gamma \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \obj{($l$->$\tau_{rl}$)\&($l$->$\tau_{rr}$)}$
          by theorem \ref{theorem:model_typing_subsumption} 
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \obj{$l$->$\tau_{rl}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \obj{$l$->$\tau_{rr}$}$ by theorem \ref{theorem:model_typing_intersection_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau_{rl}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \tau_{rr}$ by theorem \ref{theorem:model_subtyping_record_elimination}
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies \obj{$e$.$l$} \hastype \obj{$\tau_{rl}$\&$\tau_{rr}$}$ by definition
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \obj{$l$->($\tau_{rl}$\&$\tau_{rr}$)}$ by theorem \ref{theorem:model_typing_record_introduction} 
          \item \Z\Z\Z\Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e\ \Gamma .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau_l \implies 
          \vec{\delta}, \Gamma \satisfies e \hastype \tau_r
        $ by implication and generalization
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$
        by definition 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 


    \item \Z $\B{case } 
      \tau_l = \obj{$\tau_{ll}$|$\tau_{lr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      \tau_{ll} \subtypes \tau_r
      \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_{lr} \subtypes \tau_r
      \given M_1, \Delta_1
    $

    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies \tau_{ll} \subtypes \tau_r
      \I
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies \tau_{lr} \subtypes \tau_r
    $
    \item \Z $\B{wrt } \tau_{ll}\ \tau_{lr}$

      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } M, \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_{lr} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0$ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_{ll} \subtypes \tau_r$ by application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \obj{$\tau_{ll}$|$\tau_{lr}$} \subtypes \tau_r$ 
        by definition
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
        by substitution 

      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \obj{$\tau_{rl}$\&$\tau_{rr}$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin 
      \tau_l \subtypes \tau_{rl} \given M_0, \Delta_0
      \I
      M_0 \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_{rr} \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_{rl} 
      \I
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_{rr} 
    $
    \item \Z $\B{wrt } $
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_{rr}$ by instantiation and application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0 $ by theorem \ref{...} \TODO{...} 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_{rl}$ by instantiation and application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \obj{$\tau_{rl}$\&$\tau_{rr}$}$ by definition 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by substitution
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization


    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \obj{($\tau_{ra}$->$\tau_{rc}$)\&($\tau_{rb}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes 
    %   \obj{$\tau_{ra}$|$\tau_{rb}$->$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes
    %   \obj{($\tau_{ra}$->$\tau_{rb}$)\&($\tau_{ra}$->$\tau_{rc}$)}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \obj{$\tau_{ra}$->$\tau_{rb}$\&$\tau_{rc}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    %%% TEMPLATE
    \item \Z $\B{case } 
      \tau_l = \obj{EXI[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A \notfree \tau_r
      \I
      M_0 \sqcup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_b \subtypes \tau_r
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies M_1, \tau_b \subtypes \tau_r 
    $
    \item \Z $\B{mutu } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1 $ by substitution
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_b \subtypes \tau_r$ by application
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0 $ by theorem \ref{theorem:model_subtyping_sequence_prefix}
        \item \Z\Z\Z $\vec{\delta} \satisfies Q$ by application
        \item \Z\Z\Z $\B{for } e \B{ assume } \vec{\delta} \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \obj{EXI[$\Alpha$ $Q$]$\tau_b$}$ by substitution
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \tau_r$ by theorem \ref{theorem:model_typing_existential_elimination} 
        \item \Z\Z\Z $\forall e .\ \vec{\delta} \satisfies e \hastype \tau_l 
          \implies \vec{\delta} \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization

    \item \Z $\B{case } 
      \tau_r = \obj{ALL[$\Alpha$ $Q$]$\tau_b$}
      \I
      M = M_1
      \I
      \Delta = \Delta_1
    $
    \item \Z $\contin
      Q \given M_0, \Delta_0
      \I
      A \notfree \tau_l
      \I
      M_0 \sqcup \Alpha \preceq M_1
      \I
      \Delta_0 \preceq \Delta_1
      \I
      \tau_l \subtypes \tau_b
      \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_b 
    $
    \item \Z $\B{mutu } 
      \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_0 \implies \vec{\delta} \satisfies Q 
    $ by theorem \ref{...} \TODO{sequence soundness / mutual dependence}
    \item \Z $\B{wrt } \Alpha\ Q\ \tau_b\ M_1\ \Delta_1\ M_0\ \Delta_0$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1$ by substitution 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_b$ by application 
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_0$ by theorem \ref{theorem:model_subtyping_sequence_prefix} 
        \item \Z\Z\Z $\vec{\delta} \satisfies Q$ by application 
        \item \Z\Z\Z $\B{for } e \B{ assume } \vec{\delta} \satisfies e \hastype \tau_l$ 
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \obj{ALL[$\Alpha$ $Q$]$\tau_b$}$ by theorem \ref{theorem:model_typing_universal_introduction} 
          \item \Z\Z\Z\Z $\vec{\delta} \satisfies e \hastype \tau_r$ by substitution 
        \item \Z\Z\Z $\forall e .\ \vec{\delta} \satisfies e \hastype \tau_l 
          \implies \vec{\delta} \satisfies e \hastype \tau_r
        $ 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l \subtypes \tau_r$ by definition 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization
      \item \Z\Z \TODO{...} 

% e :  ALL[a b . 3 <: a ] (a,b) \implies e : (a,b)
    \item \Z $\B{case } 
      \tau_l = \alpha
      \I
      M = M_1
      \I
      \Delta = \Delta_1\ \alpha <: \tau_r
    $
    \item \Z $\contin
      \alpha \notin M_0
      \I
      M_0, \Delta_0 \entails \Delta_m <:^\sharp \alpha \slash \tau_r
      \I
      M_0, \Delta_0 \entails \Tau <:^\dagger \alpha
      \I
      M_0 \preceq M_1
    $
    \item \Z $\contin
      \Delta_0 \sqcup \Delta_m \preceq \Delta_1
      \I
      \obj{|$(\Tau)$} <: \tau_r \given M_1, \Delta_1
    $
    \item \Z $\B{hypo } \forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta_1 \implies
      \vec{\delta} \satisfies \obj{|$(\Tau)$} <: \tau_r
    $
    \item \Z $\B{wrt } \alpha\ M_1\ \Delta_1\ M_0\ \Delta_0\ \Delta_m\ \Tau$
      \item \Z\Z $\B{for } \vec{\delta} \B{ assume } \vec{\delta} \satisfies \Delta$
        \item \Z\Z\Z $\vec{\delta} \satisfies \Delta_1 \obj{($\alpha$<:$\tau_r$)}$ by substitution
        \item \Z\Z\Z $\vec{\delta} \satisfies \alpha <: \tau_r$ by theorem \ref{theorem:model_subtyping_sequence_last} 
        \item \Z\Z\Z $\vec{\delta} \satisfies \tau_l <: \tau_r$ by substitution 
      \item \Z\Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
      by implication and generalization 
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \notin M_0
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot M
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \lessdot \Delta_{skol}
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Tau 
    %   \\
    %   M_0, \Delta_0, \Delta_0 \entails \alpha \ll \Delta_{rel}
    %   \\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \widebar{\obj{.$\tau_0[\alpha\slash\tau_l]$<:$\tau_1$}}^{\tau_0<:\tau_1 \in \Delta_{rel}} \sqcup \widebar{\obj{.$\tau_l$<:$\tau$}}^{\tau \in \Tau}
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    %   \sqcup \widebar{\tau_l<:z}^{z \in M}
    %   \sqcup \widebar{\tau[\alpha\slash\tau_l]<:z}^{\tau<:z \in \Delta_{skol}} \ \tau_l<:\alpha 
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \alpha <: \tau \in (\Delta_0 \sqcup \text{factor}(\Delta_0, \alpha))
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau \subtypes \tau_r
    %   \given M_1, \Delta_1
    % } {
    %   \alpha \subtypes \tau_r
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \alpha \in M_0
    %   \\
    %   \tau <: \alpha \in \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   \tau_l \subtypes \tau
    %   \given M_1, \Delta_1
    % } {
    %   \tau_l \subtypes \alpha
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q
    %   \given M_1, \Delta_1
    % } {
    %   \obj{ALL[$\Alpha$ $Q$]$\tau_l$}
    %   \subtypes 
    %   \tau_r
    %   \given M_1, \Delta_1 
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_r
    %   \given M_0, \Delta_0
    %   \\\\
    %   M_0 \preceq M_1
    %   \\
    %   \Delta_0 \preceq \Delta_1
    %   \\
    %   Q \given M_1, \Delta_1
    % } {
    %   \tau_l
    %   \subtypes 
    %   \obj{EXI[$\Alpha$ $Q$]$\tau_r$}
    %   \given M_1, \Delta_1
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{ll} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \obj{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_{lr} \subtypes \tau_r
    %   \given M, \Delta
    % } {
    %   \obj{$\tau_{ll}$\&$\tau_{lr}$}  \subtypes \tau_r
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rl}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \obj{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }

      \item \Z\Z \TODO{...} 

    \item \Z $\B{case } $
    \item \Z $\B{hypo } $
    \item \Z $\B{wrt } $
    % \inferrule {
    %   \tau_l \subtypes \tau_{rr}
    %   \given M, \Delta
    % } {
    %   \tau_l \subtypes \obj{$\tau_{rl}$|$\tau_{rr}$}
    %   \given M, \Delta
    % }
      \item \Z\Z \TODO{...} 

    \item \Z $\forall \vec{\delta} .\ \vec{\delta} \satisfies \Delta \implies \vec{\delta} \satisfies \tau_l \subtypes \tau_r$ 
    by induction
  \item $\square$ by implication
\end{theorem}

\begin{theorem} Model typing existential elimination 
  \label{theorem:model_typing_existential_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies e \hastype \obj{EXI[$\Alpha$ $Q$]$\tau_l$}
      \\
      \vec{\delta} \satisfies Q
      \\
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha \notfree \tau_r
    } {
      \vec{\delta} \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: 
% depends on proof subtyping 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ... |= 2 : (EXI[X . 1 <: X, X <: 3] X)
% X/1 |= 1 <: X, X <: 3
% -------------------------
% X/1 |= 2 : 1 (FAIL) 
% -------------------------
% X/1 |= 2 : 4  (PASS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% X <: 4  -| X, 1 <: X, X <: 3

\end{theorem}

\begin{theorem} Model typing universal introduction 
  \label{theorem:model_typing_universal_introduction}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l
      \\
      \vec{\delta} \satisfies Q
      \\
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \Alpha \notfree \tau_l
    } {
      \vec{\delta} \satisfies e \hastype \obj{ALL[$\Alpha$ $Q$]$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{depends on proof subtyping. can we abstract away proof subtyping?}
\end{theorem}





\begin{theorem} Model subtyping sequence last 
  \label{theorem:model_subtyping_sequence_last}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta\ \obj{($\tau_l$<:$\tau_r$)}
    } {
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence reduction 
  \label{theorem:model_subtyping_sequence_reduction}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta\ \delta
    } {
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence prefix  
  \label{theorem:model_subtyping_sequence_prefix}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta'
      \\
      \Delta \preceq \Delta'
    } {
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping sequence uncat 
  \label{theorem:model_subtyping_sequence_uncat}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta \sqcup \Delta'
    } {
      \vec{\delta} \satisfies \Delta
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} concatenation prefix 
  \label{theorem:concatenation prefix}
  \begin{mathpar}
    \inferrule { 
    } {
      \Delta \preceq \Delta \sqcup \Delta'
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model subtyping unsub left 
  \label{theorem:Modle_subtyping_unsub_left}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_l \in \vec{\delta}
    } {
      \vec{\delta} \satisfies \alpha \subtypes \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping unsub right 
  \label{theorem:Modle_subtyping_unsub_right}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \tau_l \subtypes \tau_r
      \\
      \alpha\slash\tau_r \in \vec{\delta}
    } {
      \vec{\delta} \satisfies \tau_l \subtypes \alpha
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model subtyping something 
  \label{theorem:Modle_subtyping_something}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \Delta 
      \\
      M, \Delta \entails \Tau \subtypes^\sharp \alpha  
    } {
      \alpha\slash\obj{|$(\Tau)$} \in \vec{\delta}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem} Model typing record introduction 
  \label{theorem:model_typing_record_introduction}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \obj{$e$.$l$} \hastype \tau
    } {
      \vec{\delta} \satisfies e \hastype \obj{$l$->$\tau$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing implication introduction 
  \label{theorem:model_typing_implication_introduction}
  \TODO{this is really messed up}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies \obj{$e_0$($e_1$)} \hastype \tau_r
      \\
      \vec{\delta} \satisfies e_1 \hastype \tau_l
      \\
      \forall \tau .\ \vec{\delta} \satisfies e_1 \hastype \tau \implies \tau_l \subtypes \tau
    } {
      \vec{\delta} \satisfies e_0 \hastype \obj{$\tau_l$->$\tau_r$}
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}

\begin{theorem} Model typing intersection elimination 
  \label{theorem:model_typing_intersection_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta} \satisfies e \hastype \tau_l \& \tau_r
    } {
      \vec{\delta} \satisfies e \hastype \tau_l 
      \land
      \vec{\delta} \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}



\begin{theorem} Model typing reflexivity
  \label{theorem:model_typing_reflexivity}
  \begin{mathpar}
    \inferrule { 
    } {
      \vec{\delta} \satisfies \tau \subtypes \tau
    } 
  \end{mathpar}
  Proof:
  \item $\B{for } e\ \Gamma \B{ assume } \vec{\delta}, \Gamma \satisfies e \hastype \tau$
    \item \Z $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ by identity
  \item $\forall e\ \Gamma .\ \vec{\delta}, \Gamma \satisfies e \hastype \tau \implies \vec{\delta}, \Gamma \satisfies e \hastype \tau$
  by implication and generalization
  \item $\square$ by definition
\end{theorem}


\begin{theorem}(Model typing subsumption)
  \label{theorem:model_typing_subsumption}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
      \\
      \vec{\delta}, \Gamma \satisfies \tau_l <: \tau_r
    } {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau_r
    } 
  \end{mathpar}
  Proof: 
  \item $\B{assume } \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
  \I \vec{\delta}, \Gamma \satisfies \tau_l <: \tau_r
  $
    \item \Z $\B{invert on}\ \vec{\delta}, \Gamma \satisfies \tau_l <: \tau_r$
    \item \Z $\B{case}\ \forall e' .\ \vec{\delta}, \Gamma \satisfies e' : \tau_l \implies \vec{\delta}, \Gamma \satisfies e' : \tau_r$
      \item \Z\Z $\forall e' .\ \vec{\delta}, \Gamma \satisfies e' : \tau_l \implies \vec{\delta}, \Gamma \satisfies e' : \tau_r$ by identity
    \item \Z $\forall e' .\ \vec{\delta}, \Gamma \satisfies e' : \tau_l \implies \vec{\delta}, \Gamma \satisfies e' : \tau_r$ by inversion
    \item \Z $\vec{\delta}, \Gamma \satisfies e : \tau_l \implies \vec{\delta}, \Gamma \satisfies e : \tau_r$ by instantiation 
    \item \Z $\vec{\delta}, \Gamma \satisfies e : \tau_r$ by application
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}(Model typing implication elimination)
  \label{theorem:model_typing_implication_elimination}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_l \obj{->} \tau_r
      \\
      \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_l
    } {
      \vec{\delta}, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume }
    \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_l \obj{->} \tau_r
    \I 
    \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_l
  $ 

    \item \Z $\B{let } \vec{\sigma} \B{ s.t. } \vec{\delta}, \vec{\sigma} \satisfies \Gamma$ by theorem \ref{...}
    \item \Z $\B{induct on } \vec{\delta}, \Gamma \satisfies e_0 \hastype \tau_l \obj{->} \tau_r$

    \item \Z $\B{case }$ \TODO{...}

    % \inferrule { 
    %   \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies p \pattype \tau_p
    %   \\
    %   \vec{\delta}, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    %   \\\\
    %   \forall e .\ 
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_l 
    %     \implies
    %     \vec{\delta}, \Gamma \satisfies e \hastype \tau_p 
    %     \land
    %     (\forall \tau_n\ \tau .\ \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_n$->$\tau$} \implies \neg (\vec{\delta}, \Gamma \satisfies e \hastype \tau_n))
    % } {
    %   \vec{\delta}, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % \inferrule { 
    %   \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    % } {
    %   \vec{\delta}, \Gamma \satisfies \obj{$F$*$p$=>$e$} \hastype \obj{$\tau_l$->$\tau_r$}
    % } 
    \item \Z $\B{case }
      e_0 = \obj{$F$?$p$=>$e_2$}
      \I
      \vec{\delta}, \Gamma \satisfies F \hastype \obj{$\tau_l$->$\tau_r$}
    $ 
    \item \Z $\B{hypo }
      \vec{\delta}, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
    $
    \item \Z $\B{wrt }
      F\ p\ e_2 
    $
      \item \Z\Z $\VDash \obj{$F$($e_1$)}[\vec{\sigma}] $
      by theorem \ref{theorem:model_typing_soundness}
      \item \Z\Z $\B{invert on } \VDash \obj{$F$($e_1$)}[\vec{\sigma}]$
      \item \Z\Z $\B{case } \obj{$F$($e_1$)}[\vec{\sigma}] = v$
      \item \Z\Z $\B{wrt } v$
        \item \Z\Z\Z $\obj{$F$($e_1$)}[\vec{\sigma}] \neq v$ by definition 
        \item \Z\Z\Z $\bot$ by application
      \item \Z\Z $\B{case } 
        (\obj{$F$($e_1$)})[\vec{\sigma}] \rightsquigarrow e_3
        \I
        \vec{\delta}, \Gamma \satisfies e_3 \hastype \tau_r
      $
      \item \Z\Z $\B{wrt } e_3$
        \item \Z\Z\Z $(\obj{$F$($e_1$)})[\vec{\sigma}] = \obj{$F[\vec{\sigma}]$($e_1[\vec{\sigma}]$)}$ by definition
        \item \Z\Z\Z $\obj{$F[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\B{let } F' \B{ s.t. } F[\vec{\sigma}] = F'$ by theorem \ref{...} \TODO{...}
        \item \Z\Z\Z $\B{let } e_1' \B{ s.t. } e_1[\vec{\sigma}] = e_1'$ by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\text{FV}(e_2[\vec{\sigma}\backslash\text{FV}(p)]) \subseteq \text{FV}(p)$ 
        by theorem \ref{...} \TODO{...}

        \item \Z\Z\Z $\obj{$F'$($e_1'$)} \rightsquigarrow e_3$ by substitution 
        \item \Z\Z\Z $\obj{($F'$?$p$=>$e_2[\vec{\sigma}\backslash\text{FV}(p)]$)($e_1'$)} \rightsquigarrow e_3$ by definition 
        \item \Z\Z\Z $(\obj{$F[\vec{\sigma}]$?$p$=>$e_2[\vec{\sigma}\backslash\text{FV}(p)]$)($e_1[\vec{\sigma}]$)} \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $(\obj{($F$?$p$=>$e_2$)($e_1$)})[\vec{\sigma}] = \obj{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\text{FV}(p)]$)($e_1[\vec{\sigma}]$)}
        $ by definition
        \item \Z\Z\Z $(\obj{($F$?$p$=>$e_2$)($e_1$)})[\vec{\sigma}] \rightsquigarrow e_3$ by substitution 

        \item \Z\Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% OLD 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \item \Z $\B{case }
    %   \vec{\delta}, \Gamma \sqcup \Gamma' \satisfies p \hastype \tau_l
    %   \I
    %   \vec{\delta}, \Gamma \sqcup \Gamma'  \satisfies e \hastype \tau_r
    % $
    % \item \Z $ 
    %   \contin
    %   F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r
    %   \I
    %   e_0 = \obj{($F$?$p$=>$e$)} 
    % $
    % \item \Z $
    %   \B{hypo} \  \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r \implies \vec{\delta}, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
    % $
    % \item \Z $
    %   \B{wrt} \ F \ p \ e \ \Gamma' \  
    % $
    %   \item \Z\Z $F = \epsilon \lor \vec{\delta}, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r$ by application
    %   \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)} \hastype \tau_l \obj{->} \tau_r$ by substitution 
    %   \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_reduced_implication_elimination}
    %   \item \Z\Z $\vec{\delta}, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r$ by substitution 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \item \Z $\B{case }
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
      \I
      e_0[\vec{\sigma}] \rightsquigarrow e_0'
      \I
      \vec{\delta}, \Gamma \satisfies e_0' \hastype \tau_l \obj{->} \tau_r
    $
    \item \Z $\B{hypo}\ 
      \vec{\delta}, \Gamma \satisfies e_0' \hastype \tau_l \obj{->} \tau_r
      \implies
      \vec{\delta}, \Gamma \satisfies \obj{$e_0'$($e_1$)} \hastype \tau_r
    $
    \item \Z $ 
    \B{wrt}\ \vec{\sigma}\ e_0' 
    $
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e_0'\obj{(}e_1\obj{)} \hastype \tau_r$ by application 
      \item \Z\Z $e_0[\vec{\sigma}]\obj{(}e_1\obj{)} \rightsquigarrow e_0'\obj{(}e_1\obj{)}$
      \item \Z\Z ($e_0\obj{(}e_1\obj{)})[\vec{\sigma}] \rightsquigarrow e_0'\obj{(}e_1\obj{)}$
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r$ 

    \item \Z $\vec{\delta}, \Gamma \satisfies e_0\obj{(}e_1\obj{)} \hastype \tau_r$ by induction
  \item $\square$
\end{theorem}

\begin{theorem}\ Model typing reduced implication elimination  

  \label{theorem:model_typing_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)} \hastype \tau_l \obj{->} \tau_r
      \\
      \vec{\delta}, \Gamma \satisfies e_1 \hastype \tau_l
      \\
      F = \epsilon \lor \vec{\delta}, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
    } {
      \vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r
    } 
  \end{mathpar}

  \item $\B{assume } \VDash e_1[\vec{\sigma}]$


    \item \Z $\B{let } \vec{\sigma} \B{ s.t. } \vec{\delta}, \vec{\sigma} \satisfies \Gamma $ by theorem \ref{theorem:model_typing_assignability} 
    \item \Z $\VDash e_1[\vec{\sigma}]$ by theorem \ref{theorem:model_typing_soundness}
    \item \Z $\B{induct on } \VDash e_1[\vec{\sigma}]$

    \item \Z $\B{case } e_1[\vec{\sigma}] = v_1 $
    \item \Z $\B{wrt } v_1$  
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by theorem \ref{theorem:model_typing_fully_reduced_implication_elimination}

    \item \Z $\B{case}\ e_1[\vec{\sigma}] \rightsquigarrow e_1' \I \VDash e_1'$
    \item \Z $\B{hypo}\ \VDash e_1' \implies \vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$
    \item \Z $\B{wrt}\ e_1' $

      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1'$)} \hastype \tau_r$ by application
      \item \Z\Z $\obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow \obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1'$)}$ by definition 
      \item \Z\Z $\forall x .\ x \notin \B{FV}(e_1')$ by theorem \ref{theorem:reduction_closed} 
      \item \Z\Z $e_1' = e_1'[\vec{\sigma}]$ by by theorem \ref{theorem:closed_substitution} 
      \item \Z\Z $\obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow \obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1'[\vec{\sigma}]$)}$ by substitution 
      \item \Z\Z $(\obj{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow (\obj{($F$?$p$=>$e$)($e_1'$)})[\vec{\sigma}]$ by definition 
      \item \Z\Z $\vec{\sigma} \sqcup \epsilon = \vec{\sigma}$ by definition 
      \item \Z\Z $(\obj{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow (\obj{($F$?$p$=>$e$)($e_1'$)})[\vec{\sigma} \sqcup \epsilon]$ by substitution 
      \item \Z\Z $\Gamma \sqcup \epsilon = \Gamma$ by definition
      \item \Z\Z $\vec{\delta}, \epsilon \satisfies \epsilon$ by definition
      \item \Z\Z $\vec{\delta}, \Gamma \sqcup \epsilon \satisfies \obj{($F$?$p$=>$e$)($e_1'$)}$ by substitution 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r$ by definition
    \item \Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)}\obj{(}e_1\obj{)} \hastype \tau_r$ by induction
  \item $\square$ by implication 
\end{theorem}

\begin{theorem}\ Model typing fully reduced implication elimination 
  \label{theorem:model_typing_fully_reduced_implication_elimination}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)} \hastype \tau_l \obj{->} \tau_r
      \\
      F = \epsilon \lor \vec{\delta}, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r
      \\
      \vec{\delta} \satisfies e_1 \hastype \tau_l
      \\
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
      \\
      e_1[\vec{\sigma}] = v_1
      \\
    } {
      \vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume}\ F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r$
    \TODO{add more assumptions}
    \item \Z $\vec{\delta} \satisfies e_1[\vec{\sigma}] \hastype \tau_l$ by theorem \ref{theorem:model_typing_valuation} 
    \item \Z $\vec{\delta} \satisfies v_1 \hastype \tau_l$ by substitution 
    \item \Z $\B{invert on}\ F = \epsilon \lor \vec{\delta}, \Gamma \satisfies F \hastype \tau_l \obj{->} \tau_r$
    \item \Z $\B{case } F = \epsilon$ 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{$F$?$p$=>$e$} \hastype \tau_l \obj{->} \tau_r$ by theorem \ref{theorem:model_typing_unwrapping} 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{?$p$=>$e$} \hastype \tau_l \obj{->} \tau_r$ by substitution 

      \item \Z\Z $\B{let}\ \vec{\sigma}' \B{ s.t. } p \equiv v_1 \given \vec{\sigma}'$ 
      by theorem \ref{theorem:model_typing_pattern_matching} 

      \item \Z\Z $\B{for } e'$ 
        \item \Z\Z\Z $\neg \epsilon[\vec{\sigma}]\obj{($v_1$)} \rightsquigarrow e'$ by definition
        \item \Z\Z\Z $\neg F[\vec{\sigma}]\obj{($v_1$)} \rightsquigarrow e'$ by substitution 
      \item \Z\Z $\forall e' .\ \neg F[\vec{\sigma}]\obj{($v_1$)} \rightsquigarrow e'$ by generalization 

      \item \Z\Z $\obj{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\vec{\sigma}\backslash\B{FV}(p)][\vec{\sigma}]$ by definition 

      \item \Z\Z $\forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\vec{\sigma}')$ 
      by theorem \ref{theorem:pattern_matching_consistency}
      \item \Z\Z $\vec{\sigma}\backslash\B{FV}(p) = \vec{\sigma}\backslash\B{dom}(\vec{\sigma}')$ 
      by theorem \ref{theorem:consistency_diffing}
      \item \Z\Z $e[\vec{\sigma}\backslash\B{dom}(\vec{\sigma}')][\vec{\sigma}'] = e[\vec{\sigma} \sqcup \vec{\sigma}']$ 
      by theorem \ref{theorem:concatenation_substitution}

      \item \Z\Z $\obj{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\vec{\sigma}\backslash\B{dom}(\vec{\sigma}')][\vec{\sigma}]$ 
        by substitution
      \item \Z\Z $\obj{($F[\vec{\sigma}]$?$p$=>$e[\vec{\sigma}\backslash\B{FV}(p)]$)($v_1$)} \rightsquigarrow e[\vec{\sigma} \sqcup \vec{\sigma}']$ 
        by substitution 
      \item \Z\Z $\obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($v_1$)} \rightsquigarrow e[\vec{\sigma} \sqcup \vec{\sigma}']$ by definition 
      \item \Z\Z $\obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} \rightsquigarrow e[\vec{\sigma} \sqcup \vec{\sigma}']$ by substitution  

      \item \Z\Z $\obj{($F$?$p$=>$e$)$[\vec{\sigma}]$($e_1[\vec{\sigma}]$)} = (\obj{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}]$ by definition  
      \item \Z\Z $(\obj{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow e[\vec{\sigma} \sqcup \vec{\sigma}']$ by substitution  

      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition

    \item \Z $\B{case } \vec{\delta}, \Gamma \satisfies \obj{$F$($e_1$)} \hastype \tau_r$ 
      \item \Z\Z $\B{let } e' \B{ s.t. } (\obj{$F$($e_1$}))[\vec{\sigma}] \rightsquigarrow e' \land \vec{\delta}, \Gamma \satisfies e' \hastype \tau_r$ by theorem \ref{theorem:model_typing_function_progress}
      \item \Z\Z $(\obj{($F$?$p$=>$e$)($e_1$)})[\vec{\sigma}] \rightsquigarrow e'$ by definition 
      \item \Z\Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by definition
    \item \Z $\vec{\delta}, \Gamma \satisfies \obj{($F$?$p$=>$e$)($e_1$)} \hastype \tau_r$ by inversion 
  \item $\square$ by implication
\end{theorem}


\begin{theorem}\ (Pattern matching consistency)
  \label{theorem:pattern_matching_consistency}
  \begin{mathpar}
    \inferrule {
      p \equiv v \given \vec{\sigma}
    } {
      \forall x .\ x \in \B{FV}(p) \iff x \in \B{dom}(\vec{\sigma})
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}\ (Consistency diffing)
  \label{theorem:consistency_diffing}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \in X_l \iff x \in X_r 
    } {
      \vec{\sigma}\backslash X_l = \vec{\sigma}\backslash X_r
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Concatenation Substitution )
  \label{theorem:concatenation_substitution}
  \begin{mathpar}
    \inferrule {
    } {
      e[\vec{\sigma}\backslash\B{dom}(\vec{\sigma}')][\vec{\sigma}'] = e[\vec{\sigma} \sqcup \vec{\sigma}']
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
  \item $\square$
\end{theorem}



\begin{theorem}(Model typing valuation)
  \label{theorem:model_typing_valuation}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies e \hastype \tau 
      \\
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
    } {
      \vec{\delta} \satisfies e[\vec{\sigma}] \hastype \tau 
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \vec{\delta}, \Gamma \satisfies e \hastype \tau 
    \I
    \vec{\delta}, \vec{\sigma} \satisfies \Gamma
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Model typing pattern matching)
  \label{theorem:model_typing_pattern_matching}
  \begin{mathpar}
    \inferrule {
      \vec{\delta}, \Gamma \satisfies \obj{?$p$=>$e$} \hastype \tau_l \obj{->} \tau_r
      \\
      \vec{\delta} \satisfies v \hastype \tau_l 
    } {
      \exists \vec{\sigma} .\  p \equiv v \given \vec{\sigma}
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \vec{\delta}, \Gamma \satisfies \obj{?$p$=>$e$} \hastype \tau_l \obj{->} \tau_r
    \I
    \vec{\delta} \satisfies v \hastype \tau_l 
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}


\begin{theorem}(Well-formed function valuation)
  \label{theorem:wellformed_function_valuation}
  \begin{mathpar}
    \inferrule {
      \VDash F
    } {
      \exists v .\ v = F 
    } 
  \end{mathpar}
\end{theorem}
\begin{proof}
  \item $\B{assume } \VDash F$ 
    \item \Z $\B{invert on } \VDash F$
    \item \Z $\B{case } v = F$
      \item \Z\Z $v = F$ by identity
    \item \Z $\B{case } F \rightsquigarrow e$
    \item \Z $\B{wrt } e$
      \item \Z\Z $\neg F \rightsquigarrow e$ by definition
      \item \Z\Z $\bot$ by application 
    \item \Z $v = F$ by inversion 
  \item $\square$
\end{proof}


\begin{theorem}(Reduction closed)
  \label{theorem:reduction_closed}
  \begin{mathpar}
    \inferrule {
      e \rightsquigarrow e'
    } {
      \forall x .\ x \notin \B{FV}(e')
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    e \rightsquigarrow e'
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}

\begin{theorem}(Closed substitution)
  \label{theorem:closed_substitution}
  \begin{mathpar}
    \inferrule {
      \forall x .\ x \notin \B{FV}(e)
    } {
      e = e[\vec{\sigma}]
    } 
  \end{mathpar}
  Proof:
  \item $\B{assume } 
    \forall x .\ x \notin \B{FV}(e)
  $
  \item \TODO{...}
  \item $\square$
\end{theorem}



% \begin{theorem}(Progress of pattern matching)
%   \label{theorem:pattern_matching_progress}
%   \begin{mathpar}
%     \inferrule {
%       \obj{*$p$=>$e$} \in F 
%       \\
%       p \equiv v \given \vec{\sigma} 
%       \\
%       \forall e' .\ \obj{*$p$=>$e'$} \in F \implies e' = e 
%     } {
%       \exists e' .\ F\obj{(}v\obj{)} \rightsquigarrow e'
%     } 
%   \end{mathpar}
%   Proof:
%   \item $\B{for } p\ e\ F\ v\ \vec{\sigma}\ \B{assume }
%       \obj{*$p$=>$e$} \in F 
%       \I
%       p \equiv v \given \vec{\sigma} 
%       \I
%       \forall e' .\ \obj{*$p$=>$e'$} \in F \implies e' = e 
%   $

%   \item \Z $\B{case }
%     F = F'\ \obj{*$p$=>$e$} 
%     \I
%     \obj{*$p$=>$e$} \notin F'
%   $

%   \item \Z\Z $\B{for } e'$
%   \item \Z\Z\Z $\B{case}\ F'\obj{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\obj{(}F'\ \obj{*}p\obj{=>}e\obj{)(} v \obj{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z\Z\Z $F\obj{(}v\obj{)} \rightsquigarrow e'$ by substitution 
%   \item \Z\Z\Z $\B{case}\ \neg F'\obj{($v$)} \rightsquigarrow e'$
%   \item \Z\Z\Z\Z $\obj{(}F'\ \obj{*}p\obj{=>}e\obj{)(} v \obj{)} \rightsquigarrow e[\vec{\sigma}]$ by definition
%   \item \Z\Z\Z\Z $F\obj{(}v\obj{)} \rightsquigarrow e[\vec{\sigma}]$ by substitution 
%   \item \Z\Z\Z $\exists e'' .\ F\obj{(}v\obj{)} \rightsquigarrow e''$ by decidability of $F'\obj{($v$)} \rightsquigarrow e'$
%   \item \Z\Z $\forall e' .\ \exists e'' .\ F\obj{(}v\obj{)} \rightsquigarrow e''$ by summarization
%   \item \Z\Z $\exists e'' .\ F\obj{(}v\obj{)} \rightsquigarrow e''$ by independence 

%   \item \Z $\B{case }
%     F = F'\ f 
%     \I
%     \obj{*$p$=>$e$} \in F' 
%   $
%   \item \Z\Z $\B{let } e' \B{ s.t. } F'\obj{(}v\obj{)} \rightsquigarrow e'$ by induction hypothesis
%   \item \Z\Z $F'\ f\obj{(}v\obj{)} \rightsquigarrow e'$ by definition
%   \item \Z\Z $F\obj{(}v\obj{)} \rightsquigarrow e'$ by definition
%   \item \Z $\exists e' .\ F\obj{(}v\obj{)} \rightsquigarrow e'$ by induction on $\obj{*$p$=>$e$} \in F$
%   \item $\square$
% \end{theorem}

\begin{theorem}(Model typing assignability)
  \label{theorem:model_typing_assignability}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } {
      \exists \vec{\sigma} .\ \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
    } 
  \end{mathpar}
  Proof:
  \item \TODO{...}
\end{theorem}


\begin{theorem}(Model typing soundness)
  \label{theorem:model_typing_soundness}
  \begin{mathpar}
    \inferrule { 
      \vec{\delta}, \Gamma \satisfies e \hastype \tau
    } {
      \forall \vec{\sigma} .\ 
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma
      \implies
      \VDash e[\vec{\sigma}]
    } 
  \end{mathpar}
  Proof:
  \item \TODO{redo using universal/implication}
  \item $\B{assume }
        \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
        \I \vec{\delta}, \Gamma \satisfies e \hastype \tau
  $
    \item \Z $\B{case } e = \obj{@}$
      \item \Z\Z $\B{let } v \B{ s.t. } \obj{@} = v$
      \item \Z\Z $e[\vec{\sigma}] = v$
      \item \Z\Z $ \VDash e[\vec{\sigma}]$


    \item \Z $\B{case } 
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau'
      \I 
      e = \obj{<}l\obj{>}e' 
      \I 
      \tau = \obj{<}l\obj{>}\tau'
    $
      \item \Z\Z $\Vdash e'$ by induction hypothesis
      \item \Z\Z $\B{case } e'[\vec{\sigma}] = v$
        \item \Z\Z\Z $\B{let } v' \B{ s.t. } \obj{<}l\obj{>}v = v'$
        \item \Z\Z\Z $\obj{<}l\obj{>}e'[\vec{\sigma}] = v'$
        \item \Z\Z\Z $(\obj{<}l\obj{>}e')[\vec{\sigma}] = v'$
        \item \Z\Z\Z $e[\vec{\sigma}] = v'$
        \item \Z\Z\Z $\VDash e[\vec{\sigma}] $

      \item \Z\Z $\B{case } e'[\vec{\sigma}] \rightsquigarrow e'' \I \VDash e''$
        \item \Z\Z\Z $\obj{<}l\obj{>}e'[\vec{\sigma}] \rightsquigarrow \obj{<}l\obj{>} e''$
        \item \Z\Z\Z $\VDash \obj{<}l\obj{>}e'' $
        \item \Z\Z\Z $\VDash \obj{<}l\obj{>}e'[\vec{\sigma}] $
        \item \Z\Z\Z $\VDash (\obj{<}l\obj{>}e')[\vec{\sigma}] $
        \item \Z\Z\Z $\VDash e[\vec{\sigma}] $

      \item \Z\Z $\VDash e[\vec{\sigma}] $ by cases on $\VDash e' $

    \item \Z \TODO{remaining introduction cases}

    \item \Z $\B{case } 
      x \hastype \tau \in \Gamma
      \I 
      x \slash v \in \vec{\sigma}
      \I 
      e = x
    $
      \item \Z\Z $x[\vec{\sigma}] = v$
      \item \Z\Z $e[\vec{\sigma}] = v$
      \item \Z\Z $\VDash e[\vec{\sigma}] $

    \item \Z $\B{case } 
      e[\vec{\sigma}] \rightsquigarrow e' 
      \I 
      \vec{\delta}, \Gamma \satisfies e' \hastype \tau
    $ 
      \item \Z\Z $\VDash e'[\vec{\sigma}] $ by induction hypothesis
      \item \Z\Z $\VDash e[\vec{\sigma}] $

    \item \Z $\VDash e[\vec{\sigma}] $ by induction on $\vec{\delta}, \Gamma \satisfies e \hastype \tau$
  \item $\square$
  \item \TODO{Cretin's corresponding theorem is by definition of pretypes on p. 125}
\end{theorem}

\noindent
\B{NOTE: } The induction hypothesis includes the generalized assumption, e.g. $\forall e' .\ e' < e \implies Q(e')$ if inducting on $e$ or $\forall e' .\ (P(e') \implies P(e)), P(e') \implies Q(e')$ if inducting on predicate $P$

\noindent
\B{NOTE: } we induct on $\vec{\delta}, \Gamma \satisfies e \hastype \tau$ instead of $e$, as the predicate acts as a guard/ordering in lieu of a decreasing e.
This allows us to use the induction hypothesis on the reduction step result in the elimination case.

\noindent
\B{NOTE: } Kozen says, "Intuitively, one can appeal to the coinductive hypothesis as long as there
has been progress in observing the elements of the stream (guardedness) and there is no
further analysis of the tails (opacity)".  Kozen demonstrates a legal proof by induction on infinite streams too

% \begin{theorem}(Progress of proof typing)
%   \label{theorem:proof_typing_soundness}
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%     } {
%       e \B{ progressive}
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}

% \begin{theorem}(Preservation of proof typing)
%   \begin{mathpar}
%     \inferrule { 
%       \Gamma \entails e \hastype \tau \given Z  
%       \\
%       e \rightsquigarrow e'
%     } {
%       \Gamma \entails e' \hastype \tau \given Z  
%     } 
%   \end{mathpar}
%   Proof ... 
% \end{theorem}


\begin{definition}\boxed{\vec{\delta}, \vec{\sigma} \satisfies \Gamma}
  \label{def:model_typing_environment}
  \begin{mathpar}
    \inferrule { 
    } {
      \vec{\delta}, \vec{\sigma} \satisfies \epsilon  
    } 

    \inferrule { 
      \vec{\delta}, \vec{\sigma} \satisfies \Gamma 
      \\
      \vec{\delta} \satisfies v \hastype \tau 
    } {
      \vec{\delta}, \vec{\sigma} \ x \slash v \satisfies \Gamma \ x:\tau 
    } 
  \end{mathpar}
\end{definition}


\end{document}