\documentclass[table,dvipsnames,acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage[table,dvipsnames]{xcolor}
\usepackage{array}
\usepackage{wasysym}

\usepackage{pifont}% http://ctan.org/pkg/pifont

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\newcounter{pdc}
\newcounter{sdc}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={def, fix, in}
}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{requirement}{Requirement}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]
% \newtheorem{proof}{Proof}[section]

\newtheorem{instances}{Instances}[section]


\title{Extrinsic Relational Types (DRAFT 2026-02-07)}
\author{Thomas Logan}



\begin{document}



\newcommand{\stoprule}{
  \addlinespace[2pt]
  \toprule
  \addlinespace[5pt]
}

\newcommand{\sbottomrule}{
  \addlinespace[2pt]
  \bottomrule
  \addlinespace[2pt]
}

\newcommand{\smidrule}[1]{
  \addlinespace[2pt]
  \midrule
  \addlinespace[2pt]
}

\newcommand{\scmidrule}[1]{
  \addlinespace[2pt]
  \cmidrule{#1}
  \addlinespace[2pt]
}


\newcommand{\sline}{
  \arrayrulecolor{gray!50}
  \specialrule{0.4pt}{2pt}{2pt}
  \arrayrulecolor{black}
}

\newcommand{\pdc}{\stepcounter{pdc}\arabic{pdc}}
\newcommand{\sdc}{\stepcounter{sdc}\arabic{sdc}}

\newcommand{\Par}[1]{\paragraph{\textbf{#1}}}
\newcommand{\J}[1]{\texttt{\fontfamily{pcr}\selectfont #1}}
\newcommand{\lab}[1]{\text{\color{Gray}\ [#1]}}
\newcommand{\entails}{\vdash}
\newcommand{\satisfies}{\vDash}
\newcommand{\given}{\dashv}

% inflatable
\newcommand{\inflatable}{\star}

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\pass}{\text{\scriptsize \color{Green} \ding{51}}}
\newcommand{\assisted}{\text{\scriptsize \color{Purple} \ding{45}}}
\newcommand{\fail}{\text{\scriptsize \color{red} \ding{55}}}

\newcommand{\qua}{\ .\ }



\newcommand{\safe}{\ \checkmark}
\newcommand{\valued}{\ \star}



\newcommand{\ignore}{\varnothing}
\newcommand{\dTheta}{\dot{\Theta}}
\newcommand{\closed}{\bullet}
\newcommand{\local}{\blacktriangle}
\newcommand{\open}{\circ}



\newcommand{\up}{\ \land\ }
\newcommand{\down}{\ \lor\ }

% \newcommand{\tl}{\textasciitilde{}}

\newcommand{\multi}[1]{\widebar{\ #1\ }}
\newcommand{\hastype}{:}
\newcommand{\pattype}{\ \lozenge\ }
\newcommand{\restricted}{\ \blacklozenge\ }
\newcommand{\dentails}{\Vdash}
\newcommand{\liftfun}{:}

\newcommand{\sz}[1]{\text{\small #1}}


\newcommand{\nopad}{
  \setlength{\abovedisplayskip}{4pt}
  \setlength{\belowdisplayskip}{4pt}
}

\newcommand{\examp}[1]{{\nopad \footnotesize 
\[
\begin{array}[t]{@{}l}
#1
\end{array}
\]
}}


\newcommand{\cb}[1]{
$
\begin{array}[t]{@{}l}#1\end{array}
$
}




\newcommand{\ms}[1]{{\footnotesize $(#1)$}}

\newcommand{\code}[1]{\ms{\J{#1}}}


\newcommand{\R}[1]{\color{teal}\ \ [\emph{#1}]}
 
\newcommand{\subtypes}{<:}
\newcommand{\supertypes}{:>}
\newcommand{\I}{\hspace{4mm}}
\newcommand{\Z}{.\hspace{4mm}}
\newcommand{\Alpha}{\mathrm{A}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\F}[1]{\text{#1}}
\newcommand{\bigand}{\bigwedge\nolimits}
\newcommand{\bigor}{\bigvee\nolimits}
\newcommand{\C}[1]{\color{teal} \rhd\ \emph{#1}}
\newcommand{\com}[1]{\I \emph{#1}}
\newcommand{\D}[1]{\small \textsc{#1}}
% \newcommand{\fig}[1]{Fig. {\color{red} \fig{#1}}}
\newcommand{\FIG}[1]{Fig. {\color{red} \ref{#1}}}
\newcommand{\TODO}[1]{\noindent \B{\color{red} TODO: #1}}

\newcommand{\is}{\ ::=\ }
\newcommand{\sep}{\ \ |\ \ }
\newcommand{\nonterm}[1]{#1\ }
\newcommand{\contin}{|\ \ \ \ \ \ \ }
\newcommand{\wrt}{\B{wrt }}
% \newcommand{\let}{\B{def }}
% \newcommand{\for}{\B{for }}



\newcommand{\pc}{\hfill \break \noindent \ $\diamond$ \ }


\newcommand{\N}{\ $\cdot$\ \ }

\newcommand{\pitem}{\item[$\diamond$]}

\newcommand{\tl}{\textasciitilde{}}
\newcommand{\typdiff}{\J{\textbackslash}}

\maketitle

\section{Introduction}
\label{sec:introduction}

While it is commonly accepted that types are a useful tool for specification and verification
of programs, type systems vary significantly in their expressivity and their flexibility. 
At one end of the spectrum is the system Lean, whose types can express 
elaborate mathematics, but require that programs are constructed in rigid ways to be typed.
At the other end is the system TypeScript, whose types are limited to describing shapes, but can adapt to pre-existing programs.
From the perspective of verification, the importance of expressive types seems obvious, 
while the importance of a flexible type system is less so. However, recent trends in
programming language usage indicate that flexibility of programming has a far greater weight
than expressivity of verification. That is, people prioritize flexible programs with a high-degree of code reusability
and are uninterested in writing tedious boiler plate code in order to conform 
to the artificial restrictions of a verification system.

Historically, intrinsic type systems have been the more widely accepted approach to designing type systems,
even in systems with merely unexpressive simple types. By requiring constructors to be restricted to
certain types, type checking and type inference becomes more tractable by reducing the need for control-flow analysis. 
A typing is intrinsic if the type system requires that the input or output to a constructor or function abstraction is annotated
with a type.  
In Lean, data constructors are intrinsically typed according to users' annotations, The intrinsic typing of 
function abstractions are inferred from the data constructors' types whenever possible, and type annotations are required
when type inference is not possible.

For example, to define a function that calculates the length of a list, the constructors representing lists and natural
numbers must first be prescribed types.

\examp{
  \J{inductive Nat}
  \\
  \J{| Zero : Nat }
  \\
  \J{| Succ : Nat -> Nat}
  \\
  \\
  \J{inductive List T}
  \\
  \J{| Nil : List T}
  \\
  \J{| Cons : T -> List T -> List T}
  \\
  \\
  \J{def length : List T -> Nat}
  \\
  \J{| .Nil => .Zero }
  \\
  \J{| .Cons x xs => .Succ (length xs) }
}

The overhead of prescribing types is not a significant issue. 
One would most likely want numerous functions defined on lists and natural numbers,
meaning the overhead would be a small fraction of the overall effort.
The actual drawback of intrinsic typing is the inability to reuse the constructors
in contexts that don't match perfectly with the requirements of their intrinsic types.
For instance, in Lean, it is impossible to define a program
that gets the element from a singleton list, without using additional structures or auxiliary proofs.

\examp{
  \J{def get : List T -> T}
  \\
  \J{| .Cons x .Nil => x }
  \\
  \\
  \J{-- Missing cases:}
  \\
  \J{-- (List.Cons \_ (List.Cons \_ \_))}
  \\
  \J{-- List.Nil}
}

This singleton list example involves refinement, and this particular kind of rigidity has
been addressed by refinement types \cite{}, which allows type systems to be more flexible, while still
benefiting algorithmically from intrinsic typing. Additionally, Liquid types offers a mathematical level
of expressivity.   


Another scenario might be that a programmer would like a function to handle
variations of lists, such as lists that can terminate in multiple ways. However, Lean 
does not allow reusing list constructors in the list variations.

\examp{
  \J{inductive AltList T}
  \\
  \J{| Some : T -> AltList T}
  \\
  \J{| Nil : AltList T}
  \\
  \J{| Cons : T -> AltList T -> AltList T}
  \\
  \\
  \J{def process : AltList T -> Unit } 
  \\
  \J{| .Some x => () }
  \\
  \J{| .Nil => () }
  \\
  \J{| .Cons x xs => () }
  \\
  \\
  \J{\#eval process (List.Cons () List.Nil) }
  \\
  \J{--  Application type mismatch }
  \\
}

In order to use the process function on normal lists, the programmer would
need to write a translation function from normal list constructors to alternative list constructors. 
In large projects, variations on a theme are actually quite common, so this rigidity of intrinsic typing
can result in needing significant amounts of tedious boiler plate code. 
For some, this burden is more than made up for by Lean's elegant and expressive type system.
However, for many, the increased complexity and verbosity of programming will be too great of a price,
and they would prefer the flexibility of TypeScript, despite the limited expressivity of its types.


To address these issues, we have designed an extrinsic relational type system, 
which is both flexible and expressive.
\begin{itemize}
  \item Extrinsic: The types describe programs. 
    Types need not be prescribed for constructors in the program. 
  \item Relational: A type may represent an infinite space of complex values (or tuples), 
    such that the value of one part constrains the value of another part.
\end{itemize}
The types in our system are able to be extrinsic by including intersection and union type constructors.  
This allows expressions to belong to a range of types of varying precision. The semantics of intersection
and union are related to their components by subtyping. By leveraging this subtyping semantics,  
expressions may be composed together that would fail in a system based on type equivalence. In other words,
expressions are highly reusable while being well typed.
The types in our system are able to be relational by including 
least fixed point, universal constraint, and existential constraint type constructors. 
The least fixed point type describes infinite spaces while the constraint types can
declare dependencies between subparts of complex values.   

This work contains the foundational theory of our extrinsic relational type system. 
Key contributions:
\begin{itemize}
  \item The design of a semantics-driven extrinsic relational type system 
  \item The design of a corresponding small-step pattern matching semantics 
  \item Formally proven theorems of safety, progress, subject reduction, subject expansion, and confluence. 
\end{itemize}
The type system is semantics-driven due to the requirement that the types be highly expressive. 
A syntax-directed definition would overly restrict the expressivity of types. However, this foundational
theory provides the necessary tools to derive introduction and elimination rules, which
would be necessary to prove soundness of downstream syntax-directed type inference or analysis tools.

Paper organization:
\begin{itemize}
  \item Section \ref{sec:overview}: Overview of the kinds of programs and types that may occur in our type system.  
  \item Section \ref{sec:expressions}: Syntax, semantics, and theorems of expressions.  
  \item Section \ref{sec:types}: Syntax, semantics, and theorems of types.  
  \item Section \ref{sec:rules}: Corollaries for some introduction and elimination rules. 
  \item Section \ref{sec:related_work}: Related work.  
  \item Section \ref{sec:conclusion}: Conclusion.  
\end{itemize}


\section{Overview}
\label{sec:overview}
We designed the type system around a simple applicative language with pattern matching,
such that the syntax of expressions and types mirror each other. The language of types 
shares many similarities with predicate logic. 
To see how the types are both flexible and expressive, it's best to start by
looking at a few examples.

\Par{Finite Isomorphism.}
A function can be constructed from multiple paths. 
Consider the function \code{talky}, which completes a simple English phrase.

\examp{
  \J{def talky = (}
  \\
  \I \J{[<hello>@ => <world>@]}
  \\
  \I \J{[<good>@ => <morning>@]} 
  \\
  \I \J{[<thank>@ => <you>@]} 
  \\
  \J{)}
}

\noindent
Since there is no recursion, the number of paths is finite.
Such a simple function can is described precisely in the language of types
by using an intersection of path types.

\examp{
  \J{(<hello>TOP -> <world>TOP) \&}
  \\
  \J{(<good>TOP -> <morning>TOP) \&} 
  \\
  \J{(<thank>TOP -> <you>TOP)} 
}

The symbol \code{@} represents an empty record, which is merely a convenient way to express
no-op data, like unit in other languages. the type \code{TOP} is the weakest possible type, 
containing all safe expressions. The inputs and outputs, e.g. \code{<hello>@} and \code{<world>@}
are singleton data constructions distinguished by their labels. Rather than declaring data constructors,
it simply use angle brackets to distinguish labels from variables.
A data construction can inhabit a structural type e.g. \code{<world>TOP}.
For convenience, we can write \code{<world/>} to mean the expression \code{<world>@} or 
the type \code{<world>TOP}.
   

\Par{Selection.}
Although the type of function \code{talky} is no weaker than the actual function,
lifting into the type syntax avails it to approximate reasoning at application.
Consider an application of the function to a variable argument. 

\examp{
  \J{def x : <hello/> | <thank/> = ... in}
  \\
  \J{...}
  \\
  \J{talky(x)} 
  \\
  \J{...}
}

\noindent
If the type annotation holds,
The the application can inhabit to an union type, 
which is imprecise but strong enough to be useful. 

\examp{
  \J{<world/> | <you/>}
}


\Par{Learning.}
The paths of a function are not always syntactically apparent. 
If a variable is applied to arguments, the variable should implicitly behave 
like a function, or else the program is erroneous. 
Consider the higher order function \code{foo} which takes a function as input
and applies it to the number two and the boolean true.

\examp{
  \J{def foo = [f => (f(<succ><succ><zero/>), f(<true/>))]}
}

\noindent
Type systems for System F have traditionally struggled to find the best
type for such programs. If restricted to unqualified parametric types, there are many choices,
without there being a clear best or principal type, 
which is because it's not possible to construct the weakest type for the function parameter
\code{f}.
One possibility is that the type system requires that \code{f} is a function that wraps its
input in an option. 

\examp{
  \J{f : ALL[X] X -> <some>X}
}

\noindent
Another possibility is that the type system requires that \code{f} is a function that wraps its
input in an list. 

\examp{
  \J{f : ALL[X] X -> (LFP[R] <nil/> | <cons>X*R)}
}

\noindent
Both are valid, but neither is weaker than the other. The problem is that unqualified parametric
types are insufficient for describing the weakest safe input type.
However, using intersection we can easily describe the principal type of \code{foo}.

\examp{
  \J{ALL[X Y] (<succ><succ><zero>@ -> X) \& (<true>@ -> Y) -> X*Y}
}


\Par{Infinite Isomorphism.}
A function can represent infinite paths by using recursion.
Consider the function \code{repeat}, which takes an item and a natural number
as inputs and returns a list of that item repeated the input number of times.

\examp{
  \J{def repeat = [x => loop([self => [}
  \\
  \I \J{[<zero/> => <nil/>]}
  \\
  \I \J{[<succ>n => <cons>(x,self(n))]}
  \\
  \J{])]}
}

\noindent
One possibility for constructing a precise type of the recursive function would
be to follow the idea of finite isomorphism and construct a type 
that preserves all the paths. If our type system had a greatest fixed point
type constructor, then we could concisely represent such a type with minimal
rewriting.

\examp{
  \J{ALL[T] T -> GFP[R](} 
  \\
  \I \J{(<zero/> -> <nil/>) \&}
  \\
  \I \J{(ALL[N L](R <: N->L) <succ> N -> <cons> T*L)}
  \\
  \J{)} 
}
Although, this representation is syntactically concise, we have chosen to not include 
the greatest fixed point type constructor, and instead rely on least fixed points, since
those are necessary represent results of applications and sufficient for representing
infinite paths when combined with existential and universal constraint type constructors.
Using least fixed points, the parameter type and the relation between input and output must be described separately
from the path types.

\examp{
  P = \J{(LFP[N] <zero/> | <succ> N)}
  \\
  \\
  R(\alpha) = \J{LFP [R]} 
  \\
  \I \J{(<zero/> * <nil/>) | }
  \\
  \I \J{(EXI[N L] [(N*L <: R)] ((<succ>N) * (<cons>}\alpha\J{*L)))}

}

Then the parameter type and relational type can be combined with universal constraint types and path types. 

\examp{
  \J{ALL[T] T ->} 
  \\
  \J{\ \ ALL[X] [(X <: } P \J{)] X -> EXI[Y] [(X*Y <: }R(\J{T})\J{)] Y} 
}


\Par{Induction.} 
Another scenario that may arise is one in which the input to a function has an recursive type.
Consider the application of the function \code{repeat} to a variable whose type represents the even natural numbers.

\examp{
  \J{def x : (LFP[R] <zero> @ | <succ> <succ> R) = ... in}
  \\
  \J{...}
  \\
  \J{repeat(...)(x)} 
  \\
  \J{...}
}

\noindent
The application is well typed because the least fixed point of even numbers subtypes the least fixed point
of natural numbers by induction. 

\examp{
  \J{LFP[R] <zero> @ | <succ> <succ> R}
  \\
  \subtypes
  \\
  \J{LFP[R] <zero> @ | <succ> R}
}

\Par{Path Sensitivity} 
Suppose we have a simple comparison function, perhaps for sorting lists. 
In order to have a high degree of code reusability, 
we want to use it to sort either lists of scalars or lists of vectors. 

\examp{
  \J{def compare = [a,b => } 
  \\
  \I \J{if isScalar(a) then}
  \\
  \I \J{\ \ scalarCmp(a,b)}
  \\
  \I \J{else}
  \\
  \I \J{\ \ lexicoCmp(a,b)}
  \\
  \J{]} 
}

We use \code{if-then-else} as syntactic sugar for pattern matching on \code{<true/>} or \code{<false/>}
structures. Even though the same variable is used in both branches, the most precise type that
this function can inhabit would associated the same variables with different types in different paths.

\examp{
  Bool = \J{<true/> | <false/>}
  \\
  Nat = \J{LFP[N] <zero/> | <succ> N}
  \\
  List(\alpha) = \J{LFP[L] <nil/> | <cons>(}\alpha\J{*L)}
  \\
  Vec = List(Nat) 
  \\
  \\
  \I Nat \J{ * } Nat \J{ -> } Bool \J{ \&}
  \\
  \I Vec \J{ * } Vec \J{ -> } Bool
}

The typing of this kind of pattern is known as occurrence typing \cite{},
since it associates types with particular occurrences of variables rather than the variable itself. 


\section{Expressions}
\label{sec:expressions}

\noindent
To demonstrate the capabilities of our extrinsic type system, 
we rely on an applicative programming language with pattern matching.
The design attempts to keep the forms of expressions and types relatively 
similar to each other when their semantics are also similar. 
Although the expression language is based on pattern matching, 
the type inference techniques apply just as well to languages
that are based on conditional branching and destructors instead of pattern matching.
In fact, conditional branching and destructors can be encoded from pattern matching,
and used without any loss in type inference precision.

\begin{definition}
  \label{def:expression}
  \nopad 
  \small
  \[\begin{array}[t]{rr@{}l}
    \com{expression} &
    \nonterm{e} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      x \sep 
      \J{<}l\J{>} e \sep
      r \sep
      f \sep 
      e\J{.}l \sep
      e\J{(}e\J{)} \sep
      \J{loop(}e\J{)} \sep
      e\ \J{as}\ \tau \sep
      s
    \end{array}
    \\
    \com{record} &
    \nonterm{r} & \is \J{@} \sep l \J{:=} e\J{;}\ r
    \\
    \com{function} &
    \nonterm{f} & \is \epsilon \sep \J{[}p\J{=>}e \J{]}\ f
    \\
    \com{sugar} &
    \nonterm{s} 
    & 
    \is 
    \begin{array}[t]{@{}l}
      \J{<}l\J{/>} \sep
      l \J{:=} e\J{;} \sep
      l \J{:=} e \sep
      e \J{,} e \sep
      e\ \J{|>}\ e \sep
      \\
      \J{if}\ e\ \J{then}\ e\ \J{else}\ e \sep
      \J{def}\ x\ \J{=}\ e\ \J{in}\ e \sep
      \J{def}\ x\J{:}\tau\ \J{=}\ e\ \J{in}\ e
    \end{array}
  \end{array}\]
\end{definition}

\noindent
An expression is a variable \ms{x}, unit \code{@},
a record \ms{... \J{<}l\J{>} e ...}, a function \ms{...\J{[}p \J{=>} e \J{]}...}, 
a projection \ms{e\J{.}l}, an application \ms{e\J{(}e\J{)}}, 
a loop \ms{\J{loop(}e\J{)}},
an annotation \ms{\J{def}\ x\ \J{:}\ \tau\ \J{=}\ e\ \J{in}\ e},
or sugar.
These forms are similar to those seen in other applicative structural languages,
with a few choices that are a bit less common. One thing that may be
a bit unconventional is that a function may syntactically consist of 
multiple paths guarded by patterns.  

\begin{definition} 
  \label{def:expression_desugaring}
  \emph{expression desugaring}
  \hfill
  \small
  \boxed{\llbracket s \rrbracket^\square = e}
  \nopad
  \begin{align*}
      \llbracket \J{<}l\J{/>} \rrbracket^\square &= \J{<}l\J{>@}\ 
      \\
      \llbracket l \J{:=} e\J{;} \rrbracket^\square &= l \J{:=} e\J{;@}\ 
      \\
      \llbracket l \J{:=} e \rrbracket^\square &= l \J{:=} e\J{;@}\ 
      \\
      \llbracket e_l \J{,} e_r \rrbracket^\square &= \J{left:=}\ e_l \J{; right:=}\ e_r
      \\
      \llbracket e_l\ \J{|>}\ e_r \rrbracket^\square &= e_r\J{(}e_l\J{)}
      \\
      \llbracket \J{if}\ e_c\ \J{then}\ e_t\ \J{else}\ e_f \rrbracket^\square &= 
      \begin{array}[t]{@{} l}
        e_c \J{ |> (}
          \\
          \I \J{[<true>@ => } e_t \J{]}
          \\
          \I \J{[<false>@ => } e_f \J{]}
          \\
        \J{)}
      \end{array}
      \\
      \llbracket \J{def}\ x\ \J{=}\ e\ \J{in}\ e' \rrbracket^\square &= \J{[}x \J{=>} e'\J{]}\J{(}e\J{)}
      \\
      \llbracket \J{def}\ x\J{:}\tau\ \J{=}\ e\ \J{in}\ e' \rrbracket^\square &= \J{[}x \J{=>} e'\J{]}\J{(}e\ \J{as}\ \tau \J{)}
  \end{align*}

\end{definition} 

\noindent
For convenience and clarity, there is sugar for 
singleton records \ms{l\J{;}e},
tuples \ms{e\J{,}e}, 
unannotated bindings \ms{\J{def}\ x\ \J{=}\ e\ \J{in}\ e}, flow \ms{e\ \J{|>}\ e},
and conditional branching \ms{\J{if}\ e\ \J{then}\ e\ \J{else}\ e}.
For any metalanguage statement or term containing sugar $s$, we assume that $s$ is implicitly replaced with $\llbracket s \rrbracket^\square$.

\begin{definition}
  \label{def:pattern}
  \small
  \nopad
  \[\begin{array}[t]{rr@{}l}
    \com{pattern} &
    \nonterm{p} & \is 
      x \sep
      \J{@} \sep
      k
    \\
    \com{record} &
    \nonterm{k} & \is \epsilon \sep k\ \J{<}l\J{>}p
  \end{array}\]
\end{definition}

\noindent
A pattern is either unit or a record consisting of patterns.

% \begin{definition}
%   \label{def:value}
%   \small
%   \nopad
%   \[\begin{array}[t]{rr@{}l}
%     \com{value} &
%     \nonterm{v} & \is 
%       \J{@} \sep
%       g \sep
%       f
%     \\
%     \com{record} &
%     \nonterm{g} & \is \epsilon \sep g\ \J{<}l\J{>}v
%   \end{array}\]
% \end{definition}

\noindent
A value may be unit, a function, or a record consisting of only values. 

\begin{definition}
  \label{def:stepped}
  \emph{stepped}
  \hfill 
  \small
  \boxed{e \rightsquigarrow e}
  \nopad
  \begin{mathpar}
    % \inferrule {
    %   e \rightsquigarrow e'
    % } {
    %   r\ \J{<}l\J{>}e \rightsquigarrow r\ \J{<}l\J{>}e'
    % }

    % \inferrule {
    %   r \rightsquigarrow r'
    % } {
    %   r\ \J{<}l\J{>} v \rightsquigarrow r'\ \J{<} l \J{>} v
    % }

    % \inferrule {
    %   e \rightsquigarrow e'
    % } {
    %   e\J{.}l \rightsquigarrow e'\J{.}l
    % }

    % \inferrule {
    %   \J{<}l\J{>}v \in g
    %   \\
    %   \forall\ e .\ \J{<}l\J{>}e \in g \implies e = v
    % } {
    %   g\J{.}l \rightsquigarrow v
    % }

    % \inferrule {
    %   e_f \rightsquigarrow e_f'
    % } {
    %   e_f\J{(}e\J{)} \rightsquigarrow e_f'\J{(}e\J{)}
    % }

    % \inferrule {
    %   e \rightsquigarrow e'
    % } {
    %   f\J{(}e\J{)} \rightsquigarrow f\J{(}e'\J{)}
    % }

    % \inferrule {
    %   f\J{(}v\J{)} \rightsquigarrow e'
    %   \\
    %   \textbf{fv}(e) \subseteq \textbf{fv}(p)
    % } {
    %   (f\ \J{[}p\J{=>}e\J{]})\J{(}v\J{)} \rightsquigarrow e' 
    % }

    % \inferrule {
    %   \nexists e' .\ f\J{(}v\J{)} \rightsquigarrow e'
    %   \\
    %   v  \simeq p \given \sigma 
    % } {
    %   (f\ \J{[}p\J{=>}e\J{]})\J{(}v\J{)} \rightsquigarrow e[\sigma]
    % }

    \inferrule {
      e \rightsquigarrow e'
    } {
      \J{loop(}e\J{)} \rightsquigarrow \J{loop(}e'\J{)}
    }

    \inferrule {
    } {
      \J{loop([}x\J{=>}e\J{])} \rightsquigarrow e[x \slash \J{loop([}x\J{=>}e\J{])}]
    }
  \end{mathpar}
\end{definition}

\noindent
Progression of an expression is a fairly typical small-step operational semantics. 
Its most atypical aspect is handling the unconventional multi-path syntax of
functions.
Since a function may consist of multiple paths guarded by patterns, 
application subsumes pattern matching.
Recursion is enabled by the \code{loop} keyword, such that
\code{loop} behaves like a fixed point combinator.


\begin{definition}
  \label{def:value_map}
  \small
  \nopad
  \[\begin{array}[t]{rr@{}l}
    \com{value map} &
    \nonterm{\sigma} & \is \epsilon \sep \sigma\ x \slash v 
  \end{array}\]
\end{definition}

\noindent
A value map assigns variables to values.
Progression relies on interpretation maps to collect
values that are relevant from pattern matching \ms{v \simeq p \given \sigma},
and then to use them in a subsequent expression via substitution 
\ms{e[\sigma]}


\begin{definition}
  \label{def:safe}
  \emph{safe}
  \hfill
  \small
  \boxed{\delta \satisfies e \hastype \tau}
  \nopad
  \[
  \begin{array}[t]{rclcl}
      e \safe
      &\iff& 
      \forall e' \qua 
      e \rightsquigarrow^* e'
      \implies
      e \valued
      \down
      \exists e'' \qua e' \rightsquigarrow e''

      \\
  \end{array}
  \]
\end{definition}




\section{Types}
\label{sec:types}


\begin{definition}
  \label{def:type}
  \small
  \nopad
  \[\begin{array}[t]{rr@{}l}
    \com{type} &
    \nonterm{\tau} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \kappa \sep 
      \phi \sep 
      \psi \sep 
      \J{LFP[}\alpha\J{]}\tau \sep
      \tau \typdiff \eta \sep
      \gamma
    \end{array}
    \\
    \com{implication} &
    \nonterm{\kappa} & \is 
    \begin{array}[t]{@{}l}
      \J{<} l \J{>} \tau \sep 
      \tau\J{->}\tau
    \end{array}
    \\
    \com{expansion} &
    \nonterm{\phi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{|}\tau \sep 
      \J{EXI[}\Theta\J{]} \Delta \J{:} \tau
    \end{array}
    \\
    \com{refinement} &
    \nonterm{\psi} & \is 
    \begin{array}[t]{@{}l}
      \tau\J{\&}\tau \sep 
      \J{ALL[}\Theta\J{]} \Delta \J{:} \tau
    \end{array}
    \\
    \com{subtractable} &
    \nonterm{\eta} & \is 
    \begin{array}[t]{@{}l}
      \J{EXI[}\Theta \J{]} \eta \sep 
      \rho
    \end{array}
    \\
    \com{pattern} &
    \nonterm{\rho} & \is 
    \begin{array}[t]{@{}l}
      \alpha \sep
      \J{@} \sep
      \J{<}l\J{>}\rho \sep 
      \rho\J{\&}\rho \sep
      \rho\J{*}\rho
    \end{array}
    \\
    \com{sugar} &
    \nonterm{\gamma} & \is 
    \begin{array}[t]{@{}l}
      \J{TOP} \sep \J{BOT} \sep 
      \tau \J{*} \tau 
    \end{array}
  \end{array}\]
\end{definition}

\noindent
Types provide the representation for approximate specification.
To accommodate a high degree of structure reusability,
it is important that the forms of types accommodate a wide range of precision.
To manage the complexity of the various forms, we subdivide the type forms
according to some themes.
A type \ms{\tau} may consist of unit \code{@}, variables \ms{\alpha}, 
implications, expansions, refinements,
least fixed points \ms{\J{LFP[}\alpha \J{]} \tau},
differences \ms{\tau \typdiff \eta}, and sugar.


An implication \ms{\kappa} may take the form of  
an entry \ms{\J{<}l\J{>}\tau} or a path \ms{\tau \J{->} \tau},
reflecting the structure of its inhabitants.
An expansion \ms{\phi} is either a union \ms{\tau \J{|} \tau} or 
an existential \ms{\J{EXI[}\Theta \J{]} \Delta \J{:} \tau},
representing weakenings of their constituent types. 
An existential is parameterized by type variables \ms{\Theta}
and positively qualified by subtyping constraints \ms{\Delta}, 
such that the weaker the qualification, the weaker the existential.
A refinement \ms{\psi} is either an intersection \ms{\tau \J{\&} \tau} or 
a universal \ms{\J{ALL[} \Theta \J{]} \Delta \J{:}\tau},
representing strengthenings of their constituent types. 
An universal is parametrized by type variables \ms{\Theta} 
and negatively qualified by subtyping constraints $\Delta$,
such that the weaker the qualification, the stronger the universal.


A least fixed point \ms{\J{LFP[}\alpha \J{]}}
represents an infinite space of structures, 
such as natural numbers or lists. 
A difference \ms{\tau \typdiff \eta} is a space without inhabitation by certain structures.
The subtracted part is restricted to a subtractable form,
which is a form that our system can decide the inhabitation
assuming additional semantics restrictions.


\begin{definition} 
  \label{def:type_desugaring}
  \emph{type desugaring}
  \hfill 
  \small
  \boxed{\llbracket \gamma \rrbracket^\square = \tau}
  \nopad
  \begin{align*}
    \llbracket \J{TOP} \rrbracket^\square &= \J{EXI[} \alpha \J{]} \alpha
    \\
    \llbracket \J{BOT} \rrbracket^\square &= \J{ALL[} \alpha \J{]} \alpha
    \\
    \llbracket \tau_l \J{*} \tau_r \rrbracket^\square &= (\J{<left>}\ \tau_l)  \J{\&} (\J{<right>}\ \tau_r)
  \end{align*}
\end{definition} 



\noindent
For convenience and clarity, types include syntactic sugar for top $\J{TOP}$, 
bottom $\J{BOT}$, and pairs $\tau \J{*} \tau$.
For any metalanguage statement or term containing sugar $\gamma$, we assume that $\gamma$ is implicitly replaced with $\llbracket \gamma \rrbracket^\square$.

\begin{definition}
  \label{def:sequence}
  \small
  \nopad
  \[\begin{array}[t]{rr@{}l}
    \com{type var seq} &
    \nonterm{\Theta} & \is \epsilon \sep \Theta\ \alpha 
    \\
    \com{subtyping seq} &
    \nonterm{\Delta} & \is \epsilon \sep \Delta \  \tau \J{<:} \tau
    \\
    \com{typing seq} &
    \nonterm{\Gamma} & \is \epsilon \sep \Gamma\ x \hastype \tau
    \\
    \com{zone seq} &
    \nonterm{\Pi} & \is \epsilon \sep \Pi\ (\Theta, \Delta, \tau) 
    \\
    \com{subtractable type seq} &
    \nonterm{\Xi} & \is \epsilon \sep \Xi\ \eta 
    \\
    \com{negatable subtyping seq} &
    \nonterm{\Omega} & \is \epsilon \sep 
      \Omega\ \tau \J{<:} \eta \sep 
      \Omega\ \alpha \J{<:} \tau
    \\
    \com{composite seq} &
    \nonterm{C} & \is \epsilon \sep C\ \iota 
    \\
    \com{item} &
    \nonterm{\iota} & \is 
    \alpha
    \sep 
    \tau \J{<:} \tau
    \sep
    x \hastype \tau
    \sep
    (\Theta, \Delta, \tau)
    \sep
    \eta
    \sep
    \tau \J{<:} \eta

  \end{array}\]
\end{definition}


\noindent
There are various scenarios where objects should be collected into in sequences or sets.
For metalanguage operations or predicates that are generic with respect the form of a collection's items,
it is convenient to have a composite sequence.
A sequence is either empty \ms{\epsilon} or an extension,
such as \ms{C\ \iota} in the case of the composite sequence. 
For clarity, we omit writing \ms{\epsilon} explicitly when describing semantics or instances of the forms.
That is, for any structure, if there is a malformed structure due to a missing piece, 
we assume it is replaced by a well-formed structure, 
where \ms{\epsilon} is inserted wherever necessary to make it well-formed.


\begin{definition} 
  \label{def:sequence_setting}
  \emph{sequence setting}
  \hfill 
  \small
  \boxed{\textbf{set}(C) = S}
  \nopad
  \[
  \begin{array}[t]{r@{}c@{}l}
      \textbf{set}(\epsilon)
      &\ =\ & 
      \emptyset 

      \\

      \textbf{set}(C\ \iota)
      &\ =\ & 
      \textbf{set}(C) \cup [ \iota ] 
  \end{array}
  \]
\end{definition} 

\noindent
In order to leverage set arithmetic and its theory,
we implicitly convert sequences into sets. 
We assume that any sequence \ms{C} may be implicitly replaced with \ms{\textbf{set}(C)}.

\begin{definition} 
  \label{def:set_sequencing}
  \emph{set sequencing}
  \hfill 
  \small
  \boxed{\textbf{seq}(S) = C}
  \nopad
  \\
  \[
  \begin{array}[t]{r@{}c@{}l}
      \textbf{seq}(\emptyset)
      &\ =\ & 
      \epsilon 

      \\

      \textbf{seq}(S \cup [\iota])
      &\ =\ & 
      \textbf{seq}(S \backslash [\iota])\ \iota 
  \end{array}
  \]
\end{definition} 

\noindent
Likewise, it also beneficial to convert sets back into sequences, to leverage
definitions that decompose sequences according to their structures. 
We assume that any set \ms{S} may be implicitly replaced with \ms{\textbf{seq}(S)}.

\begin{definition}
  \label{def:type_map}
  \small
  \nopad
  \[\begin{array}[t]{rr@{}l}
    \com{type map} &
    \nonterm{\delta} & \is \epsilon \sep \delta\ \alpha \slash \tau
  \end{array}\]
\end{definition}

\noindent
A type map assigns variables to types.
Since a type may be constructed from variables, it 
is necessary to specify an interpretation of the variables
when judging the inhabitation of the type.
Thus, typing relies on type maps to provide interpretations
for type variables.



% \TODO{create a seperate relation restricted negations of model typing}

% \TODO{use antec rules to compensate for non-self reference in negative position}

% \TODO{consider renaming to dynamic typing}

% \TODO{completely redo model typing with well founded recursion}

% \TODO{define monotonicity/antitonicity/polarity check}

% \TODO{create recursive definition of least fixed point check}

% \TODO{use separate typing for interpreting variables as finite types}

% \TODO{use non-syntactic description of implication}

% \TODO{remove implication antecedent rules}

% \TODO{lift progression rule out to highest level for monotonic recursion}

% \begin{definition}
%   \label{def:model_progress_typing}
%   \emph{model progressive typing}
%   \hfill
%   \small
%   \boxed{\delta \satisfies e \hastype^* \tau}
%   \nopad
%   \begin{mathpar}
%     \inferrule { 
%       \downharpoonleft e
%       \up
%       \delta \satisfies e \hastype \tau 
%     } {
%       \delta \satisfies e \hastype^* \tau 
%     } 

%     \inferrule { 
%       e \rightsquigarrow e'
%       \\
%       \delta \satisfies e' \hastype^* \tau 
%     } {
%       \delta \satisfies e \hastype^* \tau 
%     } 
%   \end{mathpar}

% \end{definition}

\begin{definition}
  \label{def:typing}
  \emph{typing}
  \hfill
  \small
  \boxed{\delta \satisfies e \hastype \tau}
  \nopad
  \[
  \begin{array}[t]{rclcl}
      \delta \satisfies e \hastype \J{TOP}
      &\iff& 
      e \safe

      \\

      \delta \satisfies e \hastype \J{<} l \J{>} \tau
      &\iff& 
      \delta \satisfies e\J{.}l \hastype \tau 

      \\

      \delta \satisfies e \hastype l \J{:} \tau
      &\iff& 
      \delta \satisfies e\J{.}l \hastype \tau 

      \\

      \delta \satisfies e \hastype \tau_l \J{->} \tau_r
      &\iff& 
      \forall e' \qua
      \delta \satisfies e' \hastype \tau_l 
      \implies
      \delta \satisfies e\J{(}e'\J{)} \hastype \tau_r

      \\

      \delta \satisfies e \hastype \tau_l \J{|} \tau_r 
      &\iff& 
      \delta \satisfies e \hastype \tau_l
      \down
      \delta \satisfies e \hastype \tau_r

      \\

      \delta \satisfies e \hastype \tau_l \J{\&} \tau_r 
      &\iff& 
      \delta \satisfies e \hastype \tau_l
      \up
      \delta \satisfies e \hastype \tau_r

      \\

      \delta \satisfies e \hastype \tau_l \typdiff \tau_r
      &\iff& 
      \delta \satisfies e \hastype \tau_l
      \up
      \delta \not\satisfies e \hastype \tau_r

      \\

      \delta \satisfies e \hastype \J{EXI[}\Theta\J{]}\Delta \J{:} \tau
      &\iff& 
      \exists \delta' \qua
      \textbf{dom}(\delta') \subseteq \Theta
      \up
      \delta' \oplus \delta \satisfies \Delta 
      \up
      \delta' \oplus \delta \satisfies e \hastype \tau

      \\

      \delta \satisfies e \hastype \J{ALL[}\Theta\J{]}\Delta \J{:} \tau
      &\iff& 
      \forall \delta' \qua
      \textbf{dom}(\delta') \subseteq \Theta
      \implies
      \delta' \oplus \delta \satisfies \Delta 
      \implies
      \delta' \oplus \delta \satisfies e \hastype \tau

      \\

      \delta \satisfies e \hastype \J{LFP[}\alpha\J{]}\tau 
      &\iff& 
      \alpha \wr \tau
      \up
      \exists \tau' \qua
        \delta \satisfies \tau' \subtypes \tau \cdot \alpha \slash \tau'
        \up
        \delta \satisfies e \hastype \tau'

      \\

      \delta \satisfies e \hastype \alpha 
      &\iff& 
      \VDash e \hastype \delta(\alpha) 
  \end{array}
  \]
\end{definition}

\begin{definition}
  \label{def:finite_typing}
  \emph{finite typing}
  \hfill
  \small
  \boxed{\VDash e \hastype \tau}
  \nopad
  \[
  \begin{array}[t]{rclcl}

      \VDash e \hastype \J{@}
      &\iff& 
      e \rightsquigarrow^* \J{@}

      \\

      \VDash e \hastype \J{<} l \J{>} \tau
      &\iff& 
      \VDash e\J{.}l \hastype \tau 

      \\

      \VDash e \hastype \tau_l \J{->} \tau_r
      &\iff& 
      \forall e' \qua
      \VDash e' \hastype \tau_l 
      \implies
      \VDash e\J{(}e'\J{)} \hastype \tau_r

      \\

      \VDash e \hastype \tau_l \J{|} \tau_r 
      &\iff& 
      \VDash e \hastype \tau_l
      \down
      \VDash e \hastype \tau_r

      \\

      \VDash e \hastype \tau_l \J{\&} \tau_r 
      &\iff& 
      \VDash e \hastype \tau_l
      \up
      \VDash e \hastype \tau_r

      \\

      \VDash e \hastype \tau_l \typdiff \tau_r
      &\iff& 
      \VDash e \hastype \tau_l
      \up
      \not\VDash e \hastype \tau_r
  \end{array}
  \]
\end{definition}

% \begin{definition}
%   \label{def:model_scratch_typing}
%   \emph{model scratch typing}
%   \hfill
%   \small
%   \boxed{\delta \satisfies e \hastype \tau}
%   \nopad
%   \begin{mathpar}
    % \inferrule { 
    %   \TODO{alt def}
    %   \\\\
    %   \forall \tau' \qua  
    %   \delta \satisfies \tau[\alpha\slash\tau'] \subtypes \tau'
    %   \implies
    %   \delta \satisfies e \hastype \tau'
    % } {
    %   \delta \satisfies e \hastype \J{LFP[} \alpha \J{]} \tau
    % } 

    % \inferrule { 
    %   \delta \ \alpha \slash \J{LFP[}\alpha \J{]} \tau \satisfies e \hastype \tau
    % } {
    %   \delta \satisfies e \hastype \J{LFP[} \alpha \J{]} \tau
    % } 


    % \inferrule { 
    %   \delta \satisfies e \hastype \tau_l
    % } {
    %   \delta \satisfies e \hastype \tau_l \J{|} \tau_r
    % } 

    % \inferrule { 
    %   \delta \satisfies e \hastype \tau_r
    % } {
    %   \delta \satisfies e \hastype \tau_l \J{|} \tau_r
    % } 


    % \inferrule { 
    %   \textbf{dom}(\delta') \subseteq \Theta
    %   \\
    %   \delta \oplus \delta' \satisfies \Delta 
    %   \\
    %   \delta \oplus \delta' \satisfies e \hastype \tau
    % } {
    %   \delta \satisfies e \hastype \J{EXI[}\Theta\J{]}\Delta \J{:} \tau
    % } 

    % \inferrule { 
    %   \delta \satisfies e \hastype \tau_l
    %   \\
    %   \delta \satisfies e \hastype \tau_r
    % } {
    %   \delta \satisfies e \hastype \tau_l \J{\&} \tau_r
    % } 

    % \inferrule { 
    %   \forall \delta' \qua
    %   \textbf{dom}(\delta') \subseteq \Theta \implies
    %   \delta \oplus \delta' \VDash \Delta \implies 
    %   \delta \oplus \delta' \satisfies e \hastype \tau
    %   \\\\
    %   \exists \delta' \qua 
    %   \textbf{dom}(\delta') \subseteq \Theta \up 
    %   \delta \oplus \delta' \satisfies \Delta
    % } {
    %   \delta \satisfies e \hastype \J{ALL[}\Theta\J{]}\Delta \J{:} \tau
    % } 

    % \inferrule { 
    %   \J{<}l \J{>} v \in g
    %   \\
    %   \delta \satisfies v \hastype \tau 
    %   \\
    %   \forall v' \qua \J{<} l \J{>} v' \in g \implies v' = v
    % } {
    %   \delta \satisfies g \hastype \J{<} l \J{>} \tau
    % } 

    % \inferrule { 
    %   \TODO{diff antec}
    %   \\\\
    %   p \Uparrow \eta 
    %   \\
    %   \delta \satisfies f \hastype \tau_l \J{->} \tau_r
    % } {
    %   \delta \satisfies \J{[}p \J{=>} e \J{]}\ f \hastype \tau_l \typdiff \eta \J{->} \tau_r
    % } 


    % \inferrule { 
    %   \TODO{needs separate inter antec}
    %   \\\\
    %   \forall \sigma \qua 
    %   \delta \VDash p[\sigma] \hastype \tau_l
    %   \implies
    %   \delta  \satisfies e[\sigma] \hastype \tau_r
    % } {
    %   \delta \satisfies \J{[}p \J{=>} e \J{]}\ f\hastype \tau_l \J{->} \tau_r
    % }

    % \inferrule { 
    %   \TODO{inter antec left}
    %   \\\\
    %   \delta \satisfies e \hastype \tau_l \J{->} \tau
    % } {
    %   \delta \satisfies e \hastype (\tau_l \J{\&} \tau_r) \J{->} \tau
    % }

    % \inferrule { 
    %   \TODO{inter antec right}
    %   \\\\
    %   \delta \satisfies e \hastype \tau_r \J{->} \tau
    % } {
    %   \delta \satisfies e \hastype (\tau_l \J{\&} \tau_r) \J{->} \tau
    % }

    % \inferrule { 
    %   \TODO{all antec}
    %   \\\\
    %   \textbf{dom}(\delta') \subseteq \Theta 
    %   \\
    %   \delta \oplus \delta' \satisfies \Delta 
    %   \\
    %   \delta \oplus \delta' \satisfies e \hastype \tau_l \J{->} \tau_r
    % } {
    %   \delta \satisfies e \hastype (\J{ALL[}\Theta \J{]}\Delta\ \tau_l) \J{->} \tau_r
    % }

    % \inferrule { 
    %   \TODO{union antec}
    %   \\\\
    %   \delta \satisfies e \hastype \tau_l \J{->} \tau
    %   \\
    %   \delta \satisfies e \hastype \tau_r \J{->} \tau
    % } {
    %   \delta \satisfies e \hastype (\tau_l \J{|} \tau_r) \J{->} \tau
    % }

    % \inferrule { 
    %   \TODO{exi antec}
    %   \\\\
    %   \forall \delta' \qua 
    %   \textbf{dom}(\delta') \subseteq \Theta
    %   \implies
    %   \delta \oplus \delta' \VDash \Delta 
    %   \implies
    %   \delta \satisfies e \hastype \tau_l \J{->} \tau_r
    % } {
    %   \delta \satisfies e \hastype (\J{EXI[} \Theta \J{]}\Delta\ \tau_l) \J{->} \tau_r
    % }

    % \inferrule { 
    %   \TODO{lfp antec}
    %   \\\\
    %   \alpha \notin \textbf{ftv}(\tau_l[\alpha\slash\J{@}]^+)
    %   \\
    %   \delta\ \alpha \slash (\J{LFP[}\alpha \J{]} \tau_l) \satisfies e \hastype \tau_l \J{->} \tau_r
    % } {
    %   \delta \satisfies e \hastype (\J{LFP[}\alpha \J{]} \tau_l) \J{->} \tau_r
    % }

    % \inferrule { 
    %   \delta \satisfies e \hastype \tau_l
    %   \\
    %   \neg\ (\delta \satisfies e \hastype \tau_r)
    % } {
    %   \delta \satisfies e \hastype \tau_l \typdiff \tau_r
    % } 

    % \inferrule { 
    % } {
    %   \delta \satisfies \J{@} \hastype \J{@}
    % } 

    % \inferrule { 
    %   \TODO{remove unflipped}
    %   \\\\
    %   \delta \satisfies f \hastype \tau_l \J{->} \tau_r
    % } {
    %   \delta \satisfies f\ \J{[}p \J{=>} e \J{]}\hastype \tau_l \J{->} \tau_r
    % } 

    % \inferrule { 
    %   \TODO{remove unflipped}
    %   \\\\
    %   \forall \sigma \qua
    %   \delta \satisfies p[\sigma] \hastype \tau_l
    %   \implies
    %   \delta  \satisfies e[\sigma] \hastype \tau_r
    %   \\\\
    %   \forall \tau_l', \tau_r' \qua
    %   \delta \satisfies f \hastype \tau_l' \J{->} \tau_r'
    %   \implies
    %   \delta \satisfies \tau_l \subtypes \tau_l'
    %   \implies
    %   \delta \satisfies \tau_r' \subtypes \tau_r
    % } {
    %   \delta \satisfies f\ \J{[}p \J{=>} e \J{]}\hastype \tau_l \J{->} \tau_r
    % }

    % \inferrule { 
    %   \delta \satisfies f \hastype \tau_l \J{->} \tau_r
    %   \\\\
    %   \forall \tau_l', \tau_r' \qua
    %   \delta \satisfies \J{[}p \J{=>} e \J{]} \hastype \tau_l' \J{->} \tau_r'
    %   \implies
    %   \delta \satisfies \tau_l \subtypes \tau_l'
    %   \implies
    %   \delta \satisfies \tau_r' \subtypes \tau_r
    % } {
    %   \delta \satisfies \J{[}p \J{=>} e \J{]}\ f \hastype \tau_l \J{->} \tau_r
    % } 

    % \inferrule { 
    %   \TODO{how to deal with recursive negative occurence?}
    %   \\\\
    %   \forall v \qua 
    %   \delta \satisfies v \hastype \tau_l
    %   \implies
    %   \exists \sigma \qua
    %   v \simeq p \given \sigma 
    %   \up
    %   \delta  \satisfies e[\sigma] \hastype \tau_r
    % } {
    %   \delta \satisfies \J{[}p \J{=>} e \J{]}\ f\hastype \tau_l \J{->} \tau_r
    % }

    % \inferrule { 
    %   \TODO{how to deal with recursive negative occurence?}
    %   \\\\
    %   \TODO{intersection elim is built into pattern matching}
    %   \\\\
    %   \forall v \qua 
    %   \delta \VDash v \hastype \rho
    %   \implies
    %   \exists \sigma \qua
    %   v \simeq p \given \sigma 
    %   \up
    %   \delta  \satisfies e[\sigma] \hastype \tau_r
    % } {
    %   \delta \satisfies \J{[}p \J{=>} e \J{]}\ f\hastype \rho \J{->} \tau_r
    % }

%   \end{mathpar}
% \end{definition}

\noindent
Model typing describes what expressions inhabit what types,
according to the forms of types, the forms of values, and how expressions
progress into values. 
It imbues types with semantics, which we use
to guide and judge the design of our type inference system. 
In general, a typing holds if its expression can make progress and 
the typing holds for the reduced form.

For inhabitation of a entry \ms{\delta \satisfies g \hastype \J{<}l\J{>}\tau},
the typing holds if the the expression is a record value, and
there is an entry in the record whose content inhabits     
the content of the entry type. Additionally, there must be just one
value per entry in the record. 
For inhabitation of a path 
\ms{\delta \satisfies f\ \J{[}p \J{=>} e \J{]} \hastype \tau_l\J{->}\tau_r},
the typing holds if the the expression is a function,
and there is one path in the function where 
the typing of the path body holds whenever the typing of the pattern holds.   
Additionally, since the paths of a function are tried in order, such that 
only the result of the first matched path is returned,
it is required that either the antecedent of the path type
is not weaker than the antecedent of preceding paths 
or the consequent of the path type is weaker than the consequent
of preceding paths. 

For inhabitation of a difference 
\ms{\delta \satisfies e \hastype \tau_l \typdiff \tau_r},
the typing holds if the expression inhabits the left type
but not the right right.
For inhabitation of a intersection 
\ms{\delta \satisfies e \hastype \tau_l \J{\&} \tau_r},
the typing holds if the expression inhabits both the
left type and the right type. 
For inhabitation of a union 
\ms{\delta \satisfies e \hastype \tau_l \J{|} \tau_r},
the typing holds if the expression inhabits either the
left type or the right type. 

For inhabitation of a universal 
\ms{\delta \satisfies e \hastype \J{ALL[} \Theta \J{]}\Delta\J{:}\tau},
the typing holds if the expression inhabits the constituent type,
under all interpretations of bound variables that satisfy the qualifiers. 
To avoid accepting an erroneous expression inhabiting a vacuous
type, it is required that the qualifiers are satisfiable.  
For inhabitation of an existential 
\ms{\delta \satisfies e \hastype \J{ALL[} \Theta \J{]}\Delta\J{:}\tau},
the typing holds if qualifiers and the inhabitation of the constituent type
are satisfiable by an interpretation of the bound variables.

For inhabitation of a variable \ms{\delta \satisfies e \hastype \alpha},
the typing holds if there's an interpretation for which the typing holds. 
For inhabitation of unit \ms{\delta \satisfies \J{@} \hastype \J{@}},
the typing holds if the expression is unit.
For inhabitation of a least fixed point \ms{\delta \satisfies e \hastype \J{LFP[}\alpha\J{]}\alpha},
the typing holds if the expression also inhabits the inflated type. 

\begin{definition}
  \label{def:model_subtyping}
  \emph{model subtyping}
  \hfill
  \small
  \boxed{\delta \satisfies \tau <: \tau}
  \nopad
  \begin{mathpar}
    \inferrule { 
      \forall e .\ 
      \delta \satisfies e \hastype \tau_l \implies 
      \delta \satisfies e \hastype \tau_r 
    } {
      \delta \satisfies \tau_l <: \tau_r
    } 
  \end{mathpar}
\end{definition}

\noindent
Model subtyping describes how the spaces of two types compare to each other.

\begin{definition}
  \label{def:model_subtyping_sequence}
  \emph{model subtyping sequence} 
  \hfill
  \small
  \boxed{\delta \satisfies \Delta}
  \nopad
  \begin{mathpar}
    \inferrule { 
    } {
      \delta \satisfies \epsilon 
    } 

    \inferrule { 
      \delta \satisfies \Delta 
      \\
      \delta \satisfies \tau_l \subtypes \tau_r
    } {
      \delta \satisfies \Delta \  \tau_l \J{<:} \tau_r
    } 
  \end{mathpar}
\end{definition}

\noindent
Model subtyping sequence describes multiple subtyping constraints. 

\begin{definition}
  \label{def:model_typing_sequence}
  \emph{model typing sequence} 
  \hfill
  \small
  \boxed{\delta, \sigma \satisfies \Gamma}
  \nopad
  \begin{mathpar}
    \inferrule {
      \forall x \qua
      x \hastype \tau \in \Gamma
      \implies
      \delta \satisfies x[\sigma] \hastype \tau
    } {
      \delta, \sigma \satisfies \Gamma
    }
  \end{mathpar}
\end{definition}

\noindent
Model typing sequence describes multiples typings of variables.



\section{Rules}
\label{sec:rules}


\section{Related Work}
\label{sec:related_work}

\section{Conclusion}
\label{sec:conclusion}


\newpage

\begin{thebibliography}{9}

% \bibitem{syngar}
% X. Wang, I, Dillig, R. Singh. Program synthesis using abstraction refinement. In POPL, 2017.

% \bibitem{love}
% M. Heizmann, J. Hoenicke, A. Podelski. Software model checking for people who love automata. In CAV, 2013. 

% \bibitem{synquid}
% N. Polikarpova, I. Kuraj, A. Solar-Lezama. Program synthesis from polymorphic refinement types. In PLDI, 2016.

\end{thebibliography}

\end{document}