# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass



from core.line_format_autogen import LineFormat 
    


# type Pattern
@dataclass(frozen=True, eq=True)
class Pattern(ABC):
    @abstractmethod
    def match(self, handler : PatternHandler[T]) -> T:
        pass

# constructors for type Pattern

@dataclass(frozen=True, eq=True)
class Terminal(Pattern):
    vocab : str

    def match(self, handler : PatternHandler[T]) -> T:
        return handler.case_Terminal(self)

def make_Terminal(
    vocab : str
) -> Pattern:
    return Terminal(
        vocab
    )

def update_Terminal(source_Terminal : Terminal,
    vocab : Union[str, SourceFlag] = SourceFlag()
) -> Terminal:
    return Terminal(
        source_Terminal.vocab if isinstance(vocab, SourceFlag) else vocab
    )

        

@dataclass(frozen=True, eq=True)
class Nonterm(Pattern):
    grammar : str
    format : LineFormat

    def match(self, handler : PatternHandler[T]) -> T:
        return handler.case_Nonterm(self)

def make_Nonterm(
    grammar : str, 
    format : LineFormat
) -> Pattern:
    return Nonterm(
        grammar,
        format
    )

def update_Nonterm(source_Nonterm : Nonterm,
    grammar : Union[str, SourceFlag] = SourceFlag(),
    format : Union[LineFormat, SourceFlag] = SourceFlag()
) -> Nonterm:
    return Nonterm(
        source_Nonterm.grammar if isinstance(grammar, SourceFlag) else grammar,
        source_Nonterm.format if isinstance(format, SourceFlag) else format
    )

        

# case handler for type Pattern
class PatternHandler(ABC, Generic[T]):
    @abstractmethod
    def case_Terminal(self, o : Terminal) -> T :
        pass
    @abstractmethod
    def case_Nonterm(self, o : Nonterm) -> T :
        pass

     


# type and constructor Rule
@dataclass(frozen=True, eq=True)
class Rule:
    name : str
    content : list[Item]


def make_Rule(
    name : str,
    content : list[Item]
) -> Rule:
    return Rule(
        name,
        content)

def update_Rule(source_Rule : Rule,
    name : Union[str, SourceFlag] = SourceFlag(),
    content : Union[list[Item], SourceFlag] = SourceFlag()
) -> Rule:
    return Rule(
        source_Rule.name if isinstance(name, SourceFlag) else name, 
        source_Rule.content if isinstance(content, SourceFlag) else content)

    

# type and constructor Item
@dataclass(frozen=True, eq=True)
class Item:
    relation : str
    pattern : Pattern


def make_Item(
    relation : str,
    pattern : Pattern
) -> Item:
    return Item(
        relation,
        pattern)

def update_Item(source_Item : Item,
    relation : Union[str, SourceFlag] = SourceFlag(),
    pattern : Union[Pattern, SourceFlag] = SourceFlag()
) -> Item:
    return Item(
        source_Item.relation if isinstance(relation, SourceFlag) else relation, 
        source_Item.pattern if isinstance(pattern, SourceFlag) else pattern)

     
    