# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass



from lwtapas.base.line_format_autogen import line_format
        


# type Item
@dataclass(frozen=True, eq=True)
class Item(ABC):
    @abstractmethod
    def match(self, handler : ItemHandler[T]) -> T:
        pass

# constructors for type Item

@dataclass(frozen=True, eq=True)
class Terminal(Item):
    terminal : str

    def match(self, handler : ItemHandler[T]) -> T:
        return handler.case_Terminal(self)

def make_Terminal(
    terminal : str
) -> Item:
    return Terminal(
        terminal
    )

def update_Terminal(source_Terminal : Terminal,
    terminal : Union[str, SourceFlag] = SourceFlag()
) -> Terminal:
    return Terminal(
        source_Terminal.terminal if isinstance(terminal, SourceFlag) else terminal
    )

        

@dataclass(frozen=True, eq=True)
class Nonterm(Item):
    relation : str
    nonterminal : str
    format : LineFormat

    def match(self, handler : ItemHandler[T]) -> T:
        return handler.case_Nonterm(self)

def make_Nonterm(
    relation : str, 
    nonterminal : str, 
    format : LineFormat
) -> Item:
    return Nonterm(
        relation,
        nonterminal,
        format
    )

def update_Nonterm(source_Nonterm : Nonterm,
    relation : Union[str, SourceFlag] = SourceFlag(),
    nonterminal : Union[str, SourceFlag] = SourceFlag(),
    format : Union[LineFormat, SourceFlag] = SourceFlag()
) -> Nonterm:
    return Nonterm(
        source_Nonterm.relation if isinstance(relation, SourceFlag) else relation,
        source_Nonterm.nonterminal if isinstance(nonterminal, SourceFlag) else nonterminal,
        source_Nonterm.format if isinstance(format, SourceFlag) else format
    )

        

@dataclass(frozen=True, eq=True)
class Vocab(Item):
    relation : str
    vocab : str

    def match(self, handler : ItemHandler[T]) -> T:
        return handler.case_Vocab(self)

def make_Vocab(
    relation : str, 
    vocab : str
) -> Item:
    return Vocab(
        relation,
        vocab
    )

def update_Vocab(source_Vocab : Vocab,
    relation : Union[str, SourceFlag] = SourceFlag(),
    vocab : Union[str, SourceFlag] = SourceFlag()
) -> Vocab:
    return Vocab(
        source_Vocab.relation if isinstance(relation, SourceFlag) else relation,
        source_Vocab.vocab if isinstance(vocab, SourceFlag) else vocab
    )

        

# case handler for type Item
class ItemHandler(ABC, Generic[T]):
    @abstractmethod
    def case_Terminal(self, o : Terminal) -> T :
        pass
    @abstractmethod
    def case_Nonterm(self, o : Nonterm) -> T :
        pass
    @abstractmethod
    def case_Vocab(self, o : Vocab) -> T :
        pass

     


# type and constructor Rule
@dataclass(frozen=True, eq=True)
class Rule:
    name : str
    content : list[Item]


def make_Rule(
    name : str,
    content : list[Item]
) -> Rule:
    return Rule(
        name,
        content)

def update_Rule(source_Rule : Rule,
    name : Union[str, SourceFlag] = SourceFlag(),
    content : Union[list[Item], SourceFlag] = SourceFlag()
) -> Rule:
    return Rule(
        source_Rule.name if isinstance(name, SourceFlag) else name, 
        source_Rule.content if isinstance(content, SourceFlag) else content)

     
    