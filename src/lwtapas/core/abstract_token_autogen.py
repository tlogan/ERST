# THIS FILE IS AUTOGENERATED
# CHANGES MAY BE LOST



from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, TypeVar, Any, Generic, Union, Optional
from collections.abc import Callable

from abc import ABC, abstractmethod

T = TypeVar('T')


@dataclass(frozen=True, eq=True)
class SourceFlag: 
    pass





# type AbstractToken
@dataclass(frozen=True, eq=True)
class AbstractToken(ABC):
    @abstractmethod
    def match(self, handler : AbstractTokenHandler[T]) -> T:
        pass

# constructors for type AbstractToken

@dataclass(frozen=True, eq=True)
class Grammar(AbstractToken):
    options : str
    selection : str
    source_start : int
    source_end : int

    def match(self, handler : AbstractTokenHandler[T]) -> T:
        return handler.case_Grammar(self)

def make_Grammar(
    options : str, 
    selection : str, 
    source_start : int = 0, 
    source_end : int = 0
) -> AbstractToken:
    return Grammar(
        options,
        selection,
        source_start,
        source_end
    )

def update_Grammar(source_Grammar : Grammar,
    options : Union[str, SourceFlag] = SourceFlag(),
    selection : Union[str, SourceFlag] = SourceFlag(),
    source_start : Union[int, SourceFlag] = SourceFlag(),
    source_end : Union[int, SourceFlag] = SourceFlag()
) -> Grammar:
    return Grammar(
        source_Grammar.options if isinstance(options, SourceFlag) else options,
        source_Grammar.selection if isinstance(selection, SourceFlag) else selection,
        source_Grammar.source_start if isinstance(source_start, SourceFlag) else source_start,
        source_Grammar.source_end if isinstance(source_end, SourceFlag) else source_end
    )

        

@dataclass(frozen=True, eq=True)
class Vocab(AbstractToken):
    options : str
    selection : str

    def match(self, handler : AbstractTokenHandler[T]) -> T:
        return handler.case_Vocab(self)

def make_Vocab(
    options : str, 
    selection : str
) -> AbstractToken:
    return Vocab(
        options,
        selection
    )

def update_Vocab(source_Vocab : Vocab,
    options : Union[str, SourceFlag] = SourceFlag(),
    selection : Union[str, SourceFlag] = SourceFlag()
) -> Vocab:
    return Vocab(
        source_Vocab.options if isinstance(options, SourceFlag) else options,
        source_Vocab.selection if isinstance(selection, SourceFlag) else selection
    )

        

@dataclass(frozen=True, eq=True)
class Hole(AbstractToken):


    def match(self, handler : AbstractTokenHandler[T]) -> T:
        return handler.case_Hole(self)

def make_Hole(
) -> AbstractToken:
    return Hole(
    )

def update_Hole(source_Hole : Hole
) -> Hole:
    return Hole(
    )

        

# case handler for type AbstractToken
class AbstractTokenHandler(ABC, Generic[T]):
    @abstractmethod
    def case_Grammar(self, o : Grammar) -> T :
        pass
    @abstractmethod
    def case_Vocab(self, o : Vocab) -> T :
        pass
    @abstractmethod
    def case_Hole(self, o : Hole) -> T :
        pass

     

 
    