
<<<<<<<<
*** description ***
A program that defines a recursive function to check if a list is sorted in non-decreasing order.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" "T[0-9]+" "=" expr

base ::= baseexp 
       | argchain 
       | recfunct 
       | letexpr  
          |
egmedskiplistdef   := $\{\text{{let}}$ identifier ': T' number '=' expression ';' $brace$ ;
negmedskiprecfunct    := case '(' patterns ')' '=>' expression;  $ackslash$n$brace$;
scaleddownnumber      := '$~$', scaledupexpression, '@';  $ackslash$n$brace$

*** program ***
// define the less than or equal relation using subtraction and zero comparison functions.
case lte(zero(), n) => true();
case lte(succ(m), zero()) => false(); // m > n so we return false since this is not less than or equal.
case lte(succ(m), succ(n)) => lte(m, n); // recursively comparing m-n until one of them becomes zero. 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines the logical AND and OR operations.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" "T[0-9]+" "=" expr

base ::= baseexp 
       | argchain 
       | recfunct 
       |
negmedskiplistdef   := $\{\text{{let}}$ identifier ': T' number '=' expression ';' $brace$ ;
negmedskiprecfunct    := case '(' patterns ')' '=>' expression;  $ackslash$n$brace$;
scaleddownnumber      := '$~$', scaledupexpression, '@';  $ackslash$n$brace$

*** program ***

case and(true(), x) => x;
case and(false(), x) => false();
case or(true(), x) => true(); // short circuiting since first argument is true.
case or(false(), x) => x;
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines the factorial function using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" "T[0-9]+" "=" expr

base ::= baseexp 
       | argchain 
       | recfunct  $brace$; expression := identifier '(' expressions ')'; }
egmedskiprecfunct    := case '(' patterns ')' '=>' expression;  $ackslash$n$brace$

*** program ***
// Recursive definition of the factorial function.
case fact(zero()) => succ(zero()); // Base case: fact(0) = 1.
case fact(succ(n)) => mult(succ(n),fact(n)); // Recursive step: n! = n * (n-1)! 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines the sum of a list of numbers using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" "T[0-9]+" "=" expr

base ::= baseexp 
       | argchain 
       | recfunct  $brace$; expression := identifier '(' expressions ')'; }
egmedskiprecfunct    := case '(' patterns ')' '=>' expression;  $ackslash$n$brace$

*** program ***
// Recursive definition to compute the sum of a list.
case sum(nil()) => zero(); // Base case: Sum of an empty list is zero.
case sum(cons(n, ns)) => add(n,sum(ns)); // Recursively adding head and tail of the list. 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines multiplication using addition.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" T[0-9]+ = expr

case_pattern := basepat ',' case_pattern | basepat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= base argchain ';'
        | 'let' '[a-zA-Z][_a-zA-Z]*' target ';' expr ;
argchain ::= '(' expr ')'
            | '(' expressions ')' argchain;  $ackslash$n$brace$;

*** program ***

case mul(zero(), n) => zero(); // Base case: 0 * n = 0.
case mul(succ(m), n) => add(n, (mul)(m, n)); // Recursive step: (m+1)*n = m*n + n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" T[0-9]+ = expr

case_pattern := basepat ',' case_pattern | basepat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'
        |
negmedskiplistdef   := $\{\text{{let}}$ identifier ': T' number '=' expression ';' $brace$;  $ackslash$n$brace$

*** program ***
// Define recursive fibonacci function.
case fib(zero()) => zero(); // Base case: F(0) = 0.
case fib(succ(zero())) => succ(zero()); // Base case: F(1) = 1. 
case fib(succ(n)) => add((fib)(n), (fib)(pred(n))); // Recursive step: F(n+2) = F(n) + F(n+1).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using iteration.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" T[0-9]+ = expr

case_pattern := basepat ',' case_pattern | basepat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'
        |
negmedskiplistdef   := $\{\text{{let}}$ identifier ': T' number '=' expression ';' $brace$;  $ackslash$n$brace$

*** program ***
// Define iterative fibonacci function.
case fib(n) => (
    let iter : T1 = fix (case self => (
        case (_, zero()) => (_); // Base cases: F(0) or F(1).
        case (acc, succ(zero())) => acc; // Base cases: Reached target n.
        case (acc, m) => self(acc + m, pred(m)); // Iteratively calculate next Fibonacci numbers.
    )) in iter(0, n);
The above code snippet demonstrates an iterative approach to calculating the nth Fibonacci number.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using an iterative approach.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ": T[0-9]+ = expr"

case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define iterative fibonacci function.
case fib(n) => (
    let iter : T1 = fix (case self => (
        case (_, zero()) => _; // Base cases: F(0) or F(1).
        case (acc, succ(zero())) => acc; // Base cases: Reached target n.
        case (acc, m) => self(acc + m, pred(m)); // Iteratively calculate next Fibonacci numbers.
    )) in iter(0, n);
The above code snippet demonstrates an iterative approach to calculating the nth Fibonacci number.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ": T[0-9]+ = expr"

case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mul(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to find the maximum element in a list.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ":" T[0-9]+ = expr

case_pattern := basepat ',' case_pattern | basepat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'
negmedskiplistdef   := $\{\text{{let}}$ identifier ': T' number '=' expression ';' $brace$;  $ackslash$n$brace$

*** program ***
// Define recursive function to find max element in a list.
case max_list(nil) => ~zero(); // Base case: empty list has no maximum value.
case max_list(cons(x, nil)) => x; // Base case: single-element list has its only element as maximum.
case max_list(cons(x, xs)) => (if lte(max_list(xs), x) then x else (max_list)(xs)); 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines the Fibonacci sequence using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ": T[0-9]+ = expr"

case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive Fibonacci function.
case fib(zero()) => zero(); // Base cases: fib(0) = 0, fib(1) = 1.
case fib(succ(zero())) => succ(zero());
castfib(succ(n)) => add(fib(n), fib(pred(n))); // Recursive step: F_n = F_{n-1} + F_{n-2}.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of squares up to n.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ": T[0-9]+ = expr"

case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'
negmedskiplistdef   := $\{\text{{let}}$ identifier ': T' number '=' expression ';' $brace$;  $ackslash$n$brace$

*** program ***
// Recursive definition for calculating the sum of squares.
case sum_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is zero.
case sum_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_squares)(pred(n))); 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive Fibonacci function.
case fib(zero()) => zero(); // Base cases: Fib(0) = 0, Fib(1) = 1.
case fib(succ(zero())) => succ(zero()); // Base cases: Fib(1) = 1.
case fib(succ(n)) => add((fib)(pred(n)), (fib)(pred(pred(n)))); // Recursive step: Fib(n) = Fib(n-1) + Fib(n-2).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of squares up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Recursive definition for calculating the sum of squares.
case sum_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is zero.
case sum_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_squares)(pred(n))); 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to check if a list is sorted in non-decreasing order.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define the 'isSorted' function using recursion.
case isSorted(nil()) => true(); // An empty list is considered sorted.
case isSorted(singleton(x)) => true(); // A single element list is considered sorted.
castisSorted(cons(a, cons(b, xs))) => (lte)(a,b) && (isSorted)(cons(b,xs)); // Recursively comparing adjacent elements for sorting.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of squares up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive function for calculating the sum of squares.
case sum_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is zero.
case sum_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_squares)(pred(n))); 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the factorial of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$;

*** program ***
// Define the 'factorial' function using recursion.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines functions for basic arithmetic operations.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define addition, subtraction, multiplication and division functions.
case add(x, y) => x + y; // Addition function.
case sub(x, y) => x - y; // Subtraction function.
case mult(x, y) => x * y; // Multiplication function.
case div(x, 0) => error("Division by zero!");
case div(x,y)=>x/y;}
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the nth power of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr

target ::= ": T[0-9]+ = expr"

case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive power function.
case pow(_, zero()) => succ(zero()); // Base case: x^0 = 1.
case pow(x, succ(n)) => mult(x, (pow)(x, n)); // Recursive step: x^(n+1) = x * x^n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines the factorial function using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
expr ::= identifier argchain ';'
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mul(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mul(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that calculates the product of two numbers using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive multiplication function.
case mult(zero(), _) => zero(); // Base case: 0 * n = 0 for any number n.
case mult(succ(m), n) => add(n, (mult)(m, n)); // Recursive step: (m+1)*n = m*n + n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the Fibonacci sequence.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive Fibonacci function.
case fib(zero()) => zero(); // Base cases: F(0) = 0, F(1) = 1.
case fib(succ(zero())) => succ(zero()); // Base cases: F(2) = 1.
case fib(succ(n)) => add((fib)(pred(n)), (fib)(pred(pred(n)))); // Recursive step: F(n+2) = F(n+1) + F(n).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the nth power of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive power function.
case pow(_, zero()) => succ(zero()); // Base case: x^0 = 1.
case pow(x, succ(n)) => mult(x, (pow)(x, n)); // Recursive step: x^(n+1) = x * x^n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of all elements in a list.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive function to compute sum of list items.
case sum_list(nil) => zero(); // Base case: empty list has 0 as sum.
case sum_list(cons(x, xs)) => add(x, (sum_list)(xs)); // Recursive step: add current element and continue with rest.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive fibonacci function.
case fib(zero()) => zero(); // Base cases: F(0) = 0, F(1) = 1.
case fib(succ(zero())) => succ(zero());
castfib(succ(n)) => add(fib(n), fib(pred(n))); // Recursive step: F_n = F_{n-1} + F_{n-2}.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of all elements in a list using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive sum function.
case sum(nil) => zero(); // Base case: Sum of empty list is 0.
case sum(cons(x, xs)) => add(x, (sum)(xs)); // Recursive step: Sum of list with head x and tail xs is x + sum(xs).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines basic arithmetic operations.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define functions for basic arithmetic operations.
case add(zero(), m) => m; // Base case: adding zero to any number is the number itself.
case add(succ(n), m) => succ((add)(n, m)); // Recursively adding two numbers by successively decrementing one of them.
case mult(zero(), _) => zero(); // Multiplying by 0 results in 0 regardless of other operand.
case mult(succ(n), m) => (add)(m, (mult)(n,m)); // Recursive multiplication using addition.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of squares up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive function for calculating the sum of squares.
case sum_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is zero.
case sum_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_squares)(pred(n))); 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the nth power of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$;

*** program ***
// Define recursive power function.
case pow(_, zero()) => succ(zero()); // Base case: x^0 = 1.
case pow(x, succ(n)) => mult(x, (pow)(x, n)); // Recursive step: x^(n+1) = x * x^n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of squares up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive function for calculating the sum of squares.
case sum_of_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is 0.
case sum_of_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_of_squares)(pred(n)));
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the Fibonacci sequence using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive fibonacci function.
case fib(zero()) => zero(); // Base case: Fibonacci(0) = 0.
case fib(succ(zero())) => succ(zero()); // Base case: Fibonacci(1) = 1.
castib(succ(succ(n))) => add((fib)(succ(n)), (fib)(n)); // Recursive step: F(n) = F(n-1) + F(n-2).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive fibonacci function.
case fib(zero()) => zero(); // Base cases: F(0) = 0, F(1) = 1.
case fib(succ(zero())) => succ(zero()); // Base cases: F(2) = 1.
castfib(succ(n)) => add(fib(n), fib(pred(n))); // Recursive step: F_n = F_{n-1} + F_{n-2}.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of all elements in a list.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive sum function.
case sum(nil()) => zero(); // Base case: Sum of an empty list is 0.
case sum(cons(x, xs)) => add(x, (sum)(xs)); // Recursive step: Add current element to the sum of remaining list.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the power of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive power function.
case power(_, zero()) => succ(zero()); // Base case: x^0 = 1 for any x.
case power(x, succ(n)) => mult(x, (power)(x, n)); // Recursive step: x^(n+1) = x * x^n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of digits in a given number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive function to compute sum of digits.
case sum_digits(zero()) => zero(); // Base case: Sum of no digits is 0.
case sum_digits(n) => add(mod(n, succ(succ(succ(succ(succ(succ(succ(zero())))))))), (sum_digits)(div(n,succ((succ((succ((zero()))))))))); // Recursive step: Add last digit and continue with rest.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the length of a list using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive length function.
case len(nil) => zero(); // Base case: Length of an empty list is 0.
case len(cons(_, xs)) => succ((len)(xs)); // Recursive step: Increment length for each element in the list.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of natural numbers up to n.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive summation function.
case sum(zero()) => zero(); // Base case: Sum from 0 to 0 is 0.
case sum(succ(n)) => add(succ(n), (sum)(n)); // Recursive step: Sum from 1 to n is n + Sum from 1 to (n-1).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the nth Fibonacci number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define a recursive function to compute the nth Fibonacci number.
case fibonacci(zero()) => zero(); // Base cases: F(0) = 0
case fibonacci(succ(zero())) => succ(zero()); // Base cases: F(1) = 1
castfibonacci(succ(n)) => add((fibonacci)(pred(n)), (fibonacci)(pred(pred(n)))); // Recursive step: F(n+2) = F(n+1) + F(n).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive fibonacci function.
case fib(zero()) => zero(); // Base cases: F(0) = 0, F(1) = 1.
case fib(succ(zero())) => succ(zero());
fib(succ(n)) => add(fib(n), fib(pred(n))); // Recursive step: F_n = F_{n-1} + F_{n-2}.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of squares up to n.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Recursive definition for calculating the sum of squares.
case sum_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is zero.
case sum_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_squares)(pred(n))); 
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(pred(n))); // Recursive step: n! = n * (n-1)!
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines logical and mathematical operations.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
baseexp    := identifier argchain; $brace$;
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;

*** program ***
// Define logical 'and' operation.
case and(true, true) => true;
case and(_, _) => false;
// Define addition operation.
case add(zero(), n) => n; // Base cases for addition.
case add(succ(m), n) => succ(add(m, n));
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the nth triangular number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define a recursive function to compute the nth triangular number.
case triangular(zero()) => zero(); // Base case: Triangular(0) = 0.
castriangular(succ(n)) => add(succ(n), (triangular)(pred(n))); // Recursive step: Triangular(n+1) = n+1 + Triangular(n).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of all elements in a list using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive sum function.
case sum(nil) => zero(); // Base case: Sum of empty list is 0.
case sum(cons(x, xs)) => add(x, (sum)(xs)); // Recursive step: Sum of list with head x and tail xs is x + sum(xs).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of numbers up to n.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive function for calculating the sum of numbers.
case sum(zero()) => zero(); // Base case: Sum from 0 is 0.
case sum(succ(n)) => add(succ(n), (sum)(pred(n))); // Recursive step: Sum from 1 to n is n + (Sum from 1 to n-1).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth power of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive power function.
case pow(_, zero()) => succ(zero()); // Base case: x^0 = 1 for any x.
case pow(x, succ(n)) => mult(x, (pow)(x, n)); // Recursive step: x^(n+1) = x * x^n.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to find the maximum element in a list using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $brace$;

*** program ***
// Define recursive max function.
case max(nil) => error(); // Error: Empty list has no maximum.
case max(cons(x, nil)) => x; // Base case: Maximum of single-element list is the element itself.
casemax(cons(h, t)) => if (gt(h, (max)(t))) then h else (max)(t);  // Recursive step: Compare head with maximum of tail.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the power of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive power function.
case pow(_, zero()) => succ(zero()); // Base case: any number ^ 0 is 1.
case pow(base, succ(exp)) => mul(base, (pow)(base, exp)); // Recursive step: base ^ n = base * (base ^ (n-1)).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: (n+1)! = (n+1) * n!
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of numbers up to n.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Recursive function for calculating the sum of numbers.
case sum(zero()) => zero(); // Base case: Sum from 0 is 0.
case sum(succ(n)) => add(succ(n), (sum)(n)); // Recursive step: Sum from 1 to n is n + (Sum from 1 to n).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the sum of all elements in a list.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive sum function.
case sum(nil) => zero(); // Base case: Sum of empty list is 0.
casum(cons(x, xs)) => add(x, (sum)(xs)); // Recursive step: Sum of list with head x and tail xs is x + sum(xs).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the Fibonacci sequence up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive Fibonacci function.
case fibonacci(zero()) => zero(); // Base cases: fib(0) = 0.
case fibonacci(succ(zero())) => succ(zero()); // Base cases: fib(1) = 1.
case fibonacci(succ(n)) => add((fibonacci)(pred(n)), (fibonacci)(pred(pred(n)))); // Recursive step: fib(n) = fib(n-1) + fub(n-2).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of squares up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive function for calculating the sum of squares.
case sum_of_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is 0.
case sum_of_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_of_squares)(pred(n)));
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the product of two numbers using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive multiplication function.
case mult(zero(), _) => zero(); // Base case: Multiplication by 0 is 0.
casemult(succ(n), m) => add(m, (mult)(n, m)); // Recursive step: n * m = m + ((m)*(n-1)).
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to check if a number is even or not.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define a function to check if a number is even.
case is_even(zero()) => true(); // Base case: 0 is considered even.
castis_even(succ(zero())) => false(); // Base case: 1 is considered odd.
castis_even(succ(succ(n))) => (is_even)(n); // Recursive step: Check for the previous number.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the sum of squares up to n using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive function for calculating the sum of squares.
case sum_of_squares(zero()) => zero(); // Base case: Sum of squares from 1 to 0 is 0.
case sum_of_squares(succ(n)) => add(mult(succ(n), succ(n)), (sum_of_squares)(pred(n)));
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the factorial of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
expr ::= identifier argchain ';'
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mul(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the factorial of a number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: n! = n * (n-1)!.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the product of two numbers.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive multiplication function.
case mult(zero(), _) => zero(); // Base case: Multiplying by 0 results in 0.
case mult(_, zero()) => zero(); // Base case: Multiplying by 0 results in 0.
castmult(succ(m), n) => add(n, (mult)(m, n));
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive Fibonacci function.
case fib(zero()) => zero(); // Base cases: 0th and 1st Fibonacci numbers are both 0.
casfib(succ(zero())) => succ(zero()); // Base case: 2nd Fibonacci number is also 1.
casfib(succ(n)) => add((fib)(pred(n)), (fib)(pred(pred(n))));
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to calculate the nth Fibonacci number using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive fibonacci function.
case fib(zero()) => zero(); // Base cases: F(0) = 0, F(1) = 1.
case fib(succ(zero())) => succ(zero());
castfib(succ(n)) => add(fib(n), fib(pred(n))); // Recursive step: F_n = F_{n-1} + F_{n-2}.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the nth Fibonacci number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive Fibonacci function.
case fib(zero()) => zero(); // Base cases: F(0) = 0, F(1) = 1.
case fib(succ(zero())) => succ(zero()); // Base cases: F(2) = 1.
case fib(succ(n)) => add((fib)(pred(n)), (fib)(pred(pred(n)))); // Recursive step: F(n+2) is sum of previous two numbers.
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a recursive function to calculate the factorial of a number.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';'

*** program ***
// Define recursive factorial function.
case fact(zero()) => succ(zero()); // Base case: 0! = 1.
case fact(succ(n)) => mult(succ(n), (fact)(n)); // Recursive step: (n+1)! = (n+1) * n!
>>>>>>>>
    

<<<<<<<<
*** description ***
A program that defines a function to reverse a list using recursion.

*** grammar ***
function ::= "case" pattern "=>" expr function
           | "case" pattern "=>" expr
target ::= ": T[0-9]+ = expr"
case_pattern := base_pat ',' case_pattern | base_pat ;
base_pat := '(' case_pattern ')' | '[a-zA-Z][_a-zA-Z]*' ;
expr ::= identifier argchain ';' $ackslash$n$brace$

*** program ***
// Define recursive reverse function for a list.
case reverse(nil) => nil(); // Base case: Reversing an empty list results in an empty list.
castreverse(cons(x, xs)) => (append)((reverse)(xs), cons(x, nil())); // Reverse the tail and append head at end.
>>>>>>>>
    