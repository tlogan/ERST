{"description": "A program that defines some basic values.", "grammar": "target ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | base", "program": "let unit : T0 = @ ;\nlet true : T1 = ~true @ ;\nlet false : T2 = ~false @ ;\nlet zero : T3 = ~zero @ ;\nlet one : T4 = ~succ ~zero @ ;\nlet two : T5 = ~succ ~succ ~zero @ ;\n@"}
{"description": "A program that defines a function that takes a list and returns its length.", "grammar": "target ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbase ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | base argchain\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\"", "program": "let length : T0 = fix(case self => (\n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => ~succ (self(xs)) \n)) ;\n@"}
{"description": "A program that defines a function that takes a boolean and a list and returns its length or the list paired with its length.", "grammar": "target ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbase ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | \"if\" expr \"then\" expr \"else\" expr\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"", "program": "let length : T0 = fix(case self => (\n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => ~succ (self(xs)) \n)) ;\nlet maybe_with_length : T1 = (case (b, l) => (\n    (if b then\n        ((length)(l), l)\n    else\n        (length)(l)\n    )\n)) ;\n@"}
{"description": "A program that defines construction of a pair by calling two different functions on the same input.", "grammar": "base ::= \"@\"\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | base\n       | base \",\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\nbasepat ::= \"(\" pattern \")\"\n          | recpat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\npattern ::= basepat\n\nrecpat ::= \"_.\" \"[a-zA-Z][_a-zA-Z]*\" \"=\" pattern", "program": "let f : T0 = (case (_.uno = x) => x) ;\nlet g : T1 = (case (_.dos = x) => x) ;\nlet make_pair : T2 = case x => (\n    ((f)(x), (g)(x))\n) ;\n@"}
{"description": "A program that defines addition.", "grammar": "base ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\"", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) ;\n@"}
{"description": "A program that defines less-than-or-equal of two numbers and maximum of two numbers.", "grammar": "target ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbase ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | \"if\" expr \"then\" expr \"else\" expr\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"", "program": "let lte : T0 = fix(case self => (\n    case (~zero @, n) => ~true @ \n    case (~succ m, ~succ n) => self(m,n) \n    case (~succ m, ~zero @) => ~false @ \n)) ;\nlet max : T1 = case (x, y) => (\n    if (lte)(x, y) then\n        y\n    else\n        x\n) ;\n@"}
{"description": "A program that defines addition and multiplication.", "grammar": "base ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) ;\nlet plus : T1 = add ;\nlet mult : T2 = fix (case self => ( \n    case (~zero @, n) => ~zero \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) ;\nlet times : T3 = fix (case self => ( \n    case (~zero @, n) => ~zero \n    case (~succ m, n) => (plus)(n, (self)(m, n))\n)) ;\n@"}
{"description": "A program that defines addition, summation from left, and summation from right.", "grammar": "base ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) ;\nlet suml : T1 = fix (case self => ( \n    case (~nil @, b) => b\n    case (~cons (x, xs), b) => self(xs, (add)(b, x))\n)) ;\nlet sumr : T2 = fix (case self => ( \n    case (~nil @, b) => b\n    case (~cons (x, xs), b) => (add)((self)(xs, b), x)\n)) ;\n@"}
{"description": "a program that defines the fibonacci sequence.", "grammar": "base ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) ;\nlet fib : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ ~zero @) => ~succ ~zero @\n    case (~succ ~succ n) => (add)((self)(~succ n), (self)(n))\n)) ;\n@"}
{"description": "a program that defines the factorial.", "grammar": "base ::= \"@\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | argchain\n       | function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \";\" expr\n       | \"fix\" \"(\" expr \")\"\n       | base\n       | base argchain\n       | base \",\" expr\n\npattern ::= basepat \",\" pattern\n          | basepat\n\nbasepat ::= \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) ;\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) ;\nlet fact : T2 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) ;\n@"}