**********************************************
<<<description>>> 
A program that defines a function to compute the power of a number.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let power : T2 = fix (case self => (
    case (x, ~zero @) => ~succ ~zero @
    case (x, ~succ n) => (mult)(x, (self)(x, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, xs)) => (add)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let isEven : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ ~succ n) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is odd.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let isOdd : T0 = fix (case self => ( 
    case (~zero @) => ~false @
    case (~succ ~zero @) => ~true @
    case (~succ ~succ n) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let cons : T0 = (case (x, xs) => ~cons(x, xs)) in
let append : T1 = fix (case self => (
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => self(xs, (cons)(x, ys))
)) in
let reverse : T2 = fix (case self => (
    case (~nil @) => ~nil @
    case (~cons (x, xs)) => (append)((self)(xs), (cons)(x, ~nil @))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to find the maximum element in a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~cons (x, ~nil @)) => x
    case (~cons (x, ~cons (y, ys))) => (
        if (lte)(x, y) then
            self(~cons (y, ys))
        else
            self(~cons (x, ys))
    )
)) in
@
**********************************************
<<<description>>> 
A program that defines a function that checks if a tree is balanced.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let absdiff : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => self(m, n)
)) in
let height : T1 = fix (case self => (
    case (~leaf @) => ~succ ~zero @
    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))
)) in
let isBalanced : T2 = fix (case self => (
    case (~leaf @) => ~true @
    case (~node (l, r)) => (
        if (and)((self)(l), (self)(r)) then
            (lte)((absdiff)((height)(l), (height)(r)), ~succ ~zero @)
        else
            ~false @
    )
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let depth : T1 = fix (case self => (
    case (~leaf @) => ~zero @
    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of squares of a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let square : T2 = (case n => (mult)(n, n)) in
let sumOfSquares : T3 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, xs)) => (add)((square)(x), (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the nth Fibonacci number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let fib : T0 = fix (case self => (
    case (~zero @) => ~zero @
    case (~succ ~zero @) => ~succ ~zero @
    case (~succ ~succ n) => ((self)(~succ n)) + ((self)(n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of natural numbers up to a given number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sumUpTo : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => (add)((self)(n), ~succ n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of odd numbers up to a given number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let isOdd : T1 = fix (case self => ( 
    case (~zero @) => ~false @
    case (~succ ~zero @) => ~true @
    case (~succ ~succ n) => self(n)
)) in
let sumOddUpTo : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => if (isOdd)(n) then
                (add)(n, (self)((~pred n)))
              else
                (self)((~pred n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let product : T1 = fix (case self => ( 
    case (~nil @) => ~succ ~zero @
    case (~cons (x, xs)) => (mult)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to find the maximum element in a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let maxList : T1 = fix (case self => (
    case (~nil @) => ~zero @
    case (~cons (x, xs)) => (max)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of natural numbers up to a given number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sumUpTo : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => (add)((self)(n), ~succ n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let product : T1 = fix (case self => ( 
    case (~nil @) => ~succ ~zero @
    case (~cons (x, xs)) => (mult)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of odd numbers up to a given number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let isOdd : T1 = fix (case self => ( 
    case (~zero @) => ~false @
    case (~succ ~zero @) => ~true @
    case (~succ ~succ n) => self(n)
)) in
let sumOddUpTo : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => if (isOdd)(n) then
                (add)(n, (self)((~pred n)))
              else
                (self)((~pred n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let depth : T1 = fix (case self => (
    case (~leaf @) => ~zero @
    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of squares of natural numbers up to a given number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let square : T1 = fix (case self => (
    case n => (mult)(n, n)
)) in
let sumOfSquares : T2 = fix (case self => (
    case (~zero @) => ~zero @
    case n => (add)((square)(n), (self)((~pred n)))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let product : T1 = fix (case self => ( 
    case (~nil @) => ~succ ~zero @
    case (~cons (x, xs)) => (mult)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of two numbers using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to find the maximum element in a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let maxList : T1 = fix (case self => (
    case (~nil @) => ~zero @
    case (~cons (x, xs)) => (max)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let depth : T1 = fix (case self => (
    case (~leaf @) => ~zero @
    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, xs)) => (add)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let depth : T1 = fix (case self => (
    case (~leaf @) => ~zero @
    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let factorial : T0 = fix (case self => (
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let max : T0 = fix (case self => (
    case (~zero @, n) => n
    case (n, ~zero @) => n
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let maxList : T1 = fix (case self => (
    case (~nil @) => ~zero @
    case (~cons (x, xs)) => (max)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of squares of natural numbers up to a given number using recursion.

<<<grammar>>>
function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

expr ::= base argchain
       | base
       | "fix" "(" expr ")"
       | base "," expr
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr

base ::= function
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | argchain
       | "[a-zA-Z][_a-zA-Z]*"

basepat ::= "(" pattern ")"
          | "@"
          | "[a-zA-Z][_a-zA-Z]*"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat

pattern ::= basepat
          | basepat "," pattern

argchain ::= "(" expr ")"
           | "(" expr ")" argchain

target ::= ":" "T[0-9]+" "=" expr



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let square : T1 = fix (case self => (
    case n => (mult)(n, n)
)) in
let sumOfSquares : T2 = fix (case self => (
    case (~zero @) => ~zero @
    case n => (add)((square)(n), (self)((~pred n)))
)) in
@