**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let reverse : T0 = fix(case self => (
    case ~nil @ => ~nil @ 
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
let append : T1 = fix(case self => (
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the nth Fibonacci number using recursion.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let fib : T0 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ (~zero @)) => ~succ (~zero @)
    case (~succ (~succ n)) => (add)((self)(~succ n), (self)(n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is prime.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let div : T0 = fix (case self => ( 
    case (~zero @, n) => ~false @
    case (m, n) => 
        (if (lte)(m, n) then 
            (if (eq)(mod)(m, n), ~zero @) then ~true @ else self((succ)(m), n))
        else ~false @
)) in
let prime : T1 = fix (case self => ( 
    case (~zero @) => ~false @
    case (~succ ~zero @) => ~false @
    case n => (div)(~succ ~succ ~zero @, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of leaf nodes in a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let leafCount : T1 = fix (case self => ( 
    case ~leaf @ => ~succ ~zero @
    case ~node(l, r) => (add)((self)(l), (self)(r))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the sum of squares of natural numbers up to a given number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let square : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => (add)(n, (self)((pred)(n)))
)) in
let sum_of_squares : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => (add)((square)(n), (self)((pred)(n)))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the depth of a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (m, ~zero @) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let depth : T1 = fix (case self => ( 
    case ~leaf @ => ~succ ~zero @
    case ~node(l, r) => ~succ (max((self)(l), (self)(r)))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list is empty.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_empty : T0 = fix (case self => ( 
    case ~nil @ => ~true @ 
    case ~cons (x, xs) => ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list contains a specific element.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let contains : T0 = fix (case self => ( 
    case (~nil @, e) => ~false @ 
    case (~cons (x, xs), e) => 
        if (eq)(x, e) then 
            ~true @ 
        else 
            self(xs, e)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to find the maximum number in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (m, ~zero @) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let max_in_list : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (max)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of elements in a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let count : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => ~succ (self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to merge two sorted lists into a single sorted list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let merge : T0 = fix (case self => ( 
    case (~nil @, ys) => ys
    case (xs, ~nil @) => xs
    case (~cons (x, xs), ~cons (y, ys)) => 
        if (lte)(x, y) then 
            ~cons(x, self(xs, ~cons(y, ys)))
        else 
            ~cons(y, self(~cons(x, xs), ys))
)) in
let lte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~succ n) => self(m, n) 
    case (~succ m, ~zero @) => ~false @ 
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to concatenate two lists.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let append : T0 = fix(case self => (
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let factorial : T2 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, (self)((pred)(n)))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the sum of all elements in a list of natural numbers using tail recursion.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum_tail : T1 = fix (case self => ( 
    case (~nil @, acc) => acc
    case (~cons (x, xs), acc) => self(xs, (add)(acc, x))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of occurrences of an element in a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let count : T1 = fix (case self => ( 
    case (~nil @, e) => ~zero @ 
    case (~cons (x, xs), e) => 
        if (eq)(x, e) then 
            ~succ (self(xs, e)) 
        else 
            self(xs, e)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let product : T2 = fix (case self => ( 
    case ~nil @ => ~succ ~zero @ 
    case ~cons (x, xs) => (mult)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to insert an element into a sorted list in its correct position.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let insert : T0 = fix (case self => ( 
    case (~nil @, e) => ~cons(e, ~nil @)
    case (~cons (x, xs), e) => 
        if (lte)(e, x) then 
            ~cons(e, ~cons(x, xs))
        else 
            ~cons(x, self(xs, e))
)) in
let lte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~succ n) => self(m, n) 
    case (~succ m, ~zero @) => ~false @ 
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to find the maximum value in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~zero @) => ~false @ 
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the sum of all elements in a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | "if" expr "then" expr "else" expr
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @ 
    case (~succ (~zero @)) => ~false @ 
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the minimum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let min : T0 = fix (case self => ( 
    case (n, ~zero @) => n 
    case (~zero @, m) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
let min_in_list : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (min)(x, (self)(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let append : T0 = fix(case self => (
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
let reverse : T1 = fix (case self => ( 
    case ~nil @ => ~nil @ 
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @ 
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mul : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, (self)((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let append : T0 = fix (case self => ( 
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
let reverse : T1 = fix (case self => ( 
    case ~nil @ => ~nil @
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the nth Fibonacci number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let fib : T0 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ ~zero @) => ~succ ~zero @
    case n => (add)((self)((pred)(n)), (self)((pred)((pred)(n))))
)) in
let pred : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if all elements in a list are even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
let all_even : T1 = fix (case self => ( 
    case ~nil @ => ~true @
    case ~cons (x, xs) => 
        if (even)(x) then self(xs) else ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let reverse : T0 = fix(case self => (
    case ~nil @ => ~nil @ 
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
let append : T1 = fix(case self => (
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a given number is prime.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_prime : T0 = fix (case self => (
    case n => (and)((not)((divides)(n, ~succ (~zero @))), self((pred)(n)))
    case (~succ (~zero @)) => ~true @
    case (~zero @) => ~false @
)) in
let divides : T1 = fix (case self => (
    case (n, d) => if (eq)((mod)(n, d), ~zero @) then ~true @ else ~false @
)) in
let mod : T2 = fix (case self => (
    case (n, d) => if (lt)(n, d) then n else self((sub)(n, d), d)
)) in
let sub : T3 = fix (case self => (
    case (n, ~zero @) => n
    case (n, ~succ d) => self((pred)(n), d)
)) in
let pred : T4 = fix (case self => (
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (n, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, (self)((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a tree is a binary search tree (BST).

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let lte : T0 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~succ n) => self(m, n) 
    case (~succ m, ~zero @) => ~false @ 
)) in
let is_bst : T1 = fix (case self => ( 
    case ~leaf @ => ~true @
    case ~node (~leaf @, v, ~leaf @) => ~true @
    case ~node (l, v, ~leaf @) => (and)(self(l), (lte)((max_value)(l), v))
    case ~node (~leaf @, v, r) => (and)(self(r), (lte)(v, (min_value)(r)))
    case ~node (l, v, r) => (and)((and)(self(l), self(r)), (and)((lte)((max_value)(l), v), (lte)(v, (min_value)(r))))
)) in
let max_value : T2 = fix (case self => ( 
    case ~leaf @ => ~zero @
    case ~node (~leaf @, v, ~leaf @) => v
    case ~node (~leaf @, v, r) => (max)(v, (self)(r))
    case ~node (l, v, ~leaf @) => (max)((self)(l), v)
    case ~node (l, v, r) => (max)((max)((self)(l), v), (self)(r))
)) in
let min_value : T3 = fix (case self => ( 
    case ~leaf @ => ~zero @
    case ~node (~leaf @, v, ~leaf @) => v
    case ~node (~leaf @, v, r) => (min)(v, (self)(r))
    case ~node (l, v, ~leaf @) => (min)((self)(l), v)
    case ~node (l, v, r) => (min)((min)((self)(l), v), (self)(r))
)) in
let and : T4 = case (x, y) => (
    if x then (if y then ~true @ else ~false @) else ~false @
) in
let min : T5 = case (x, y) => (
    if (lte)(x, y) then x else y
) in
let max : T6 = case (x, y) => (
    if (lte)(x, y) then y else x
) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the length of a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let length : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (_, xs) => ~succ (self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list is empty.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_empty : T0 = fix (case self => ( 
    case ~nil @ => ~true @ 
    case ~cons (x, xs) => ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let product : T1 = fix (case self => ( 
    case ~nil @ => ~succ ~zero @ 
    case ~cons (x, xs) => (mult)(x, self(xs))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @ 
    case (~succ (~zero @)) => ~false @ 
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the length of a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let length : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => ~succ (self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a given number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @ 
    case (~succ (~zero @)) => ~false @ 
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let product : T1 = fix (case self => ( 
    case ~nil @ => ~succ ~zero @ 
    case ~cons (x, xs) => (mult)(x, self(xs))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let depth : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~node (l, r) => ~succ (max (self(l), self(r)))
)) in
let max : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (m, ~zero @) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)((succ)(n), self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n
    case (~succ m, n) => ~succ (self(m, n))
)) in
let factorial : T2 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)(~succ n, self(n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let append : T0 = fix(case self => (
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
let reverse : T1 = fix (case self => ( 
    case ~nil @ => ~nil @ 
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (n, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let reverse : T0 = fix (case self => ( 
    case ~nil @ => ~nil @ 
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
let append : T1 = fix (case self => ( 
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @ 
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of occurrences of an element in a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let count : T1 = fix (case self => ( 
    case (~nil @, e) => ~zero @ 
    case (~cons (x, xs), e) => 
        if (eq)(x, e) then 
            ~succ (self(xs, e)) 
        else 
            self(xs, e)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of leaf nodes in a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let leafCount : T1 = fix (case self => ( 
    case ~leaf @ => ~succ ~zero @
    case ~node(l, r) => (add)((self)(l), (self)(r))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let factorial : T2 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (n, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list is sorted in ascending order.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let lte : T0 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~zero @) => ~false @ 
    case (~succ m, ~succ n) => self(m, n) 
)) in
let is_sorted : T1 = fix (case self => ( 
    case ~nil @ => ~true @
    case ~cons (x, ~nil @) => ~true @
    case ~cons (x, ~cons (y, ys)) => 
        if (lte)(x, y) then self(~cons (y, ys)) else ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a given natural number is even.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_even : T0 = fix (case self => ( 
    case (~zero @) => ~true @
    case (~succ ~zero @) => ~false @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @ 
    case (~succ n) => (mult)((succ)(n), self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mul : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, (self)((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)((succ)(n), self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((succ)(n), self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let depth : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~node (l, r) => ~succ (max (self(l), self(r)))
)) in
let max : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (m, ~zero @) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let factorial : T2 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((succ)(n), self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let factorial : T2 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, (self)((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let product : T1 = fix (case self => ( 
    case ~nil @ => ~succ ~zero @ 
    case ~cons (x, xs) => (mult)(x, self(xs))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a number is odd.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let odd : T0 = fix (case self => ( 
    case (~zero @) => ~false @
    case (~succ ~zero @) => ~true @
    case (~succ (~succ n)) => self(n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of the first n natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum_n : T0 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => (add)(n, self((pred)(n)))
)) in
let pred : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of the squares of natural numbers up to a given number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let square_sum : T0 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case n => (add)((square)(n), self((pred)(n)))
)) in
let square : T1 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case n => (mult)(n, n)
)) in
let mult : T2 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T4 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to find the nth Fibonacci number using a recursive approach.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let fib : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ ~zero @) => ~succ ~zero @
    case n => (add)((self)((pred)(n)), (self)((pred)((pred)(n))))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let depth : T0 = fix (case self => ( 
    case ~leaf @ => ~zero @ 
    case ~node (l, r) => ~succ (max (self(l), self(r)))
)) in
let max : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (m, ~zero @) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the length of a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let length : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => ~succ (self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @ 
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list is sorted in ascending order.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_sorted : T0 = fix (case self => ( 
    case ~nil @ => ~true @ 
    case ~cons (x, ~nil @) => ~true @ 
    case ~cons (x, ~cons (y, ys)) => 
        if (lte)(x, y) then self(~cons(y, ys)) else ~false @
)) in
let lte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to merge two sorted lists into a single sorted list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let merge : T0 = fix (case self => ( 
    case (~nil @, ys) => ys
    case (xs, ~nil @) => xs
    case (~cons (x, xs), ~cons (y, ys)) => 
        if (lte)(x, y) then 
            ~cons(x, self(xs, ~cons(y, ys)))
        else 
            ~cons(y, self(~cons(x, xs), ys))
)) in
let lte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~succ n) => self(m, n) 
    case (~succ m, ~zero @) => ~false @ 
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of occurrences of an element in a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let count : T1 = fix (case self => ( 
    case (~nil @, e) => ~zero @ 
    case (~cons (x, xs), e) => 
        if (eq)(x, e) then 
            ~succ (self(xs, e)) 
        else 
            self(xs, e)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, (self)((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to determine if a tree is a binary search tree (BST).

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_bst : T0 = fix (case self => ( 
    case ~leaf @ => (~true @, ~zero @, ~zero @) 
    case ~node (~leaf @, x, ~leaf @) => (~true @, x, x)
    case ~node (l, x, r) => 
        let (bl, minl, maxl) = self(l) in
        let (br, minr, maxr) = self(r) in
        let valid_node = (and)((lte)(maxl, x), (lte)(x, minr)) in
        (~and (bl, ~and (br, valid_node)), ~min (minl, x), ~max (x, maxr))
)) in
let lte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
let min : T2 = fix (case self => ( 
    case (m, n) => if (lte)(m, n) then m else n
)) in
let max : T3 = fix (case self => ( 
    case (m, n) => if (lte)(m, n) then n else m
)) in
let and : T4 = fix (case self => ( 
    case (~true @, b) => b
    case (b, ~true @) => b
    case (_, _) => ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (n, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, (self)((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of squares of natural numbers up to a given number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let square : T1 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => (add)(n, (self)((pred)(n)))
)) in
let sum_of_squares : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case n => (add)((square)(n), (self)((pred)(n)))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the maximum element in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let max : T0 = fix (case self => ( 
    case (~nil @) => ~zero @
    case (~cons (x, ~nil @)) => x
    case (~cons (x, xs)) => 
        let m = self(xs) in
        if (gte)(x, m) then x else m
)) in
let gte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number using recursion.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, self((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to count the number of leaf nodes in a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let leafCount : T1 = fix (case self => ( 
    case ~leaf @ => ~succ ~zero @
    case ~node(l, r) => (add)((self)(l), (self)(r))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, (self)((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, (self)((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a given number is a prime number using recursion.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_prime : T0 = fix (case self => (
    case (~zero @) => ~false @
    case (~succ ~zero @) => ~false @
    case n => (check_prime)(n, (pred)(n))
)) in
let check_prime : T1 = fix (case self => (
    case (n, ~succ ~zero @) => ~true @
    case (n, d) => 
        if (eq)((mod)(n, d), ~zero @) then ~false @
        else self(n, (pred)(d))
)) in
let mod : T2 = fix (case self => (
    case (m, n) => 
        if (lt)(m, n) then m 
        else self((sub)(m, n), n)
)) in
let sub : T3 = fix (case self => (
    case (~zero @, n) => ~zero @
    case (m, ~zero @) => m
    case (~succ m, ~succ n) => self(m, n)
)) in
let pred : T4 = fix (case self => (
    case (~succ n) => n
)) in
let eq : T5 = fix (case self => (
    case (~zero @, ~zero @) => ~true @
    case (~succ m, ~succ n) => self(m, n)
    case (_, _) => ~false @
)) in
let lt : T6 = fix (case self => (
    case (~zero @, ~succ n) => ~true @
    case (~succ m, ~zero @) => ~false @
    case (~succ m, ~succ n) => self(m, n)
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of the squares of natural numbers up to a given number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let square_sum : T0 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case n => (add)((square)(n), self((pred)(n)))
)) in
let square : T1 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case n => (mult)(n, n)
)) in
let mult : T2 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T4 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, (self)((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number using recursion.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, self((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to merge two sorted lists into a single sorted list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let merge : T0 = fix (case self => ( 
    case (~nil @, ys) => ys
    case (xs, ~nil @) => xs
    case (~cons (x, xs), ~cons (y, ys)) => 
        if (lte)(x, y) then 
            ~cons(x, self(xs, ~cons(y, ys)))
        else 
            ~cons(y, self(~cons(x, xs), ys))
)) in
let lte : T1 = fix (case self => ( 
    case (~zero @, n) => ~true @ 
    case (~succ m, ~succ n) => self(m, n) 
    case (~succ m, ~zero @) => ~false @ 
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to reverse a list.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let append : T0 = fix (case self => ( 
    case (~nil @, ys) => ys
    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))
)) in
let reverse : T1 = fix (case self => ( 
    case ~nil @ => ~nil @ 
    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @ 
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, self((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list is empty.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_empty : T0 = fix (case self => ( 
    case ~nil @ => ~true @ 
    case ~cons (x, xs) => ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, self((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)((self)(m, n), n)
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)((succ)(n), self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let sum : T0 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
let add : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to calculate the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the product of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let product : T1 = fix (case self => ( 
    case ~nil @ => ~succ ~zero @ 
    case ~cons (x, xs) => (mult)(x, self(xs))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ (~zero @)
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to check if a list is empty.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let is_empty : T0 = fix (case self => ( 
    case ~nil @ => ~true @ 
    case ~cons (x, xs) => ~false @
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mul)(n, self((pred)(n)))
)) in
let mul : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @ 
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @ 
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the depth of a binary tree.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let depth : T0 = fix (case self => ( 
    case ~leaf @ => ~zero @ 
    case ~node (l, r) => ~succ (max (self(l), self(r)))
)) in
let max : T1 = fix (case self => ( 
    case (~zero @, n) => n 
    case (m, ~zero @) => m 
    case (~succ m, ~succ n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let mult : T0 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let factorial : T1 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let pred : T2 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
let add : T3 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)(~succ n, self(n))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the sum of all elements in a list of natural numbers.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let add : T0 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let sum : T1 = fix (case self => ( 
    case ~nil @ => ~zero @ 
    case ~cons (x, xs) => (add)(x, self(xs))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case (~succ n) => (mult)((self)(n), ~succ n)
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (~succ m, n) => (add)(n, (self)(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
@
**********************************************
<<<description>>> 
A program that defines a function to compute the factorial of a natural number.

<<<grammar>>>
base ::= argchain
       | "[a-zA-Z][_a-zA-Z]*"
       | "~" "[a-zA-Z][_a-zA-Z]*" base
       | "@"
       | function

expr ::= "fix" "(" expr ")"
       | "let" "[a-zA-Z][_a-zA-Z]*" target "in" expr
       | base argchain
       | base
       | base "," expr

function ::= "case" pattern "=>" expr
           | "case" pattern "=>" expr function

basepat ::= "(" pattern ")"
          | "@"
          | "~" "[a-zA-Z][_a-zA-Z]*" basepat
          | "[a-zA-Z][_a-zA-Z]*"

target ::= ":" "T[0-9]+" "=" expr

argchain ::= "(" expr ")" argchain
           | "(" expr ")"

pattern ::= basepat "," pattern
          | basepat



<<<program>>>
let factorial : T0 = fix (case self => ( 
    case (~zero @) => ~succ ~zero @
    case n => (mult)(n, self((pred)(n)))
)) in
let mult : T1 = fix (case self => ( 
    case (~zero @, n) => ~zero @ 
    case (m, ~zero @) => ~zero @ 
    case (~succ m, n) => (add)(n, self(m, n))
)) in
let add : T2 = fix (case self => ( 
    case (~zero @, n) => n 
    case (~succ m, n) => ~succ (self(m, n))
)) in
let pred : T3 = fix (case self => ( 
    case (~zero @) => ~zero @
    case (~succ n) => n
)) in
@