{"description": "A program that defines a function to calculate the power of a number.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet power : T1 = fix (case self => ( \n    case (n, ~zero @) => ~succ ~zero @\n    case (n, ~succ m) => (mult)(n, (self)(n, m))\n)) in\n@"}
{"description": "A program that defines a function to find the maximum element in a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let max : T0 = fix(case self => (\n    case (~nil @) => ~zero @  // Assuming non-empty lists for simplicity\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => (\n        let tail_max = self(xs) in\n        if (lte)(x, tail_max) then\n            tail_max\n        else\n            x\n    )\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let reverse : T0 = fix(case self => (\n    case ~nil @ => ~nil @\n    case ~cons (x, xs) => (\n        let rev_tail = self(xs) in\n        append(rev_tail, ~cons (x, ~nil @))\n    )\n)) in\nlet append : T1 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons (x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to compute the length of a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain", "program": "let length : T0 = fix(case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => ~succ (self(xs))\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let append : T0 = fix(case self => (\n    case (~nil @, l) => l\n    case (~cons (x, xs), l) => ~cons (x, self(xs, l))\n)) in\nlet reverse : T1 = fix(case self => (\n    case ~nil @ => ~nil @\n    case ~cons (x, xs) => (append)(self(xs), ~cons (x, ~nil @))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of elements in a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let sum : T0 = fix (case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a list is empty.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let is_empty : T0 = case xs => (\n    case ~nil @ => ~true @\n    case ~cons (x, xs) => ~false @\n) in\n@"}
{"description": "A program that defines a function to check if a given number is even.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let is_even : T0 = fix(case self => (\n    case ~zero @ => ~true @\n    case ~succ ~zero @ => ~false @\n    case ~succ ~succ n => self(n)\n)) in\n@"}
{"description": "A program that defines a function to concatenate two lists.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let append : T0 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons (x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let reverse : T0 = fix(case self => (\n    case ~nil @ => ~nil @\n    case ~cons (x, xs) => (append)(self(xs), ~cons (x, ~nil @))\n)) in\nlet append : T1 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons (x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to concatenate two lists.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let concat : T0 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons (x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to check if a natural number is zero, and if not, decrement it.", "grammar": "expr ::= base argchain\n       | \"if\" expr \"then\" expr \"else\" expr\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let is_zero : T0 = (case n => (\n    case ~zero @ => ~true @\n    case ~succ m => ~false @\n)) in\nlet pred : T1 = fix(case self => (\n    case ~zero @ => ~zero @\n    case ~succ m => m\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of all elements in a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let sum : T0 = fix(case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix(case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to find the maximum value in a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let max : T0 = fix(case self => (\n    case (~nil @) => ~zero @  # Assuming zero as the default minimum value\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => (\n        let m = self(xs) in \n        (if (greater)(x, m) then x else m)\n    )\n)) in\nlet greater : T1 = fix(case self => (\n    case (~zero @, ~zero @) => ~false @\n    case (~zero @, ~succ n) => ~false @\n    case (~succ m, ~zero @) => ~true @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to find the length of a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let length : T0 = fix (case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => ~succ (self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum of two natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (m, ~zero @) => m\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to find the maximum number in a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let max : T0 = fix(case self => (\n    case ~nil @ => ~zero @  // Assuming zero as the minimum value\n    case ~cons (x, ~nil @) => x\n    case ~cons (x, xs) => (\n        let m = self(xs) in\n        case (gte)(x, m) => x\n        case _ => m\n    )\n)) in\nlet gte : T1 = fix(case self => (  // Greater than or equal function\n    case (~zero @, n) => ~true @\n    case (n, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let factorial : T0 = fix (case self => (\n    case ~zero @ => ~succ ~zero @\n    case ~succ n => (mul)(~succ n, self(n))\n)) in\nlet mul : T1 = fix (case self => (\n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let factorial : T0 = fix(case self => (\n    case ~zero @ => ~succ ~zero @\n    case ~succ n => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix(case self => (\n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix(case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let sum : T0 = fix(case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix(case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of elements in a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let sum : T0 = fix (case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number using recursion.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let factorial : T0 = fix(case self => (\n    case ~zero @ => ~succ ~zero @\n    case ~succ n => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix(case self => (\n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix(case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let reverse : T0 = fix (case self => (\n    case ~nil @ => ~nil @\n    case ~cons (x, xs) => (concat)(self(xs), ~cons (x, ~nil @))\n)) in\nlet concat : T1 = fix (case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons (x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let sum : T0 = fix(case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix(case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a list is empty.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let is_empty : T0 = (case lst => (\n    case ~nil @ => ~true @\n    case ~cons (x, xs) => ~false @\n)) in\n@"}
{"description": "A program that defines a function to check if a number is zero.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let is_zero : T0 = case n => (\n    case ~zero @ => ~true @\n    case ~succ m => ~false @\n) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of integers.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let sum : T0 = fix (case self => (\n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a given natural number is zero.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let is_zero : T0 = case n => (\n    case ~zero @ => ~true @\n    case ~succ _ => ~false @\n) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let reverse : T0 = fix(case self => (\n    case ~nil @ => ~nil @\n    case ~cons (x, xs) => (append)(self(xs), ~cons (x, ~nil @))\n)) in\nlet append : T1 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons (x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "expr ::= base argchain\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base\n\nbasepat ::= \"[a-zA-Z][_a-zA-Z]*\"\n          | \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nbase ::= function\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | argchain\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n\nfunction ::= \"case\" pattern \"=>\" expr function\n           | \"case\" pattern \"=>\" expr\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"", "program": "let factorial : T0 = fix (case self => (\n    case ~zero @ => ~succ ~zero @\n    case ~succ n => (mul)((self)(n), ~succ n)\n)) in\nlet mul : T1 = fix (case self => (\n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => (\n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}