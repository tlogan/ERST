{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let reverse : T0 = fix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\nlet append : T1 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to calculate the nth Fibonacci number using recursion.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let fib : T0 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ (~zero @)) => ~succ (~zero @)\n    case (~succ (~succ n)) => (add)((self)(~succ n), (self)(n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is prime.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let div : T0 = fix (case self => ( \n    case (~zero @, n) => ~false @\n    case (m, n) => \n        (if (lte)(m, n) then \n            (if (eq)(mod)(m, n), ~zero @) then ~true @ else self((succ)(m), n))\n        else ~false @\n)) in\nlet prime : T1 = fix (case self => ( \n    case (~zero @) => ~false @\n    case (~succ ~zero @) => ~false @\n    case n => (div)(~succ ~succ ~zero @, n)\n)) in\n@"}
{"description": "A program that defines a function to count the number of leaf nodes in a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet leafCount : T1 = fix (case self => ( \n    case ~leaf @ => ~succ ~zero @\n    case ~node(l, r) => (add)((self)(l), (self)(r))\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of squares of natural numbers up to a given number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet square : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => (add)(n, (self)((pred)(n)))\n)) in\nlet sum_of_squares : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => (add)((square)(n), (self)((pred)(n)))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to calculate the depth of a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (m, ~zero @) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet depth : T1 = fix (case self => ( \n    case ~leaf @ => ~succ ~zero @\n    case ~node(l, r) => ~succ (max((self)(l), (self)(r)))\n)) in\n@"}
{"description": "A program that defines a function to check if a list is empty.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_empty : T0 = fix (case self => ( \n    case ~nil @ => ~true @ \n    case ~cons (x, xs) => ~false @\n)) in\n@"}
{"description": "A program that defines a function to check if a list contains a specific element.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let contains : T0 = fix (case self => ( \n    case (~nil @, e) => ~false @ \n    case (~cons (x, xs), e) => \n        if (eq)(x, e) then \n            ~true @ \n        else \n            self(xs, e)\n)) in\n@"}
{"description": "A program that defines a function to find the maximum number in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (m, ~zero @) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet max_in_list : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (max)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to count the number of elements in a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let count : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => ~succ (self(xs))\n)) in\n@"}
{"description": "A program that defines a function to merge two sorted lists into a single sorted list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let merge : T0 = fix (case self => ( \n    case (~nil @, ys) => ys\n    case (xs, ~nil @) => xs\n    case (~cons (x, xs), ~cons (y, ys)) => \n        if (lte)(x, y) then \n            ~cons(x, self(xs, ~cons(y, ys)))\n        else \n            ~cons(y, self(~cons(x, xs), ys))\n)) in\nlet lte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~succ n) => self(m, n) \n    case (~succ m, ~zero @) => ~false @ \n)) in\n@"}
{"description": "A program that defines a function to concatenate two lists.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let append : T0 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet factorial : T2 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, (self)((pred)(n)))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of all elements in a list of natural numbers using tail recursion.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum_tail : T1 = fix (case self => ( \n    case (~nil @, acc) => acc\n    case (~cons (x, xs), acc) => self(xs, (add)(acc, x))\n)) in\n@"}
{"description": "A program that defines a function to count the number of occurrences of an element in a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet count : T1 = fix (case self => ( \n    case (~nil @, e) => ~zero @ \n    case (~cons (x, xs), e) => \n        if (eq)(x, e) then \n            ~succ (self(xs, e)) \n        else \n            self(xs, e)\n)) in\n@"}
{"description": "A program that defines a function to compute the product of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet product : T2 = fix (case self => ( \n    case ~nil @ => ~succ ~zero @ \n    case ~cons (x, xs) => (mult)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to insert an element into a sorted list in its correct position.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let insert : T0 = fix (case self => ( \n    case (~nil @, e) => ~cons(e, ~nil @)\n    case (~cons (x, xs), e) => \n        if (lte)(e, x) then \n            ~cons(e, ~cons(x, xs))\n        else \n            ~cons(x, self(xs, e))\n)) in\nlet lte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~succ n) => self(m, n) \n    case (~succ m, ~zero @) => ~false @ \n)) in\n@"}
{"description": "A program that defines a function to find the maximum value in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~zero @) => ~false @ \n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of all elements in a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | \"if\" expr \"then\" expr \"else\" expr\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @ \n    case (~succ (~zero @)) => ~false @ \n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the minimum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let min : T0 = fix (case self => ( \n    case (n, ~zero @) => n \n    case (~zero @, m) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet min_in_list : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (min)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let append : T0 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\nlet reverse : T1 = fix (case self => ( \n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @ \n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mul : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, (self)((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let append : T0 = fix (case self => ( \n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\nlet reverse : T1 = fix (case self => ( \n    case ~nil @ => ~nil @\n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the nth Fibonacci number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let fib : T0 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ ~zero @) => ~succ ~zero @\n    case n => (add)((self)((pred)(n)), (self)((pred)((pred)(n))))\n)) in\nlet pred : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to check if all elements in a list are even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\nlet all_even : T1 = fix (case self => ( \n    case ~nil @ => ~true @\n    case ~cons (x, xs) => \n        if (even)(x) then self(xs) else ~false @\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let reverse : T0 = fix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\nlet append : T1 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a given number is prime.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_prime : T0 = fix (case self => (\n    case n => (and)((not)((divides)(n, ~succ (~zero @))), self((pred)(n)))\n    case (~succ (~zero @)) => ~true @\n    case (~zero @) => ~false @\n)) in\nlet divides : T1 = fix (case self => (\n    case (n, d) => if (eq)((mod)(n, d), ~zero @) then ~true @ else ~false @\n)) in\nlet mod : T2 = fix (case self => (\n    case (n, d) => if (lt)(n, d) then n else self((sub)(n, d), d)\n)) in\nlet sub : T3 = fix (case self => (\n    case (n, ~zero @) => n\n    case (n, ~succ d) => self((pred)(n), d)\n)) in\nlet pred : T4 = fix (case self => (\n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (n, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, (self)((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to check if a tree is a binary search tree (BST).", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let lte : T0 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~succ n) => self(m, n) \n    case (~succ m, ~zero @) => ~false @ \n)) in\nlet is_bst : T1 = fix (case self => ( \n    case ~leaf @ => ~true @\n    case ~node (~leaf @, v, ~leaf @) => ~true @\n    case ~node (l, v, ~leaf @) => (and)(self(l), (lte)((max_value)(l), v))\n    case ~node (~leaf @, v, r) => (and)(self(r), (lte)(v, (min_value)(r)))\n    case ~node (l, v, r) => (and)((and)(self(l), self(r)), (and)((lte)((max_value)(l), v), (lte)(v, (min_value)(r))))\n)) in\nlet max_value : T2 = fix (case self => ( \n    case ~leaf @ => ~zero @\n    case ~node (~leaf @, v, ~leaf @) => v\n    case ~node (~leaf @, v, r) => (max)(v, (self)(r))\n    case ~node (l, v, ~leaf @) => (max)((self)(l), v)\n    case ~node (l, v, r) => (max)((max)((self)(l), v), (self)(r))\n)) in\nlet min_value : T3 = fix (case self => ( \n    case ~leaf @ => ~zero @\n    case ~node (~leaf @, v, ~leaf @) => v\n    case ~node (~leaf @, v, r) => (min)(v, (self)(r))\n    case ~node (l, v, ~leaf @) => (min)((self)(l), v)\n    case ~node (l, v, r) => (min)((min)((self)(l), v), (self)(r))\n)) in\nlet and : T4 = case (x, y) => (\n    if x then (if y then ~true @ else ~false @) else ~false @\n) in\nlet min : T5 = case (x, y) => (\n    if (lte)(x, y) then x else y\n) in\nlet max : T6 = case (x, y) => (\n    if (lte)(x, y) then y else x\n) in\n@"}
{"description": "A program that defines a function to calculate the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the length of a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let length : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (_, xs) => ~succ (self(xs))\n)) in\n@"}
{"description": "A program that defines a function to check if a list is empty.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_empty : T0 = fix (case self => ( \n    case ~nil @ => ~true @ \n    case ~cons (x, xs) => ~false @\n)) in\n@"}
{"description": "A program that defines a function to compute the product of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case ~nil @ => ~succ ~zero @ \n    case ~cons (x, xs) => (mult)(x, self(xs))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @ \n    case (~succ (~zero @)) => ~false @ \n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the length of a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let length : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => ~succ (self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to check if a given number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @ \n    case (~succ (~zero @)) => ~false @ \n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the product of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case ~nil @ => ~succ ~zero @ \n    case ~cons (x, xs) => (mult)(x, self(xs))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let depth : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~node (l, r) => ~succ (max (self(l), self(r)))\n)) in\nlet max : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (m, ~zero @) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)((succ)(n), self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n\n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet factorial : T2 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let append : T0 = fix(case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\nlet reverse : T1 = fix (case self => ( \n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (n, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let reverse : T0 = fix (case self => ( \n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\nlet append : T1 = fix (case self => ( \n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @ \n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to count the number of occurrences of an element in a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet count : T1 = fix (case self => ( \n    case (~nil @, e) => ~zero @ \n    case (~cons (x, xs), e) => \n        if (eq)(x, e) then \n            ~succ (self(xs, e)) \n        else \n            self(xs, e)\n)) in\n@"}
{"description": "A program that defines a function to count the number of leaf nodes in a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet leafCount : T1 = fix (case self => ( \n    case ~leaf @ => ~succ ~zero @\n    case ~node(l, r) => (add)((self)(l), (self)(r))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet factorial : T2 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (n, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a list is sorted in ascending order.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let lte : T0 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~zero @) => ~false @ \n    case (~succ m, ~succ n) => self(m, n) \n)) in\nlet is_sorted : T1 = fix (case self => ( \n    case ~nil @ => ~true @\n    case ~cons (x, ~nil @) => ~true @\n    case ~cons (x, ~cons (y, ys)) => \n        if (lte)(x, y) then self(~cons (y, ys)) else ~false @\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to check if a given natural number is even.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_even : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @ \n    case (~succ n) => (mult)((succ)(n), self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mul : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, (self)((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)((succ)(n), self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((succ)(n), self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let depth : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~node (l, r) => ~succ (max (self(l), self(r)))\n)) in\nlet max : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (m, ~zero @) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet factorial : T2 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((succ)(n), self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet factorial : T2 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, (self)((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the product of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case ~nil @ => ~succ ~zero @ \n    case ~cons (x, xs) => (mult)(x, self(xs))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is odd.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let odd : T0 = fix (case self => ( \n    case (~zero @) => ~false @\n    case (~succ ~zero @) => ~true @\n    case (~succ (~succ n)) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of the first n natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum_n : T0 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => (add)(n, self((pred)(n)))\n)) in\nlet pred : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of the squares of natural numbers up to a given number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let square_sum : T0 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case n => (add)((square)(n), self((pred)(n)))\n)) in\nlet square : T1 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case n => (mult)(n, n)\n)) in\nlet mult : T2 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T4 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to find the nth Fibonacci number using a recursive approach.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet fib : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ ~zero @) => ~succ ~zero @\n    case n => (add)((self)((pred)(n)), (self)((pred)((pred)(n))))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to calculate the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let depth : T0 = fix (case self => ( \n    case ~leaf @ => ~zero @ \n    case ~node (l, r) => ~succ (max (self(l), self(r)))\n)) in\nlet max : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (m, ~zero @) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the length of a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let length : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => ~succ (self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @ \n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to check if a list is sorted in ascending order.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_sorted : T0 = fix (case self => ( \n    case ~nil @ => ~true @ \n    case ~cons (x, ~nil @) => ~true @ \n    case ~cons (x, ~cons (y, ys)) => \n        if (lte)(x, y) then self(~cons(y, ys)) else ~false @\n)) in\nlet lte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to merge two sorted lists into a single sorted list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let merge : T0 = fix (case self => ( \n    case (~nil @, ys) => ys\n    case (xs, ~nil @) => xs\n    case (~cons (x, xs), ~cons (y, ys)) => \n        if (lte)(x, y) then \n            ~cons(x, self(xs, ~cons(y, ys)))\n        else \n            ~cons(y, self(~cons(x, xs), ys))\n)) in\nlet lte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~succ n) => self(m, n) \n    case (~succ m, ~zero @) => ~false @ \n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @\n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to count the number of occurrences of an element in a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet count : T1 = fix (case self => ( \n    case (~nil @, e) => ~zero @ \n    case (~cons (x, xs), e) => \n        if (eq)(x, e) then \n            ~succ (self(xs, e)) \n        else \n            self(xs, e)\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, (self)((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to determine if a tree is a binary search tree (BST).", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_bst : T0 = fix (case self => ( \n    case ~leaf @ => (~true @, ~zero @, ~zero @) \n    case ~node (~leaf @, x, ~leaf @) => (~true @, x, x)\n    case ~node (l, x, r) => \n        let (bl, minl, maxl) = self(l) in\n        let (br, minr, maxr) = self(r) in\n        let valid_node = (and)((lte)(maxl, x), (lte)(x, minr)) in\n        (~and (bl, ~and (br, valid_node)), ~min (minl, x), ~max (x, maxr))\n)) in\nlet lte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\nlet min : T2 = fix (case self => ( \n    case (m, n) => if (lte)(m, n) then m else n\n)) in\nlet max : T3 = fix (case self => ( \n    case (m, n) => if (lte)(m, n) then n else m\n)) in\nlet and : T4 = fix (case self => ( \n    case (~true @, b) => b\n    case (b, ~true @) => b\n    case (_, _) => ~false @\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (n, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, (self)((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of squares of natural numbers up to a given number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet square : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => (add)(n, (self)((pred)(n)))\n)) in\nlet sum_of_squares : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => (add)((square)(n), (self)((pred)(n)))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let max : T0 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, xs)) => \n        let m = self(xs) in\n        if (gte)(x, m) then x else m\n)) in\nlet gte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number using recursion.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, self((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to count the number of leaf nodes in a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet leafCount : T1 = fix (case self => ( \n    case ~leaf @ => ~succ ~zero @\n    case ~node(l, r) => (add)((self)(l), (self)(r))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, (self)((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, (self)((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to check if a given number is a prime number using recursion.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_prime : T0 = fix (case self => (\n    case (~zero @) => ~false @\n    case (~succ ~zero @) => ~false @\n    case n => (check_prime)(n, (pred)(n))\n)) in\nlet check_prime : T1 = fix (case self => (\n    case (n, ~succ ~zero @) => ~true @\n    case (n, d) => \n        if (eq)((mod)(n, d), ~zero @) then ~false @\n        else self(n, (pred)(d))\n)) in\nlet mod : T2 = fix (case self => (\n    case (m, n) => \n        if (lt)(m, n) then m \n        else self((sub)(m, n), n)\n)) in\nlet sub : T3 = fix (case self => (\n    case (~zero @, n) => ~zero @\n    case (m, ~zero @) => m\n    case (~succ m, ~succ n) => self(m, n)\n)) in\nlet pred : T4 = fix (case self => (\n    case (~succ n) => n\n)) in\nlet eq : T5 = fix (case self => (\n    case (~zero @, ~zero @) => ~true @\n    case (~succ m, ~succ n) => self(m, n)\n    case (_, _) => ~false @\n)) in\nlet lt : T6 = fix (case self => (\n    case (~zero @, ~succ n) => ~true @\n    case (~succ m, ~zero @) => ~false @\n    case (~succ m, ~succ n) => self(m, n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of the squares of natural numbers up to a given number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let square_sum : T0 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case n => (add)((square)(n), self((pred)(n)))\n)) in\nlet square : T1 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case n => (mult)(n, n)\n)) in\nlet mult : T2 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T4 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, (self)((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number using recursion.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, self((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to merge two sorted lists into a single sorted list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let merge : T0 = fix (case self => ( \n    case (~nil @, ys) => ys\n    case (xs, ~nil @) => xs\n    case (~cons (x, xs), ~cons (y, ys)) => \n        if (lte)(x, y) then \n            ~cons(x, self(xs, ~cons(y, ys)))\n        else \n            ~cons(y, self(~cons(x, xs), ys))\n)) in\nlet lte : T1 = fix (case self => ( \n    case (~zero @, n) => ~true @ \n    case (~succ m, ~succ n) => self(m, n) \n    case (~succ m, ~zero @) => ~false @ \n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let append : T0 = fix (case self => ( \n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => ~cons(x, self(xs, ys))\n)) in\nlet reverse : T1 = fix (case self => ( \n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => (append)(self(xs), ~cons(x, ~nil @))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @ \n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, self((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to check if a list is empty.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_empty : T0 = fix (case self => ( \n    case ~nil @ => ~true @ \n    case ~cons (x, xs) => ~false @\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, self((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)((self)(m, n), n)\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)((succ)(n), self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let sum : T0 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\nlet add : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to calculate the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the product of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case ~nil @ => ~succ ~zero @ \n    case ~cons (x, xs) => (mult)(x, self(xs))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ (~zero @)\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to check if a list is empty.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let is_empty : T0 = fix (case self => ( \n    case ~nil @ => ~true @ \n    case ~cons (x, xs) => ~false @\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mul)(n, self((pred)(n)))\n)) in\nlet mul : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @ \n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @ \n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let depth : T0 = fix (case self => ( \n    case ~leaf @ => ~zero @ \n    case ~node (l, r) => ~succ (max (self(l), self(r)))\n)) in\nlet max : T1 = fix (case self => ( \n    case (~zero @, n) => n \n    case (m, ~zero @) => m \n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet pred : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\nlet add : T3 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)(~succ n, self(n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @\n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of all elements in a list of natural numbers.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => (add)(x, self(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number.", "grammar": "base ::= argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | function\n\nexpr ::= \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n       | base argchain\n       | base\n       | base \",\" expr\n\nfunction ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n          | \"[a-zA-Z][_a-zA-Z]*\"\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr\n\nargchain ::= \"(\" expr \")\" argchain\n           | \"(\" expr \")\"\n\npattern ::= basepat \",\" pattern\n          | basepat", "program": "let factorial : T0 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case n => (mult)(n, self((pred)(n)))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (m, ~zero @) => ~zero @ \n    case (~succ m, n) => (add)(n, self(m, n))\n)) in\nlet add : T2 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet pred : T3 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => n\n)) in\n@"}