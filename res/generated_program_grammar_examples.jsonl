{"description": "A program that defines a function to compute the power of a number.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet power : T2 = fix (case self => (\n    case (x, ~zero @) => ~succ ~zero @\n    case (x, ~succ n) => (mult)(x, (self)(x, n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, xs)) => (add)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to check if a number is even.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let isEven : T0 = fix (case self => ( \n    case (~zero @) => ~true @\n    case (~succ ~zero @) => ~false @\n    case (~succ ~succ n) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to check if a number is odd.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let isOdd : T0 = fix (case self => ( \n    case (~zero @) => ~false @\n    case (~succ ~zero @) => ~true @\n    case (~succ ~succ n) => self(n)\n)) in\n@"}
{"description": "A program that defines a function to reverse a list.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let cons : T0 = (case (x, xs) => ~cons(x, xs)) in\nlet append : T1 = fix (case self => (\n    case (~nil @, ys) => ys\n    case (~cons (x, xs), ys) => self(xs, (cons)(x, ys))\n)) in\nlet reverse : T2 = fix (case self => (\n    case (~nil @) => ~nil @\n    case (~cons (x, xs)) => (append)((self)(xs), (cons)(x, ~nil @))\n)) in\n@"}
{"description": "A program that defines a function to find the maximum element in a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~cons (x, ~nil @)) => x\n    case (~cons (x, ~cons (y, ys))) => (\n        if (lte)(x, y) then\n            self(~cons (y, ys))\n        else\n            self(~cons (x, ys))\n    )\n)) in\n@"}
{"description": "A program that defines a function that checks if a tree is balanced.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let absdiff : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => self(m, n)\n)) in\nlet height : T1 = fix (case self => (\n    case (~leaf @) => ~succ ~zero @\n    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))\n)) in\nlet isBalanced : T2 = fix (case self => (\n    case (~leaf @) => ~true @\n    case (~node (l, r)) => (\n        if (and)((self)(l), (self)(r)) then\n            (lte)((absdiff)((height)(l), (height)(r)), ~succ ~zero @)\n        else\n            ~false @\n    )\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet depth : T1 = fix (case self => (\n    case (~leaf @) => ~zero @\n    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of squares of a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet square : T2 = (case n => (mult)(n, n)) in\nlet sumOfSquares : T3 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, xs)) => (add)((square)(x), (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the nth Fibonacci number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let fib : T0 = fix (case self => (\n    case (~zero @) => ~zero @\n    case (~succ ~zero @) => ~succ ~zero @\n    case (~succ ~succ n) => ((self)(~succ n)) + ((self)(n))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of natural numbers up to a given number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sumUpTo : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => (add)((self)(n), ~succ n)\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of odd numbers up to a given number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet isOdd : T1 = fix (case self => ( \n    case (~zero @) => ~false @\n    case (~succ ~zero @) => ~true @\n    case (~succ ~succ n) => self(n)\n)) in\nlet sumOddUpTo : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => if (isOdd)(n) then\n                (add)(n, (self)((~pred n)))\n              else\n                (self)((~pred n))\n)) in\n@"}
{"description": "A program that defines a function to compute the product of a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case (~nil @) => ~succ ~zero @\n    case (~cons (x, xs)) => (mult)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to find the maximum element in a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet maxList : T1 = fix (case self => (\n    case (~nil @) => ~zero @\n    case (~cons (x, xs)) => (max)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of natural numbers up to a given number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sumUpTo : T1 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case (~succ n) => (add)((self)(n), ~succ n)\n)) in\n@"}
{"description": "A program that defines a function to compute the product of a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case (~nil @) => ~succ ~zero @\n    case (~cons (x, xs)) => (mult)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of odd numbers up to a given number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet isOdd : T1 = fix (case self => ( \n    case (~zero @) => ~false @\n    case (~succ ~zero @) => ~true @\n    case (~succ ~succ n) => self(n)\n)) in\nlet sumOddUpTo : T2 = fix (case self => ( \n    case (~zero @) => ~zero @\n    case n => if (isOdd)(n) then\n                (add)(n, (self)((~pred n)))\n              else\n                (self)((~pred n))\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet depth : T1 = fix (case self => (\n    case (~leaf @) => ~zero @\n    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of squares of natural numbers up to a given number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet square : T1 = fix (case self => (\n    case n => (mult)(n, n)\n)) in\nlet sumOfSquares : T2 = fix (case self => (\n    case (~zero @) => ~zero @\n    case n => (add)((square)(n), (self)((~pred n)))\n)) in\n@"}
{"description": "A program that defines a function to compute the product of a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet product : T1 = fix (case self => ( \n    case (~nil @) => ~succ ~zero @\n    case (~cons (x, xs)) => (mult)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\n@"}
{"description": "A program that defines a function to compute the product of two numbers using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet mult : T1 = fix (case self => ( \n    case (~zero @, n) => ~zero \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\n@"}
{"description": "A program that defines a function to find the maximum element in a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet maxList : T1 = fix (case self => (\n    case (~nil @) => ~zero @\n    case (~cons (x, xs)) => (max)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet depth : T1 = fix (case self => (\n    case (~leaf @) => ~zero @\n    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet sum : T1 = fix (case self => ( \n    case (~nil @) => ~zero @\n    case (~cons (x, xs)) => (add)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the depth of a binary tree.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet depth : T1 = fix (case self => (\n    case (~leaf @) => ~zero @\n    case (~node (l, r)) => ~succ ((max)((self)(l), (self)(r)))\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let factorial : T0 = fix (case self => (\n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\n@"}
{"description": "A program that defines a function to compute the factorial of a natural number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let mult : T0 = fix (case self => ( \n    case (~zero @, n) => ~zero @ \n    case (~succ m, n) => (add)(n, (self)(m, n))\n)) in\nlet factorial : T1 = fix (case self => ( \n    case (~zero @) => ~succ ~zero @\n    case (~succ n) => (mult)((self)(n), ~succ n)\n)) in\n@"}
{"description": "A program that defines a function to compute the maximum element in a list of natural numbers.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let max : T0 = fix (case self => (\n    case (~zero @, n) => n\n    case (n, ~zero @) => n\n    case (~succ m, ~succ n) => ~succ (self(m, n))\n)) in\nlet maxList : T1 = fix (case self => (\n    case (~nil @) => ~zero @\n    case (~cons (x, xs)) => (max)(x, (self)(xs))\n)) in\n@"}
{"description": "A program that defines a function to compute the sum of squares of natural numbers up to a given number using recursion.", "grammar": "function ::= \"case\" pattern \"=>\" expr\n           | \"case\" pattern \"=>\" expr function\n\nexpr ::= base argchain\n       | base\n       | \"fix\" \"(\" expr \")\"\n       | base \",\" expr\n       | \"let\" \"[a-zA-Z][_a-zA-Z]*\" target \"in\" expr\n\nbase ::= function\n       | \"~\" \"[a-zA-Z][_a-zA-Z]*\" base\n       | \"@\"\n       | argchain\n       | \"[a-zA-Z][_a-zA-Z]*\"\n\nbasepat ::= \"(\" pattern \")\"\n          | \"@\"\n          | \"[a-zA-Z][_a-zA-Z]*\"\n          | \"~\" \"[a-zA-Z][_a-zA-Z]*\" basepat\n\npattern ::= basepat\n          | basepat \",\" pattern\n\nargchain ::= \"(\" expr \")\"\n           | \"(\" expr \")\" argchain\n\ntarget ::= \":\" \"T[0-9]+\" \"=\" expr", "program": "let add : T0 = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) in\nlet square : T1 = fix (case self => (\n    case n => (mult)(n, n)\n)) in\nlet sumOfSquares : T2 = fix (case self => (\n    case (~zero @) => ~zero @\n    case n => (add)((square)(n), (self)((~pred n)))\n)) in\n@"}