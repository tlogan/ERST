{"description": "A function that takes a list and returns its length", "program": "let foo : T1 =\nfix(case self => (\n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => ~succ (self(xs)) \n)) \n;\nfoo", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of numbers and returns the sum of all even numbers in the list", "program": "let sumEven : T1 =\nfix(case self => (\n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => ~add (if ~eq (x, ~zero @) then ~zero @ else if ~eq (~mod (x, ~succ (~succ (~zero @))), ~zero @) then x else ~zero @, self(xs)) \n)) \n;\nsumEven", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of strings and returns a new list with the lengths of each string", "program": "let stringLengths : T1 =\nfix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => ~cons (~length(x), self(xs)) \n)) \n;\nstringLengths", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of numbers and returns a new list with only the numbers greater than 10", "program": "let filterGreaterThan10 : T1 =\nfix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => if ~gt (x, ~succ (~succ (~succ (~succ (~succ (~succ (~succ (~succ (~succ (~succ (~zero @))))))))))) then ~cons (x, self(xs)) else self(xs) \n)) \n;\nfilterGreaterThan10", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of booleans and returns true if all elements are true, false otherwise", "program": "let allTrue : T1 =\nfix(case self => (\n    case ~nil @ => ~true @ \n    case ~cons (x, xs) => if ~eq (x, ~true @) then self(xs) else ~false @ \n)) \n;\nallTrue", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of numbers and returns the product of all elements in the list", "program": "let product : T1 =\nfix(case self => (\n    case ~nil @ => ~succ (~zero @) \n    case ~cons (x, xs) => ~mult (x, self(xs)) \n)) \n;\nproduct", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of strings and returns a new list with only the strings containing the letter 'a'", "program": "let filterStringsContainingA : T1 =\nfix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => if ~contains (x, ~char('a')) then ~cons (x, self(xs)) else self(xs) \n)) \n;\nfilterStringsContainingA", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of numbers and returns a new list with the square of each number", "program": "let squareNumbers : T1 =\nfix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => ~cons (~mult (x, x), self(xs)) \n)) \n;\nsquareNumbers", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of strings and returns a new list with only the strings longer than 5 characters", "program": "let filterLongStrings : T1 =\nfix(case self => (\n    case ~nil @ => ~nil @ \n    case ~cons (x, xs) => if ~gt (~length(x), ~succ (~succ (~succ (~succ (~succ (~zero @)))))) then ~cons (x, self(xs)) else self(xs) \n)) \n;\nfilterLongStrings", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of numbers and returns the maximum number in the list", "program": "let maxNumber : T1 =\nfix(case self => (\n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => if ~gt (x, self(xs)) then x else self(xs) \n)) \n;\nmaxNumber", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}
{"description": "A function that takes a list of booleans and returns true if any element is true, false otherwise", "program": "let anyTrue : T1 =\nfix(case self => (\n    case ~nil @ => ~false @ \n    case ~cons (x, xs) => if ~eq (x, ~true @) then ~true @ else self(xs) \n)) \n;\nanyTrue", "grammar": "base ::= function\n       | '[a-zA-Z][_a-zA-Z]*'\n       | '~' '[a-zA-Z][_a-zA-Z]*' base\n       | '@'\n       | argchain\n\nexpr ::= base argchain\n       | 'let' '[a-zA-Z][_a-zA-Z]*' target '' expr\n       | 'fix' '(' expr ')'\n       | base\n\nbasepat ::= '@'\n          | '~' '[a-zA-Z][_a-zA-Z]*' basepat\n          | '[a-zA-Z][_a-zA-Z]*'\n          | '(' pattern ')'\n\nfunction ::= 'case' pattern '=>' expr function\n           | 'case' pattern '=>' expr\n\nargchain ::= '(' expr ')'\n\npattern ::= basepat\n          | basepat ',' pattern\n\ntarget ::= ':' 'T[0-9]+' '=' expr\n\n"}