{"program": "let unit : <extra_id_0> = @ ;\nlet true : <extra_id_1> = ~true @ ;\nlet false : <extra_id_2> = ~false @ ;\nlet zero : <extra_id_3> = ~zero @ ;\nlet one : <extra_id_4> = ~succ ~zero @ ;\nlet two : <extra_id_5> = ~succ ~succ ~zero @ ;\n@", "context": "<<TODO>>", "aliasing": "", "annotations": "<extra_id_0> @\n<extra_id_1> ~true @\n<extra_id_5> ~succ ~succ ~zero @\n<extra_id_3> ~zero @\n<extra_id_2> ~false @\n<extra_id_4> ~succ ~zero @\n"}
{"program": "let length : <extra_id_0> = fix(case self => (\n    case ~nil @ => ~zero @ \n    case ~cons (x, xs) => ~succ (self(xs)) \n)) ;\n@", "context": "<<TODO>>", "aliasing": "alias G24 = (LFP G20 ((~nil @, ~zero @) | (EXI [G8 G9 G16 ; (G9, G16) <: G20] (~cons (G8, G9), ~succ G16))))\nalias G23 = (LFP G20 (~nil @ | (EXI [G8 G9 ; G9 <: G20] ~cons (G8, G9))))\n", "annotations": "<extra_id_0> (ALL [G21 ; G21 <: G23] (G21 -> (EXI [G22 ; (G21, G22) <: G24] G22)))\n"}
{"program": "let add : <extra_id_0> = fix (case self => ( \n    case (~zero @, n) => n \n    case (~succ m, n) => ~succ (self(m, n))\n)) ;\n@", "context": "<<TODO>>", "aliasing": "alias G26 = (LFP G22 ((EXI [G21 G21 ; G19 <: G3] ((~zero @, G21), G21)) | (EXI [G8 G9 G18 ; ((G8, G9), G18) <: G22] ((~succ G8, G9), ~succ G18))))\nalias G25 = (LFP G22 ((EXI [G21 ; G19 <: G3] (~zero @, G21)) | (EXI [G8 G9 ; (G8, G9) <: G22] (~succ G8, G9))))\n", "annotations": "<extra_id_0> (ALL [G8 G3 G18 G2 G6 G9 G19 ; (G3 -> (((~zero @, G6) -> G6) & (ALL [ ; G3 <: ((G8, G9) -> G18)] ((~succ G8, G9) -> ~succ G18)))) <: G2] (ALL [G23 ; G23 <: G25] (G23 -> (EXI [G24 ; (G23, G24) <: G26] G24))))\n"}